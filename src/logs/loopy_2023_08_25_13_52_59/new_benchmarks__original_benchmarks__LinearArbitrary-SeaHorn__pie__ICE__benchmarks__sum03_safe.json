{
    "logs": {
        "file": "../new_benchmarks/original_benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  while(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
        "completions": [
            {
                "invariants": "/*@ \n    loop invariant sn == x;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == x;\n    loop invariant sn >= 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\nloop invariant i2: sn >= 0;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nloop invariant i2 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            },
            {
                "invariants": "/*@ \n  loop invariant sn == x;\n  loop invariant x >= 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\nloop invariant i2: x >= 0;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nloop invariant i2 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            },
            {
                "invariants": "//@\n  loop invariant sn == x;",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == x;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == x;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == 0 || sn == x;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == 0 || sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": false,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Unproven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == 0 || sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}",
                "checker_message_after_prune": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == x || sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x || sn == 0;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": false,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Unproven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x || sn == 0;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}",
                "checker_message_after_prune": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == x || sn == 0;\n    loop variant UINT_MAX - x;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x || sn == 0;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": false,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Unproven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x || sn == 0;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}",
                "checker_message_after_prune": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn == x;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
                "success": true,
                "checker_message": "loop invariant i1 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
            }
        ],
        "llm_conversation": [
            [
                {
                    "role": "system",
                    "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**\n"
                }
            ],
            [
                {
                    "role": "user",
                    "content": "\n\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  while(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n\n```\nOutput the loop invariants for the loop in the program above.\nLet's think step by step."
                }
            ],
            [
                {
                    "role": "assistant",
                    "content": "First, we need to identify the pre-conditions, variable assignments, and loop conditions:\n\n- Pre-conditions: None\n- Variable assignments: `sn = 0`, `loop1 = unknown_uint()`, `n1 = unknown_uint()`, `x = 0`\n- Loop condition: The while loop is an infinite loop with the condition `1`.\n\nNow, we can analyze the loop body and output the loop invariants:\n\n```\n/*@ \n    loop invariant sn == x;\n*/\n```"
                },
                {
                    "role": "assistant",
                    "content": "First, let's analyze the given program:\n\nPre-conditions or variable assignments:\n1. sn = 0\n2. loop1 and n1 are assigned unknown unsigned integers (they are not relevant to the loop)\n3. x = 0\n\nLoop condition: The loop runs indefinitely (while(1))\n\nLoop body:\n1. sn = sn + 1\n2. x++\n\nNow, let's find the necessary loop invariants:\n\n1. sn == x: This invariant holds true before the loop execution (sn and x are both 0), in every iteration of the loop (sn and x are incremented by 1), and after the loop termination (if it ever terminates, which it doesn't in this case).\n\n2. sn >= 0: This invariant holds true before the loop execution (sn is 0), in every iteration of the loop (sn is incremented by 1), and after the loop termination (if it ever terminates, which it doesn't in this case).\n\nHere are the loop invariants for the given program:\n\n```\n/*@ \n    loop invariant sn == x;\n    loop invariant sn >= 0;\n*/\n```"
                },
                {
                    "role": "assistant",
                    "content": "First, let's identify the loop condition, pre-conditions, and variable assignments:\n\n- The loop condition is `1`, which means it's an infinite loop.\n- The variables `sn` and `x` are initialized to `0`.\n- The variables `loop1` and `n1` are assigned unknown values, but they are not used in the loop.\n\nNow, let's analyze the loop body:\n\n- `sn` is incremented by `1` in each iteration.\n- `x` is incremented by `1` in each iteration.\n\nNow we can identify the loop invariants:\n\n1. The value of `sn` is equal to the value of `x`.\n2. The value of `x` is always non-negative.\n\nHere are the loop invariants for the given program:\n\n```\n/*@ \n  loop invariant sn == x;\n  loop invariant x >= 0;\n*/\n```"
                },
                {
                    "role": "assistant",
                    "content": "First, let's make a note of the variable assignments and pre-conditions in the program:\n\n- `int sn=0;`\n- `unsigned int loop1=unknown_uint(), n1=unknown_uint();`\n- `unsigned int x=0;`\n\nNext, let's analyze the loop condition and body:\n\n- The loop is an infinite loop (`while(1)`).\n- In every iteration of the loop, `sn` is incremented by 1 (`sn = sn + 1;`), and `x` is incremented by 1 (`x++;`).\n\nNow, let's output the loop invariants for this loop:\n\n```\n//@\n  loop invariant sn == x;\n```\n\nThese loop invariants are true:\n(i) before the loop execution, since `sn = 0` and `x = 0`,\n(ii) in every iteration of the loop, as both `sn` and `x` are incremented by 1,\n(iii) after the loop termination, although in this case, the loop never terminates."
                },
                {
                    "role": "assistant",
                    "content": "First, let's make a note of the pre-conditions or variable assignments in the program:\n\n1. `int sn = 0;`\n2. `unsigned int loop1 = unknown_uint();`\n3. `unsigned int n1 = unknown_uint();`\n4. `unsigned int x = 0;`\n\nNow, let's analyze the loop body and make a note of the loop condition:\n\n1. `sn = sn + 1;`\n2. `x++;`\n\nThe loop is a while(1) loop, which means it will run indefinitely. However, we can still find loop invariants that hold during the execution of the loop.\n\nHere are the necessary loop invariants for the loop in the program:\n\n```\n/*@ \n    loop invariant sn == x;\n*/\n```"
                },
                {
                    "role": "assistant",
                    "content": "First, let's make a note of the pre-conditions or variable assignments in the program:\n- `int sn = 0;`\n- `unsigned int loop1 = unknown_uint();`\n- `unsigned int n1 = unknown_uint();`\n- `unsigned int x = 0;`\n\nNext, analyze the loop body and make a note of the loop condition:\n- The loop has a `while(1)` condition, meaning it is an infinite loop.\n\nNow, let's output the loop invariants for the while loop that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply the post-condition.\n\n```\n/*@ \n    loop invariant sn == x;\n*/\n```\nThe loop invariant `sn == x` holds before the loop starts (both are initialized to 0), in every iteration of the loop (both `sn` and `x` are incremented by 1 in each iteration), and after the loop termination (though the loop is infinite and does not terminate in this case). This invariant implies the post-condition `sn == x * 1 || sn == 0`, as it is a stronger condition."
                },
                {
                    "role": "assistant",
                    "content": "First, let's analyze the given program:\n\nPre-conditions and variable assignments:\n- sn = 0\n- loop1 and n1 are assigned unknown unsigned integers (we do not know their values)\n- x = 0\n\nLoop condition:\n- The loop has no explicit condition, it is a while(1) loop, which means it runs indefinitely.\n\nLoop body:\n- sn = sn + 1\n- x++\n\nNow, let's find the loop invariants:\n\nBefore the loop execution:\n- sn = 0\n- x = 0\n\nIn every iteration of the loop:\n- sn = x * 1 (since sn and x are incremented by 1 in every iteration)\n\nAfter the loop termination:\n- The loop does not terminate, so there is no invariant for loop termination.\n\nNow, let's write the loop invariants in ACSL:\n\n```\n/*@ \n    loop invariant sn == 0 || sn == x;\n*/\n```\n\nPlease note that the loop invariants should be placed inside the loop, before the loop body. In this case, the loop does not terminate, and the post-condition is not defined. The provided invariant just describes the relationship between sn and x during the loop execution."
                },
                {
                    "role": "assistant",
                    "content": "First, let's make a note of the variable assignments and the loop condition:\n- sn = 0\n- loop1, n1 = unknown_uint()\n- x = 0\n- Loop condition: true (infinite loop)\n\nNow, let's analyze the loop body and find the necessary loop invariants:\n\n```\n/*@ \n    loop invariant sn == x || sn == 0;\n*/\n```\n\nThese invariants hold before the loop execution, in every iteration of the loop, and after the loop termination (if it ever terminates), such that the loop invariants imply the given assertion in the loop body."
                },
                {
                    "role": "assistant",
                    "content": "First, let's note the pre-conditions and variable assignments:\n- sn is initialized to 0.\n- loop1, n1, and x are initialized with unknown_uint().\n\nNow let's analyze the loop body and loop condition:\n- The loop condition is always true, so it's an infinite loop.\n- Inside the loop, sn is incremented by 1, and x is incremented by 1.\n- There is an assertion that sn must be equal to x*1 or sn must be 0.\n\nGiven this information, we can output the loop invariants:\n```\n/*@ \n    loop invariant sn == x || sn == 0;\n    loop variant UINT_MAX - x;\n*/\n```\n\nThe loop invariant `sn == x || sn == 0` is true before the loop execution, in every iteration of the loop, and after the loop termination. Since the loop is infinite, the loop variant helps with termination analysis by showing that the loop will never terminate."
                },
                {
                    "role": "assistant",
                    "content": "First, let's make a note of the pre-conditions or variable assignments in the program.\n\n`sn` is initialized to 0. `loop1`, `n1`, and `x` are initialized to unknown unsigned integers.\n\nNow, let's analyze the loop body and make a note of the loop condition.\n\nThe loop is a `while(1)` loop, meaning that it will run indefinitely until there's a break or a return statement.\n\nThe loop body contains two assignments: `sn = sn + 1;` and `x++;`, which means `sn` and `x` are incremented by 1 in each iteration.\n\nWe are now ready to output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply the post condition.\n\n```\n/*@ \n    loop invariant sn == x;\n*/\n```\n\nThis loop invariant is true before the loop execution (since both `sn` and `x` are initialized to 0), in every iteration of the loop (since both `sn` and `x` are incremented by 1), and after the loop termination (which in this case doesn't happen because the loop runs indefinitely). The loop invariant implies the post condition `sn == x * 1 || sn == 0` since `sn == x` implies that `sn == x * 1`."
                }
            ]
        ],
        "invariants": [
            "/*@ \n    loop invariant sn == x;\n*/",
            "/*@ \n    loop invariant sn == x;\n    loop invariant sn >= 0;\n*/",
            "/*@ \n  loop invariant sn == x;\n  loop invariant x >= 0;\n*/",
            "//@\n  loop invariant sn == x;",
            "/*@ \n    loop invariant sn == x;\n*/",
            "/*@ \n    loop invariant sn == x;\n*/",
            "/*@ \n    loop invariant sn == 0 || sn == x;\n*/",
            "/*@ \n    loop invariant sn == x || sn == 0;\n*/",
            "/*@ \n    loop invariant sn == x || sn == 0;\n    loop variant UINT_MAX - x;\n*/",
            "/*@ \n    loop invariant sn == x;\n*/"
        ],
        "code_with_combined_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\nloop invariant i2: sn == x;\nloop invariant i3: sn >= 0;\nloop invariant i4: sn == x;\nloop invariant i5: x >= 0;\nloop invariant i6: sn == x;\nloop invariant i7: sn == x;\nloop invariant i8: sn == x;\nloop invariant i9: sn == 0 || sn == x;\nloop invariant i10: sn == x || sn == 0;\nloop invariant i11: sn == x || sn == 0;\nloop invariant i12: sn == x;\n*/\nwhile(1){\n    sn = sn + 1;\n    x++;\n    {;//@ assert(sn==x*1 || sn == 0);\n}\n  }\n}\n",
        "checker_output": true,
        "checker_message": "loop invariant i1 is inductive.\nloop invariant i2 is inductive.\nloop invariant i3 is inductive.\nloop invariant i4 is inductive.\nloop invariant i5 is inductive.\nloop invariant i6 is inductive.\nloop invariant i7 is inductive.\nloop invariant i8 is inductive.\nloop invariant i9 is inductive.\nloop invariant i10 is inductive.\nloop invariant i11 is inductive.\nloop invariant i12 is inductive.\nAssertion sn == x * 1 || sn == 0: Valid\n"
    },
    "stats": {
        "success": [
            0,
            1,
            3,
            7,
            8,
            11,
            13,
            14,
            20,
            26,
            27,
            28,
            29,
            35,
            36,
            38,
            39,
            40,
            41,
            44,
            45,
            48,
            49,
            50,
            51,
            53,
            54,
            59,
            61,
            62,
            63,
            65,
            66,
            67,
            68,
            69,
            71,
            73,
            75,
            76,
            79,
            89,
            91,
            94,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            107,
            108,
            109,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            119,
            122,
            125,
            127,
            128,
            130,
            131,
            134,
            135,
            136,
            138,
            139,
            140,
            141,
            142,
            143,
            145,
            148,
            150,
            151,
            157,
            159,
            161,
            163,
            165,
            166,
            167,
            168,
            171,
            172,
            173,
            174,
            175,
            177,
            179,
            180,
            181,
            184,
            185,
            186,
            191,
            192,
            195,
            197,
            198,
            202,
            203,
            204,
            205,
            206,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            228,
            235,
            236,
            237
        ],
        "failure": [
            2,
            4,
            5,
            6,
            9,
            10,
            12,
            15,
            16,
            17,
            18,
            19,
            21,
            22,
            23,
            24,
            25,
            30,
            31,
            32,
            33,
            34,
            37,
            42,
            43,
            46,
            47,
            52,
            55,
            56,
            57,
            58,
            60,
            64,
            70,
            72,
            74,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            90,
            92,
            93,
            95,
            103,
            104,
            105,
            106,
            110,
            118,
            120,
            121,
            123,
            124,
            126,
            129,
            132,
            133,
            137,
            144,
            146,
            147,
            149,
            152,
            153,
            154,
            156,
            158,
            160,
            162,
            164,
            169,
            170,
            176,
            178,
            182,
            183,
            187,
            188,
            189,
            190,
            193,
            194,
            196,
            199,
            200,
            201,
            207,
            216,
            217,
            227,
            229,
            230,
            231,
            232,
            233,
            234
        ],
        "skipped": [
            77,
            78,
            80,
            155
        ],
        "total": 234,
        "success_rate": 0.5641025641025641
    }
}