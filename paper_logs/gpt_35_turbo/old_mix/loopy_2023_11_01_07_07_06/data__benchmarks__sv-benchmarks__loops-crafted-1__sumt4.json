{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt4.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  while( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}\n",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  while( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The macro `assume(e)` takes a boolean expression `e` and if it evaluates to false, it returns 0 from the function.\n- The function `unknown_uint()` returns an unsigned integer, the value of which is unknown to us.\n- The variable `SIZE` is assigned the value 20000001.\n- The variable `n` is initialized to the value returned by `unknown_uint()`.\n- The variables `i`, `k`, `j`, `l` and `v4` are initialized to 0.\n\nLoop condition:\n- The loop runs as long as the value of `l` is less than `n`.\n\nPost-condition:\n- The sum of `i`, `j`, `k` and `v4` should be equal to the final value of `l`.\n\nLoop invariants:\n1. Before the loop execution, `i`, `j`, `k`, `l` and `v4` are non-negative integers.\n```\n/*@ loop invariant i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;*/\n```\n\n2. In every iteration of the loop, the values of `i`, `j`, `k`, `l` and `v4` are non-negative integers.\n```\n/*@ loop invariant i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;*/\n```\n\n3. In every iteration of the loop, `l` is less than or equal to `n`.\n```\n/*@ loop invariant l <= n;*/\n```\n\n4. In every iteration of the loop, either `l%4`, `l%3`, `l%2` or none of them is 0. This is because the if-else blocks cover all possible cases of `l` modulo 2, 3 and 4.\n```\n/*@ loop invariant (l%4 == 0) || (l%3 == 0) || (l%2 == 0) || (l%4 != 0 && l%3 != 0 && l%2 != 0);*/\n```\n\n5. In every iteration of the loop, `v4`, `i`, `j` and `k` are non-negative integers that satisfy the following relations:\n```\n/*@ loop invariant v4 + i + j + k == l;\n    loop invariant v4 <= l/4;\n    loop invariant i <= l/3;\n    loop invariant j <= l/2;\n    loop invariant k <= l/2;\n*/\n```\n- The first invariant directly corresponds to the post-condition. It means that the sum of `v4`, `i`, `j` and `k` is equal to the final value of `l`.\n- The second invariant follows from the fact that `v4` is incremented every time `l` is a multiple of 4. Therefore, the maximum value of `v4` can be attained when `l` is a multiple of 4. In that case, `v4` would be equal to `l/4`.\n- The third invariant follows a similar reasoning as the second invariant, but for `i` and multiples of 3.\n- The fourth invariant follows a similar reasoning as the second and third invariants, but for `j` and `k` and multiples of 2.",
            "Pre-conditions: \n- The macro `assume(e)` returns 0 if the expression `e` is false.\n- The function `unknown_uint()` returns an unsigned integer whose value is not known at compile-time.\n- The variable `SIZE` is initialized to 20000001.\n\nVariable assignments:\n- `n`, `i`, `k`, `j`, `l`, and `v4` are initialized to 0.\n- `n` is assigned the value returned by `unknown_uint()`.\n\nLoop condition:\n- The loop continues as long as `l` is less than `n`.\n\nLoop invariants:\n- `0 <= i <= l`\n- `0 <= k <= l`\n- `0 <= j <= l`\n- `0 <= v4 <= l`\n- `(i + j + k + v4) == l`\n- `(l%4 == 0 ==> v4 == (l/4)) && (l%4 != 0 ==> v4 == (l/4) + 1)`\n- `(l%3 == 0 ==> i == (l/3)) && (l%3 != 0 ==> i == (l/3) + 1)`\n- `(l%2 == 0 ==> j == (l/2)) && (l%2 != 0 ==> j == (l/2) + 1)`\n\nExplanation:\n- `0 <= i <= l`: variable `i` is incremented by 1 when `l` is divisible by 3, so it is always less than or equal to `l`.\n- `0 <= k <= l`: variable `k` is incremented by 1 when `l` is not divisible by 4, 3, or 2, so it is always less than or equal to `l`.\n- `0 <= j <= l`: variable `j` is incremented by 1 when `l` is divisible by 2 but not by 3 or 4, so it is always less than or equal to `l`.\n- `0 <= v4 <= l`: variable `v4` is incremented by 1 when `l` is divisible by 4, so it is always less than or equal to `l`.\n- `(i + j + k + v4) == l`: the sum of all the increments is equal to the number of loop iterations.\n- `(l%4 == 0 ==> v4 == (l/4)) && (l%4 != 0 ==> v4 == (l/4) + 1)`: if `l` is divisible by 4, `v4` should be equal to `l/4`, otherwise it should be equal to `(l/4) + 1`.\n- `(l%3 == 0 ==> i == (l/3)) && (l%3 != 0 ==> i == (l/3) + 1)`: if `l` is divisible by 3, `i` should be equal to `l/3`, otherwise it should be equal to `(l/3) + 1`.\n- `(l%2 == 0 ==> j == (l/2)) && (l%2 != 0 ==> j == (l/2) + 1)`: if `l` is divisible by 2, `j` should be equal to `l/2`, otherwise it should be equal to `(l/2) + 1`.",
            "First, let's note the pre-conditions and variable assignments in the program:\n- The macro `assume(e)` checks if the expression `e` is true, and if not, returns 0. \n- The function `unknown_uint()` returns an unsigned integer with unknown value. \n- The variable `SIZE` is assigned a value of 20000001.\n- The variables `n`, `i`, `k`, `j`, `l`, `v4` are declared and assigned initial values of 0.\n\nNext, let's analyze the loop body and the loop condition:\n- The loop condition is `l < n`, which means that the loop will execute as long as `l` is less than `n`. \n- The loop body contains conditional statements that increment the variables `i`, `j`, `k`, or `v4` depending on the value of `l`.\n\nBased on the program analysis above, we can come up with the following loop invariants:\n```\n/*@\n  loop invariant 0 <= l <= n;\n  loop invariant 0 <= i+j+k+v4 <= l;\n  loop invariant v4 <= l/4;\n  loop invariant i <= l/3;\n  loop invariant j <= l/2;\n*/\n```\n\nExplanation:\n- The first invariant `0 <= l <= n` ensures that `l` remains within the bounds of 0 and `n` throughout the loop execution. \n- The second invariant `0 <= i+j+k+v4 <= l` ensures that the sum of `i`, `j`, `k`, and `v4` is always less than or equal to `l`, which is the number of loop iterations. \n- The third invariant `v4 <= l/4` ensures that the variable `v4` is incremented at most once every 4 iterations of the loop. \n- The fourth invariant `i <= l/3` ensures that the variable `i` is incremented at most once every 3 iterations of the loop. \n- The fifth invariant `j <= l/2` ensures that the variable `j` is incremented at most once every 2 iterations of the loop. \n\nFinally, we can use the guard condition in an implication to modify the second invariant:\n```\n/*@\n  loop invariant 0 <= l <= n;\n  loop invariant (l%4==0 ==> v4 <= l/4) && (l%4!=0 ==> v4 < l/4);\n  loop invariant (l%3==0 ==> i <= l/3) && (l%3!=0 ==> i < l/3);\n  loop invariant (l%2==0 ==> j <= l/2) && (l%2!=0 ==> j < l/2);\n  loop invariant 0 <= i+j+k+v4 <= l;\n*/\n```\nIn the modified invariants, we use implications to ensure that `v4`, `i`, and `j` are incremented at most once every 4, 3, and 2 iterations of the loop respectively, depending on their respective remainder when divided by 4, 3, and 2. \n\nThese loop invariants, together with the pre-conditions and the post-condition assertion, can be used to verify that the post-condition holds after the loop terminates.",
            "Pre-conditions:\n- `SIZE` is a constant integer with value 20000001.\n- There is an external function `unknown_uint` that returns an unsigned integer value.\n- The program initializes variables `n`, `i`, `k`, `j`, `l`, and `v4` to 0.\n\nLoop condition:\n- The while loop executes while the value of `l` is less than `n`.\n\nLoop invariants:\n- `0 <= l <= n` (bounds `l` to be between 0 and `n`, both inclusive)\n- `0 <= i <= l` (bounds `i` to be between 0 and `l`, both inclusive)\n- `0 <= j <= l` (bounds `j` to be between 0 and `l`, both inclusive)\n- `0 <= k <= l` (bounds `k` to be between 0 and `l`, both inclusive)\n- `v4 + i + j + k = (l - 1) / 4` (the number of times `l` is divisible by 4 is equal to `v4`)\n- `v4 + i + j + k = (l - 1) / 3` (the number of times `l` is divisible by 3 is equal to `i`)\n- `v4 + i + j + k = (l - 1) / 2` (the number of times `l` is divisible by 2 is equal to `j`)\n- `(l >= n) ==> (i+j+k+v4) == l` (if the loop terminates, then the sum of `i`, `j`, `k`, and `v4` is equal to `l`) \n\nExplanation:\n- The first four loop invariants bound the maximum and minimum values that `i`, `j`, `k`, and `l` can take. Since `v4` is updated only when `l` is divisible by 4, `v4` is the count of numbers between 0 and `l-1` that are divisible by 4. Thus, the fifth loop invariant is derived by counting the number of such numbers, and equating it to `v4`. The sixth loop invariant is derived in a similar way for the numbers that are divisible by 3. The seventh loop invariant is derived in a similar way for the numbers that are divisible by 2. The last loop invariant relates the loop variables to the post-condition of the program. It uses implication to handle the case where the loop does not execute at all (i.e., when `n` is less than or equal to 0). Note that the loop invariants hold true for all iterations of the loop.",
            "**Step 1: Pre-conditions and variable assignments**\n\nThe program defines a macro `assume` which is used to terminate the program if the argument is false. It also defines an external function `unknown_uint` which returns an unsigned integer with an unknown value.\n\nThe program initializes a variable `SIZE` to `20000001`. \n\nThe program then declares and initializes four unsigned integer variables `n`, `i`, `j`, and `k`, and initializes them to `0`. It also declares another unsigned integer variable `l` and initializes it to `0`. Finally, it declares an unsigned integer variable `v4` and initializes it to `0`.\n\nThe program reads a non-deterministic value into `n` using the `unknown_uint` function. It then checks if `n` is less than or equal to `SIZE`. If `n` is greater than `SIZE`, the program terminates.\n\n**Step 2: Loop condition**\n\nThe program has a while loop with the condition `l < n`.\n\n**Step 3: Loop invariants**\n\nWe need to find loop invariants that are true:\n\n(i) before the loop execution, \n\n(ii) in every iteration of the loop and \n\n(iii) after the loop termination.\n\nLet's consider each of these in turn:\n\n(i) Before the loop execution, the following loop invariants hold:\n```\n/*@ loop invariant 0 <= n <= SIZE;\n    loop invariant i == 0;\n    loop invariant j == 0;\n    loop invariant k == 0;\n    loop invariant l == 0;\n    loop invariant v4 == 0;\n*/\n```\nThe first loop invariant states that `n` is between `0` and `SIZE`, which is the maximum value that `n` can take. The second, third, fourth, and fifth loop invariants state that `i`, `j`, `k`, and `l` are all equal to `0` before the loop starts. The last loop invariant states that `v4` is also equal to `0` before the loop starts.\n\n(ii) In every iteration of the loop, the following loop invariants hold:\n```\n/*@ loop invariant 0 <= l <= n;\n    loop invariant (l%4 == 0) ==> (v4 > 0);\n    loop invariant (l%4 != 0) ==> (v4 == 0);\n    loop invariant (l%3 == 0) ==> (i > 0);\n    loop invariant (l%3 != 0) ==> (i == 0);\n    loop invariant (l%2 == 0) ==> (j > 0);\n    loop invariant (l%2 != 0) ==> (j == 0);\n    loop invariant (l%2 != 0) ==> (k > 0);\n    loop invariant (l%2 == 0) ==> (k == 0);\n*/\n```\nThe first loop invariant states that `l` is between `0` and `n`, which is the maximum value that `l` can take. The remaining loop invariants are based on the conditional statements in the loop body. \n\nFor example, the loop invariant `(l%4 == 0) ==> (v4 > 0)` states that if `l` is a multiple of `4`, then `v4` must be greater than `0`. Similarly, the loop invariant `(l%4 != 0) ==> (v4 == 0)` states that if `l` is not a multiple of `4`, then `v4` must be equal to `0`.\n\n(iii) After the loop termination, the following loop invariant holds:\n```\n/*@ assert (i+j+k+v4) == l;\n*/\n```\nThis loop invariant states that the sum of `i`, `j`, `k`, and `v4` must be equal to `l` after the loop terminates. \n\n**Step 4: Putting it all together**\n\nPutting all of the loop invariants together, we get:\n```\n/*@ \n    loop invariant 0 <= n <= SIZE;\n    loop invariant i == 0;\n    loop invariant j == 0;\n    loop invariant k == 0;\n    loop invariant l == 0;\n    loop invariant v4 == 0;\n\n    loop invariant 0 <= l <= n;\n    loop invariant (l%4 == 0) ==> (v4 > 0);\n    loop invariant (l%4 != 0) ==> (v4 == 0);\n    loop invariant (l%3 == 0) ==> (i > 0);\n    loop invariant (l%3 != 0) ==> (i == 0);\n    loop invariant (l%2 == 0) ==> (j > 0);\n    loop invariant (l%2 != 0) ==> (j"
        ],
        "annotation_blocks": [
            "/*@ loop invariant i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions: \n- The macro `assume(e)` returns 0 if the expression `e` is false.\n- The function `unknown_uint()` returns an unsigned integer whose value is not known at compile-time.\n- The variable `SIZE` is initialized to 20000001.\n\nVariable assignments:\n- `n`, `i`, `k`, `j`, `l`, and `v4` are initialized to 0.\n- `n` is assigned the value returned by `unknown_uint()`.\n\nLoop condition:\n- The loop continues as long as `l` is less than `n`.\n\nLoop invariants:\n- `0 <= i <= l`\n- `0 <= k <= l`\n- `0 <= j <= l`\n- `0 <= v4 <= l`\n- `(i + j + k + v4) == l`\n- `(l%4 == 0 ==> v4 == (l/4)) && (l%4 != 0 ==> v4 == (l/4) + 1)`\n- `(l%3 == 0 ==> i == (l/3)) && (l%3 != 0 ==> i == (l/3) + 1)`\n- `(l%2 == 0 ==> j == (l/2)) && (l%2 != 0 ==> j == (l/2) + 1)`\n\nExplanation:\n- `0 <= i <= l`: variable `i` is incremented by 1 when `l` is divisible by 3, so it is always less than or equal to `l`.\n- `0 <= k <= l`: variable `k` is incremented by 1 when `l` is not divisible by 4, 3, or 2, so it is always less than or equal to `l`.\n- `0 <= j <= l`: variable `j` is incremented by 1 when `l` is divisible by 2 but not by 3 or 4, so it is always less than or equal to `l`.\n- `0 <= v4 <= l`: variable `v4` is incremented by 1 when `l` is divisible by 4, so it is always less than or equal to `l`.\n- `(i + j + k + v4) == l`: the sum of all the increments is equal to the number of loop iterations.\n- `(l%4 == 0 ==> v4 == (l/4)) && (l%4 != 0 ==> v4 == (l/4) + 1)`: if `l` is divisible by 4, `v4` should be equal to `l/4`, otherwise it should be equal to `(l/4) + 1`.\n- `(l%3 == 0 ==> i == (l/3)) && (l%3 != 0 ==> i == (l/3) + 1)`: if `l` is divisible by 3, `i` should be equal to `l/3`, otherwise it should be equal to `(l/3) + 1`.\n- `(l%2 == 0 ==> j == (l/2)) && (l%2 != 0 ==> j == (l/2) + 1)`: if `l` is divisible by 2, `j` should be equal to `l/2`, otherwise it should be equal to `(l/2) + 1`."
            ],
            "/*@\n  loop invariant 0 <= l <= n;\n  loop invariant 0 <= i+j+k+v4 <= l;\n  loop invariant v4 <= l/4;\n  loop invariant i <= l/3;\n  loop invariant j <= l/2;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- `SIZE` is a constant integer with value 20000001.\n- There is an external function `unknown_uint` that returns an unsigned integer value.\n- The program initializes variables `n`, `i`, `k`, `j`, `l`, and `v4` to 0.\n\nLoop condition:\n- The while loop executes while the value of `l` is less than `n`.\n\nLoop invariants:\n- `0 <= l <= n` (bounds `l` to be between 0 and `n`, both inclusive)\n- `0 <= i <= l` (bounds `i` to be between 0 and `l`, both inclusive)\n- `0 <= j <= l` (bounds `j` to be between 0 and `l`, both inclusive)\n- `0 <= k <= l` (bounds `k` to be between 0 and `l`, both inclusive)\n- `v4 + i + j + k = (l - 1) / 4` (the number of times `l` is divisible by 4 is equal to `v4`)\n- `v4 + i + j + k = (l - 1) / 3` (the number of times `l` is divisible by 3 is equal to `i`)\n- `v4 + i + j + k = (l - 1) / 2` (the number of times `l` is divisible by 2 is equal to `j`)\n- `(l >= n) ==> (i+j+k+v4) == l` (if the loop terminates, then the sum of `i`, `j`, `k`, and `v4` is equal to `l`) \n\nExplanation:\n- The first four loop invariants bound the maximum and minimum values that `i`, `j`, `k`, and `l` can take. Since `v4` is updated only when `l` is divisible by 4, `v4` is the count of numbers between 0 and `l-1` that are divisible by 4. Thus, the fifth loop invariant is derived by counting the number of such numbers, and equating it to `v4`. The sixth loop invariant is derived in a similar way for the numbers that are divisible by 3. The seventh loop invariant is derived in a similar way for the numbers that are divisible by 2. The last loop invariant relates the loop variables to the post-condition of the program. It uses implication to handle the case where the loop does not execute at all (i.e., when `n` is less than or equal to 0). Note that the loop invariants hold true for all iterations of the loop."
            ],
            "/*@ loop invariant 0 <= n <= SIZE;\n    loop invariant i == 0;\n    loop invariant j == 0;\n    loop invariant k == 0;\n    loop invariant l == 0;\n    loop invariant v4 == 0;\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ loop invariant i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0 is inductive.\nAssertion ((i + j) + k) + v4 == l: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  /*@\nloop invariant i1: i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}\n",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions: \n- The macro `assume(e)` returns 0 if the expression `e` is false.\n- The function `unknown_uint()` returns an unsigned integer whose value is not known at compile-time.\n- The variable `SIZE` is initialized to 20000001.\n\nVariable assignments:\n- `n`, `i`, `k`, `j`, `l`, and `v4` are initialized to 0.\n- `n` is assigned the value returned by `unknown_uint()`.\n\nLoop condition:\n- The loop continues as long as `l` is less than `n`.\n\nLoop invariants:\n- `0 <= i <= l`\n- `0 <= k <= l`\n- `0 <= j <= l`\n- `0 <= v4 <= l`\n- `(i + j + k + v4) == l`\n- `(l%4 == 0 ==> v4 == (l/4)) && (l%4 != 0 ==> v4 == (l/4) + 1)`\n- `(l%3 == 0 ==> i == (l/3)) && (l%3 != 0 ==> i == (l/3) + 1)`\n- `(l%2 == 0 ==> j == (l/2)) && (l%2 != 0 ==> j == (l/2) + 1)`\n\nExplanation:\n- `0 <= i <= l`: variable `i` is incremented by 1 when `l` is divisible by 3, so it is always less than or equal to `l`.\n- `0 <= k <= l`: variable `k` is incremented by 1 when `l` is not divisible by 4, 3, or 2, so it is always less than or equal to `l`.\n- `0 <= j <= l`: variable `j` is incremented by 1 when `l` is divisible by 2 but not by 3 or 4, so it is always less than or equal to `l`.\n- `0 <= v4 <= l`: variable `v4` is incremented by 1 when `l` is divisible by 4, so it is always less than or equal to `l`.\n- `(i + j + k + v4) == l`: the sum of all the increments is equal to the number of loop iterations.\n- `(l%4 == 0 ==> v4 == (l/4)) && (l%4 != 0 ==> v4 == (l/4) + 1)`: if `l` is divisible by 4, `v4` should be equal to `l/4`, otherwise it should be equal to `(l/4) + 1`.\n- `(l%3 == 0 ==> i == (l/3)) && (l%3 != 0 ==> i == (l/3) + 1)`: if `l` is divisible by 3, `i` should be equal to `l/3`, otherwise it should be equal to `(l/3) + 1`.\n- `(l%2 == 0 ==> j == (l/2)) && (l%2 != 0 ==> j == (l/2) + 1)`: if `l` is divisible by 2, `j` should be equal to `l/2`, otherwise it should be equal to `(l/2) + 1`.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@\n  loop invariant 0 <= l <= n;\n  loop invariant 0 <= i+j+k+v4 <= l;\n  loop invariant v4 <= l/4;\n  loop invariant i <= l/3;\n  loop invariant j <= l/2;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= l <= n is partially proven to be inductive.\nloop invariant 0 <= i+j+k+v4 <= l is partially proven to be inductive.\nloop invariant v4 <= l/4 is established but not preserved.\nloop invariant i <= l/3 is established but not preserved.\nloop invariant j <= l/2 is established but not preserved.\nAssertion ((i + j) + k) + v4 == l: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  /*@\nloop invariant i1: 0 <= l <= n;\nloop invariant i2: 0 <= i+j+k+v4 <= l;\n\n\n\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- `SIZE` is a constant integer with value 20000001.\n- There is an external function `unknown_uint` that returns an unsigned integer value.\n- The program initializes variables `n`, `i`, `k`, `j`, `l`, and `v4` to 0.\n\nLoop condition:\n- The while loop executes while the value of `l` is less than `n`.\n\nLoop invariants:\n- `0 <= l <= n` (bounds `l` to be between 0 and `n`, both inclusive)\n- `0 <= i <= l` (bounds `i` to be between 0 and `l`, both inclusive)\n- `0 <= j <= l` (bounds `j` to be between 0 and `l`, both inclusive)\n- `0 <= k <= l` (bounds `k` to be between 0 and `l`, both inclusive)\n- `v4 + i + j + k = (l - 1) / 4` (the number of times `l` is divisible by 4 is equal to `v4`)\n- `v4 + i + j + k = (l - 1) / 3` (the number of times `l` is divisible by 3 is equal to `i`)\n- `v4 + i + j + k = (l - 1) / 2` (the number of times `l` is divisible by 2 is equal to `j`)\n- `(l >= n) ==> (i+j+k+v4) == l` (if the loop terminates, then the sum of `i`, `j`, `k`, and `v4` is equal to `l`) \n\nExplanation:\n- The first four loop invariants bound the maximum and minimum values that `i`, `j`, `k`, and `l` can take. Since `v4` is updated only when `l` is divisible by 4, `v4` is the count of numbers between 0 and `l-1` that are divisible by 4. Thus, the fifth loop invariant is derived by counting the number of such numbers, and equating it to `v4`. The sixth loop invariant is derived in a similar way for the numbers that are divisible by 3. The seventh loop invariant is derived in a similar way for the numbers that are divisible by 2. The last loop invariant relates the loop variables to the post-condition of the program. It uses implication to handle the case where the loop does not execute at all (i.e., when `n` is less than or equal to 0). Note that the loop invariants hold true for all iterations of the loop.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@ loop invariant 0 <= n <= SIZE;\n    loop invariant i == 0;\n    loop invariant j == 0;\n    loop invariant k == 0;\n    loop invariant l == 0;\n    loop invariant v4 == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= n <= SIZE is partially proven to be inductive.\nloop invariant i == 0 is partially proven to be inductive.\nloop invariant j == 0 is partially proven to be inductive.\nloop invariant k == 0 is partially proven to be inductive.\nloop invariant l == 0 is established but not preserved.\nloop invariant v4 == 0 is partially proven to be inductive.\nAssertion ((i + j) + k) + v4 == l: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  /*@\nloop invariant i1: 0 <= n <= SIZE;\n\n\n\n\n\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0 is partially proven to be inductive.\nloop invariant 0 <= l <= n is partially proven to be inductive.\nloop invariant 0 <= i+j+k+v4 <= l is partially proven to be inductive.\nloop invariant v4 <= l/4 is established but not preserved.\nloop invariant i <= l/3 is partially proven to be inductive.\nloop invariant j <= l/2 is partially proven to be inductive.\nloop invariant 0 <= n <= SIZE is partially proven to be inductive.\nloop invariant i == 0 is partially proven to be inductive.\nloop invariant j == 0 is partially proven to be inductive.\nloop invariant k == 0 is partially proven to be inductive.\nloop invariant l == 0 is partially proven to be inductive.\nloop invariant v4 == 0 is partially proven to be inductive.\nAssertion ((i + j) + k) + v4 == l: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  /*@\nloop invariant i1: i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;\nloop invariant i2: 0 <= l <= n;\nloop invariant i3: 0 <= i+j+k+v4 <= l;\nloop invariant i4: v4 <= l/4;\nloop invariant i5: i <= l/3;\nloop invariant i6: j <= l/2;\nloop invariant i7: 0 <= n <= SIZE;\nloop invariant i8: i == 0;\nloop invariant i9: j == 0;\nloop invariant i10: k == 0;\nloop invariant i11: l == 0;\nloop invariant i12: v4 == 0;\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}\n",
        "combined_annotation_num_solver_calls": 6,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n=0,i=0,k=0,j=0,l=0;\n  unsigned int v4=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  /*@\nloop invariant i1: i >= 0 && j >= 0 && k >= 0 && l >= 0 && v4 >= 0;\nloop invariant i2: 0 <= l <= n;\nloop invariant i3: 0 <= i+j+k+v4 <= l;\n\n\n\nloop invariant i7: 0 <= n <= SIZE;\n\n\n\n\n\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%4))\n\t    v4 = v4 + 1;\n\t  else if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k+v4) == l);\n}\n\n  return 0;\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/NetBSD_loop.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/afnp2014.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/css2003.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007b.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gsv2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/hhk2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_2.c",
            "../data/benchmarks/sv-benchmarks/loop-new/gauss_sum.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark01_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark02_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark04_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark05_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark06_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark08_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark10_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark11_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark13_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark14_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark15_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark16_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark17_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark18_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark20_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark21_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark22_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark23_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark25_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark26_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark27_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark29_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark30_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark31_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark32_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark33_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark34_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark35_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark36_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark37_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark38_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark39_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark40_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark41_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark42_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark43_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark45_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark48_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark49_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark50_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark51_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark52_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark53_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum04-2.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_02-2.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/trex03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/while_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/while_infinite_loop_2.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/loopv1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/loopv3.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt2.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt3.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/even.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/mod4.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/odd.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/id_trans.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/bhmr2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/ddlm2013.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gcnr2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gr2006.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_k.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_nondet.c",
            "../data/benchmarks/sv-benchmarks/loop-new/half.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark03_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark07_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark09_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark12_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark19_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark24_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark28_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark44_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark46_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark47_linear.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-2.c",
            "../data/benchmarks/sv-benchmarks/loops/for_bounded_loop1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02_sum01_bug02_base.case.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum04-1.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_02-1.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/trex03-1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/iftelse.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_10.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_12.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_6.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_8.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_9.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono4_1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono5_1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono6_1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt4.c"
        ],
        "skipped": [],
        "total": 395,
        "success_count": 202,
        "failure_count": 193,
        "success_rate": 0.5113924050632911
    }
}