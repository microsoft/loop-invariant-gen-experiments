{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(){\n  int  sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int  x=0;\n  while(1){\n      if(x<10){\n          sn = sn +(2);\n      }\n      x++;\n      {;\n//@ assert(sn==x*(2)|| sn == 0);\n}\n\n  }\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(){\n  int  sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int  x=0;\n  while(1){\n      if(x<10){\n          sn = sn +(2);\n      }\n      x++;\n      {;\n//@ assert(sn==x*(2)|| sn == 0);\n}\n\n  }\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "First, let's analyze the program and make a note of the pre-conditions and variable assignments:\n\n- The program defines a macro `assume(e)` which returns 0 if the expression `e` is false.\n- The program declares an external function `unknown_uint()` which returns an unsigned integer value.\n- The program initializes variables `loop1` and `n1` with the results of calls to `unknown_uint()`.\n- The program initializes variable `x` to 0.\n- The program enters an infinite loop.\n- Inside the loop, if `x` is less than 10, it updates variable `sn` by adding 2.\n- The loop increments `x` by 1 in each iteration.\n- The program contains an assertion that checks if `sn` is equal to `x*(2)` or `0`.\n\nNow, let's analyze the loop body and make a note of the loop condition:\n\n- The loop condition is `while(1)` which means the loop will execute indefinitely.\n\nBased on the above analysis, we can come up with the following loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= x <= UINT_MAX;\n    loop invariant sn == (x*(2)) || sn == 0;\n*/\n```\n\nExplanation:\n\n- The first loop invariant `0 <= x <= UINT_MAX` bounds the value of `x` to be within the range of unsigned integers.\n- The second loop invariant `sn == (x*(2)) || sn == 0` checks if the updated value of `sn` is either equal to `x*(2)` or `0`. This is consistent with the code inside the loop and the assertion after the loop.\n\nWe do not need to add any additional constraints for `loop1`, `n1`, or `unknown_uint()` because they are not used in the loop and do not affect the loop invariants.\n\nNote that we do not need to add any implications because there are no non-deterministic values or conditional statements that affect the loop invariants.",
            "Pre-conditions: None\n\nVariable assignments:\n- Initialize `sn` to 0\n- Initialize `loop1` and `n1` to non-deterministic unsigned integers\n- Initialize `x` to 0\n\nLoop condition: The loop runs indefinitely as the condition is `while(1)`\n\nLoop body: \n- If `x` is less than 10, add 2 to `sn`\n- Increment `x`\n- Check that `sn` is equal to `x*2` or 0 using the assertion\n\nLoop invariants:\n- Before the loop execution:\n    - `sn >= 0`\n    - `x == 0`\n    - `loop1 >= 0`\n    - `n1 >= 0`\n\n- In every iteration:\n    - `x >= 0`\n    - `sn == x*2 || sn == 0`\n    - `loop1 >= 0`\n    - `n1 >= 0`\n\n- After the loop termination:\n    - `sn == x*2 || sn == 0`\n\nExplanation:\n- Before the loop starts, `sn` is initialized to 0 and `x` is initialized to 0. Both variables have a lower bound of 0.\n- In every iteration, `x` is incremented and `sn` is either increased by 2 or remains the same. Therefore, `x` is always greater than or equal to 0 and `sn` is always equal to `x*2` or 0.\n- After the loop termination, the value of `sn` is either equal to `x*2` or 0, which is exactly what the assertion is checking for.",
            "Pre-conditions:\n- None\n\nVariable Assignments:\n- sn is assigned 0\n- loop1 is assigned the result of unknown_uint() function\n- n1 is assigned the result of unknown_uint() function\n- x is assigned 0\n\nLoop Condition:\n- The loop runs indefinitely, so the condition is always true (1).\n\nLoop Invariants:\n- Before the loop execution:\n    - sn == 0\n    - x == 0\n- In every iteration of the loop:\n    - x >= 0\n    - sn == x*(2) || sn == 0\n- After the loop termination:\n    - x >= 10 ==> sn == 20\n    - x < 10 ==> sn == x*(2) || sn == 0\n\nExplanation:\n- Before the loop execution, we know that sn is 0 and x is 0.\n- In every iteration of the loop, we know that x is non-negative and sn can only be equal to x*(2) or 0, based on the condition in the loop.\n- After the loop termination, we know that if x is greater than or equal to 10, then sn must be equal to 20. Otherwise, sn can only be equal to x*(2) or 0, based on the condition in the loop.",
            "Pre-conditions:\n- None.\n\nVariable Assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the result of `unknown_uint()` function.\n- `n1` is assigned the result of `unknown_uint()` function.\n- `x` is initialized to 0.\n\nLoop condition:\n- The while loop runs indefinitely, so the loop condition is always true.\n\nLoop Invariants:\n- `0 <= x <= loop1`\n- `0 <= n1`\n- `sn == x*2 || sn == 0`\n- `x <= 10 ==> sn <= x*2`\n- `x > 10 ==> sn == 20`\n\nExplanation:\n- The first loop invariant specifies that `x` is always between 0 and `loop1`.\n- The second loop invariant specifies that `n1` is always non-negative.\n- The third loop invariant specifies that `sn` is either equal to `x*2` or 0 at the end of each iteration of the loop.\n- The fourth loop invariant specifies that if `x` is less than or equal to 10, then `sn` is less than or equal to `x*2`. This is because `sn` is incremented by 2 for each iteration of the loop where `x` is less than 10.\n- The fifth loop invariant specifies that if `x` is greater than 10, then `sn` is equal to 20. This is because after `x` becomes greater than 10, `sn` is not incremented anymore.\n\nPutting it all together:\n```\n/*@ \n    loop invariant 0 <= x <= loop1;\n    loop invariant 0 <= n1;\n    loop invariant sn == x*2 || sn == 0;\n    loop invariant x <= 10 ==> sn <= x*2;\n    loop invariant x > 10 ==> sn == 20;\n*/\n```",
            "Pre-conditions:\n- The program does not have any pre-conditions.\n- `unknown_uint()` returns a non-deterministic unsigned integer value.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned a non-deterministic unsigned integer value.\n- `n1` is assigned a non-deterministic unsigned integer value.\n- `x` is initialized to 0.\n\nLoop condition:\n- The loop is an infinite loop and runs until the program is terminated.\n\nLoop invariants:\n- `sn >= 0`\n- `x >= 0`\n- `sn == x * 2 ==> x <= 10`\n- `sn == 0 ==> x > 10`\n- `sn == x * 2 || sn == 0`\n\nExplanation:\n- Since `sn` is initially assigned 0 and only increases by 2 in each iteration, `sn` is always non-negative.\n- Since `x` is initially assigned 0 and only increases by 1 in each iteration, `x` is always non-negative.\n- If `sn` is equal to `x * 2`, then `x` cannot be larger than 10 because the loop condition checks if `x` is less than 10. So, `sn == x * 2 ==> x <= 10`.\n- If `sn` is equal to 0, then `x` must be larger than 10 because the loop condition checks if `x` is less than 10. So, `sn == 0 ==> x > 10`.\n- The assertion `sn==x*(2)|| sn == 0` holds true in every iteration of the loop because either `sn` is equal to `x * 2` or `sn` is equal to 0."
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant 0 <= x <= UINT_MAX;\n    loop invariant sn == (x*(2)) || sn == 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions: None\n\nVariable assignments:\n- Initialize `sn` to 0\n- Initialize `loop1` and `n1` to non-deterministic unsigned integers\n- Initialize `x` to 0\n\nLoop condition: The loop runs indefinitely as the condition is `while(1)`\n\nLoop body: \n- If `x` is less than 10, add 2 to `sn`\n- Increment `x`\n- Check that `sn` is equal to `x*2` or 0 using the assertion\n\nLoop invariants:\n- Before the loop execution:\n    - `sn >= 0`\n    - `x == 0`\n    - `loop1 >= 0`\n    - `n1 >= 0`\n\n- In every iteration:\n    - `x >= 0`\n    - `sn == x*2 || sn == 0`\n    - `loop1 >= 0`\n    - `n1 >= 0`\n\n- After the loop termination:\n    - `sn == x*2 || sn == 0`\n\nExplanation:\n- Before the loop starts, `sn` is initialized to 0 and `x` is initialized to 0. Both variables have a lower bound of 0.\n- In every iteration, `x` is incremented and `sn` is either increased by 2 or remains the same. Therefore, `x` is always greater than or equal to 0 and `sn` is always equal to `x*2` or 0.\n- After the loop termination, the value of `sn` is either equal to `x*2` or 0, which is exactly what the assertion is checking for."
            ],
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None\n\nVariable Assignments:\n- sn is assigned 0\n- loop1 is assigned the result of unknown_uint() function\n- n1 is assigned the result of unknown_uint() function\n- x is assigned 0\n\nLoop Condition:\n- The loop runs indefinitely, so the condition is always true (1).\n\nLoop Invariants:\n- Before the loop execution:\n    - sn == 0\n    - x == 0\n- In every iteration of the loop:\n    - x >= 0\n    - sn == x*(2) || sn == 0\n- After the loop termination:\n    - x >= 10 ==> sn == 20\n    - x < 10 ==> sn == x*(2) || sn == 0\n\nExplanation:\n- Before the loop execution, we know that sn is 0 and x is 0.\n- In every iteration of the loop, we know that x is non-negative and sn can only be equal to x*(2) or 0, based on the condition in the loop.\n- After the loop termination, we know that if x is greater than or equal to 10, then sn must be equal to 20. Otherwise, sn can only be equal to x*(2) or 0, based on the condition in the loop."
            ],
            "/*@ \n    loop invariant 0 <= x <= loop1;\n    loop invariant 0 <= n1;\n    loop invariant sn == x*2 || sn == 0;\n    loop invariant x <= 10 ==> sn <= x*2;\n    loop invariant x > 10 ==> sn == 20;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The program does not have any pre-conditions.\n- `unknown_uint()` returns a non-deterministic unsigned integer value.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned a non-deterministic unsigned integer value.\n- `n1` is assigned a non-deterministic unsigned integer value.\n- `x` is initialized to 0.\n\nLoop condition:\n- The loop is an infinite loop and runs until the program is terminated.\n\nLoop invariants:\n- `sn >= 0`\n- `x >= 0`\n- `sn == x * 2 ==> x <= 10`\n- `sn == 0 ==> x > 10`\n- `sn == x * 2 || sn == 0`\n\nExplanation:\n- Since `sn` is initially assigned 0 and only increases by 2 in each iteration, `sn` is always non-negative.\n- Since `x` is initially assigned 0 and only increases by 1 in each iteration, `x` is always non-negative.\n- If `sn` is equal to `x * 2`, then `x` cannot be larger than 10 because the loop condition checks if `x` is less than 10. So, `sn == x * 2 ==> x <= 10`.\n- If `sn` is equal to 0, then `x` must be larger than 10 because the loop condition checks if `x` is less than 10. So, `sn == 0 ==> x > 10`.\n- The assertion `sn==x*(2)|| sn == 0` holds true in every iteration of the loop because either `sn` is equal to `x * 2` or `sn` is equal to 0."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant 0 <= x <= UINT_MAX;\n    loop invariant sn == (x*(2)) || sn == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 9: unbound logic variable UINT_MAX. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(){\n  int  sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int  x=0;\n  /*@\n\nloop invariant i2: sn == (x*(2)) || sn == 0;\n*/\nwhile(1){\n      if(x<10){\n          sn = sn +(2);\n      }\n      x++;\n      {;\n//@ assert(sn==x*(2)|| sn == 0);\n}\n\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions: None\n\nVariable assignments:\n- Initialize `sn` to 0\n- Initialize `loop1` and `n1` to non-deterministic unsigned integers\n- Initialize `x` to 0\n\nLoop condition: The loop runs indefinitely as the condition is `while(1)`\n\nLoop body: \n- If `x` is less than 10, add 2 to `sn`\n- Increment `x`\n- Check that `sn` is equal to `x*2` or 0 using the assertion\n\nLoop invariants:\n- Before the loop execution:\n    - `sn >= 0`\n    - `x == 0`\n    - `loop1 >= 0`\n    - `n1 >= 0`\n\n- In every iteration:\n    - `x >= 0`\n    - `sn == x*2 || sn == 0`\n    - `loop1 >= 0`\n    - `n1 >= 0`\n\n- After the loop termination:\n    - `sn == x*2 || sn == 0`\n\nExplanation:\n- Before the loop starts, `sn` is initialized to 0 and `x` is initialized to 0. Both variables have a lower bound of 0.\n- In every iteration, `x` is incremented and `sn` is either increased by 2 or remains the same. Therefore, `x` is always greater than or equal to 0 and `sn` is always equal to `x*2` or 0.\n- After the loop termination, the value of `sn` is either equal to `x*2` or 0, which is exactly what the assertion is checking for.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None\n\nVariable Assignments:\n- sn is assigned 0\n- loop1 is assigned the result of unknown_uint() function\n- n1 is assigned the result of unknown_uint() function\n- x is assigned 0\n\nLoop Condition:\n- The loop runs indefinitely, so the condition is always true (1).\n\nLoop Invariants:\n- Before the loop execution:\n    - sn == 0\n    - x == 0\n- In every iteration of the loop:\n    - x >= 0\n    - sn == x*(2) || sn == 0\n- After the loop termination:\n    - x >= 10 ==> sn == 20\n    - x < 10 ==> sn == x*(2) || sn == 0\n\nExplanation:\n- Before the loop execution, we know that sn is 0 and x is 0.\n- In every iteration of the loop, we know that x is non-negative and sn can only be equal to x*(2) or 0, based on the condition in the loop.\n- After the loop termination, we know that if x is greater than or equal to 10, then sn must be equal to 20. Otherwise, sn can only be equal to x*(2) or 0, based on the condition in the loop.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant 0 <= x <= loop1;\n    loop invariant 0 <= n1;\n    loop invariant sn == x*2 || sn == 0;\n    loop invariant x <= 10 ==> sn <= x*2;\n    loop invariant x > 10 ==> sn == 20;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= x <= loop1 is established but not preserved.\nloop invariant 0 <= n1 is partially proven to be inductive.\nloop invariant sn == x*2 || sn == 0 is partially proven to be inductive.\nloop invariant x <= 10 ==> sn <= x*2 is partially proven to be inductive.\nloop invariant x > 10 ==> sn == 20 is established but not preserved.\nAssertion sn == x * 2 || sn == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(){\n  int  sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int  x=0;\n  /*@\n\nloop invariant i2: 0 <= n1;\nloop invariant i3: sn == x*2 || sn == 0;\nloop invariant i4: x <= 10 ==> sn <= x*2;\n\n*/\nwhile(1){\n      if(x<10){\n          sn = sn +(2);\n      }\n      x++;\n      {;\n//@ assert(sn==x*(2)|| sn == 0);\n}\n\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The program does not have any pre-conditions.\n- `unknown_uint()` returns a non-deterministic unsigned integer value.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned a non-deterministic unsigned integer value.\n- `n1` is assigned a non-deterministic unsigned integer value.\n- `x` is initialized to 0.\n\nLoop condition:\n- The loop is an infinite loop and runs until the program is terminated.\n\nLoop invariants:\n- `sn >= 0`\n- `x >= 0`\n- `sn == x * 2 ==> x <= 10`\n- `sn == 0 ==> x > 10`\n- `sn == x * 2 || sn == 0`\n\nExplanation:\n- Since `sn` is initially assigned 0 and only increases by 2 in each iteration, `sn` is always non-negative.\n- Since `x` is initially assigned 0 and only increases by 1 in each iteration, `x` is always non-negative.\n- If `sn` is equal to `x * 2`, then `x` cannot be larger than 10 because the loop condition checks if `x` is less than 10. So, `sn == x * 2 ==> x <= 10`.\n- If `sn` is equal to 0, then `x` must be larger than 10 because the loop condition checks if `x` is less than 10. So, `sn == 0 ==> x > 10`.\n- The assertion `sn==x*(2)|| sn == 0` holds true in every iteration of the loop because either `sn` is equal to `x * 2` or `sn` is equal to 0.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 9: unbound logic variable UINT_MAX. Ignoring loop annotation",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(){\n  int  sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int  x=0;\n  /*@\nloop invariant i1: 0 <= x <= UINT_MAX;\nloop invariant i2: sn == (x*(2)) || sn == 0;\nloop invariant i3: 0 <= x <= loop1;\nloop invariant i4: 0 <= n1;\nloop invariant i5: sn == x*2 || sn == 0;\nloop invariant i6: x <= 10 ==> sn <= x*2;\nloop invariant i7: x > 10 ==> sn == 20;\n*/\nwhile(1){\n      if(x<10){\n          sn = sn +(2);\n      }\n      x++;\n      {;\n//@ assert(sn==x*(2)|| sn == 0);\n}\n\n  }\n}",
        "combined_annotation_num_solver_calls": 4,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(){\n  int  sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int  x=0;\n  /*@\n\nloop invariant i2: sn == (x*(2)) || sn == 0;\n\nloop invariant i4: 0 <= n1;\nloop invariant i5: sn == x*2 || sn == 0;\nloop invariant i6: x <= 10 ==> sn <= x*2;\n\n*/\nwhile(1){\n      if(x<10){\n          sn = sn +(2);\n      }\n      x++;\n      {;\n//@ assert(sn==x*(2)|| sn == 0);\n}\n\n  }\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c"
        ],
        "skipped": [],
        "total": 144,
        "success_count": 58,
        "failure_count": 86,
        "success_rate": 0.4027777777777778
    }
}