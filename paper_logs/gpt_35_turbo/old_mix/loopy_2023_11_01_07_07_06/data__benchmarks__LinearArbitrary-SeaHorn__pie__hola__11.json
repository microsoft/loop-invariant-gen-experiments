{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
        "benchmark_code": "#define assume(e) if(!(e)) return;\n\nvoid main()\n{\n  int j=0;\n  int i;\n  int x=100;\n   \n  for (i =0; i< x ; i++){\n    j = j + 2;\n  }\n\n  {;\n//@ assert(j == 2*x);\n}\n\n}\n",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return;\n\nvoid main()\n{\n  int j=0;\n  int i;\n  int x=100;\n   \n  for (i =0; i< x ; i++){\n    j = j + 2;\n  }\n\n  {;\n//@ assert(j == 2*x);\n}\n\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- None\n\nVariable Assignments:\n- `j = 0`\n- `i = 0`\n- `x = 100`\n\nLoop Condition:\n- `i < x`\n\nPost-condition:\n- `j == 2*x`\n\nLoop Invariants:\n- Before loop execution: `j == 2*i`\n- In every iteration: `j == 2*i`\n- After loop termination: `j == 2*x`\n\nProof:\n- Before loop execution: Since `i` is initialized to 0 and `j` is set to 0 before the loop, the invariant `j == 2*i` holds.\n- In every iteration: The loop body increments `i` by 1 and updates `j` as `j = j + 2`. Therefore, the invariant `j == 2*i` holds at every iteration of the loop.\n- After loop termination: Since the loop condition is `i < x` and the loop increments `i` by 1 at every iteration, at the end of the loop `i` is equal to `x`. Therefore, `j` is equal to `2*x` and the invariant `j == 2*x` holds.\n\nFinal Loop Invariants:\n```\n/*@ \n    loop invariant j == 2*i;\n*/\n```",
            "Pre-conditions:\n- None\n\nVariable assignments:\n- j is assigned 0\n- i is assigned 0\n- x is assigned 100\n\nLoop condition:\n- i < x\n\nLoop body:\n- j = j + 2\n\nPost-condition:\n- j == 2*x\n\nLoop Invariants:\n- Before loop execution: None needed\n- In every iteration: j == 2*i\n- After loop termination: j == 2*x\n\nExplanation:\n- Before loop execution: No invariants are needed as there are no assumptions on the initial values of the variables.\n- In every iteration: Since j is incremented by 2 in each iteration, we can infer that j == 2*i, where i is the loop variable.\n- After loop termination: Since the loop runs x times and j is incremented by 2 in each iteration, we can infer that j == 2*x.\n\nPutting it all together:\n\n```\n/*@ \n    loop invariant j == 2*i;\n    loop invariant j == 2*x;\n*/\nfor (i = 0; i < x; i++){\n    j = j + 2;\n}\n\n{;\n//@ assert(j == 2*x);\n}\n``` \n\nNote: Since there are no variables whose bounds are known, we cannot add any bounds as loop invariants. Also, there are no non-deterministic variables, so we don't need to use any implications.",
            "First, let's look at the pre-conditions and variable assignments:\n- The program does not have any pre-conditions.\n- The variable `j` is initialized to 0.\n- The variable `i` is uninitialized and contains garbage value.\n- The variable `x` is initialized to 100.\n\nNow, let's analyze the loop body and make a note of the loop condition:\n- The loop body is the statement `j = j + 2;`.\n- The loop condition is `i < x`.\n\nNext, let's find the loop invariants:\n- Before the loop execution, `j == 0` and `x == 100`.\n- In every iteration of the loop, `0 <= i <= x` and `j == 2*i`.\n- After the loop termination, `i == x` and `j == 2*x`.\n\nPutting everything together, we get the following loop invariants:\n```\n/*@ \n    loop invariant j >= 0;\n    loop invariant j == 2*i;\n    loop invariant 0 <= i <= x;\n    loop invariant i <= x;\n    loop invariant j <= 2*x;\n    loop invariant i == x ==> j == 2*x;\n*/\n``` \nNote that we have used the implication operator `==>` to take care of the conditional nature of the assertion. Also, we have used conjunctions to bound the maximum and minimum values of `i` and `j`. Finally, we have used the implication operator to make the invariants trivially true at the beginning and end of the loop for the non-deterministic variable `i`.",
            "We can start by analyzing the loop body:\n\n```\nj = j + 2;\n```\n\nThe loop condition is:\n\n```\ni < x\n```\n\nNow, let's look at the pre-conditions:\n\n```\nint j=0;\nint i;\nint x=100;\n```\n\nWe know that `j` is initialized to 0 and `x` is initialized to 100. We do not have any information about the value of `i` at the start of the program.\n\nLet's look at the post-condition:\n\n```\n//@ assert(j == 2*x);\n```\n\nThe post-condition states that `j` should be equal to `2*x` after the loop execution.\n\nBased on the loop body and condition, we can come up with the following loop invariants:\n\n```\n/*@\nloop invariant 0 <= i <= x;\nloop invariant j == 2*i;\n*/\n```\n\nExplanation:\n- The first loop invariant states that `i` is always greater than or equal to 0 and less than or equal to `x`, which is the loop bound.\n- The second loop invariant states that `j` is always equal to `2*i`. This is true because in each iteration of the loop, `j` is incremented by 2 and `i` is incremented by 1. Therefore, `j` will always be twice the value of `i`.\n\nSince the loop invariants are true before the loop execution, in every iteration of the loop, and after the loop termination, and they imply the post-condition, Frama-C can use them to verify the program.",
            "First, let's analyze the loop body and make a note of the loop condition. The loop runs while `i` is less than `x`. \n\nNow, let's find the pre-conditions or variable assignments in the program:\n- `j` is initialized to 0\n- `i` is not initialized and contains garbage values\n- `x` is initialized to 100\n\nWe can add the following loop invariants:\n```\n/*@ \n    loop invariant 0 <= i <= x;\n    loop invariant j == 2*i;\n*/\n```\n- The first loop invariant states that `i` is always between 0 and `x`, inclusive.\n- The second loop invariant states that `j` is always equal to twice the value of `i`.\n\nSince the loop condition is `i<x`, we know that `i` is always less than `x` when the loop terminates. We can use implication to include this in our loop invariants:\n```\n/*@ \n    loop invariant 0 <= i <= x;\n    loop invariant j == 2*i;\n    loop invariant i == x ==> j == 2*x;\n*/\n```\nThis states that if `i` is equal to `x`, then `j` must be equal to `2*x`.\n\nFinally, we can use implication to include the assertion in our loop invariants:\n```\n/*@ \n    loop invariant 0 <= i <= x;\n    loop invariant j == 2*i;\n    loop invariant i == x ==> j == 2*x;\n    loop invariant i == x ==> j == 2*x ==> j == 2*x && j == 2*x;\n*/\n```\nThis states that if `i` is equal to `x`, then `j` must be equal to `2*x`, which implies that `j` must be equal to `2*x` and the assertion holds.\n\nTherefore, the loop invariants are:\n```\n/*@ \n    loop invariant 0 <= i <= x;\n    loop invariant j == 2*i;\n    loop invariant i == x ==> j == 2*x;\n    loop invariant i == x ==> j == 2*x ==> j == 2*x && j == 2*x;\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant j == 2*i;\n*/",
            "/*@ \n    loop invariant j == 2*i;\n    loop invariant j == 2*x;\n*/\nfor (i = 0; i < x; i++){\n    j = j + 2;\n}\n\n{;\n//@ assert(j == 2*x);\n}",
            "/*@ \n    loop invariant j >= 0;\n    loop invariant j == 2*i;\n    loop invariant 0 <= i <= x;\n    loop invariant i <= x;\n    loop invariant j <= 2*x;\n    loop invariant i == x ==> j == 2*x;\n*/",
            "/*@\nloop invariant 0 <= i <= x;\nloop invariant j == 2*i;\n*/",
            "/*@ \n    loop invariant 0 <= i <= x;\n    loop invariant j == 2*i;\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant j == 2*i;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant j == 2*i is inductive.\nAssertion j == 2 * x: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid main()\n{\n  int j=0;\n  int i;\n  int x=100;\n   \n  /*@\nloop invariant i1: j == 2*i;\n*/\nfor (i =0; i< x ; i++){\n    j = j + 2;\n  }\n\n  {;\n//@ assert(j == 2*x);\n}\n\n}\n",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant j == 2*i;\n    loop invariant j == 2*x;\n*/\nfor (i = 0; i < x; i++){\n    j = j + 2;\n}\n\n{;\n//@ assert(j == 2*x);\n}",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant j == 2*i is partially proven to be inductive.\nloop invariant j == 2*x is preserved but not established.\nAssertion j == 2 * x: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid main()\n{\n  int j=0;\n  int i;\n  int x=100;\n   \n  /*@\nloop invariant i1: j == 2*i;\n\n*/\nfor (i =0; i< x ; i++){\n    j = j + 2;\n  }\n\n  {;\n//@ assert(j == 2*x);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ \n    loop invariant j >= 0;\n    loop invariant j == 2*i;\n    loop invariant 0 <= i <= x;\n    loop invariant i <= x;\n    loop invariant j <= 2*x;\n    loop invariant i == x ==> j == 2*x;\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant j >= 0 is inductive.\nloop invariant j == 2*i is inductive.\nloop invariant 0 <= i <= x is inductive.\nloop invariant i <= x is inductive.\nloop invariant j <= 2*x is inductive.\nloop invariant i == x ==> j == 2*x is inductive.\nAssertion j == 2 * x: Valid"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@\nloop invariant 0 <= i <= x;\nloop invariant j == 2*i;\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 0 <= i <= x is inductive.\nloop invariant j == 2*i is inductive.\nAssertion j == 2 * x: Valid"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ \n    loop invariant 0 <= i <= x;\n    loop invariant j == 2*i;\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 0 <= i <= x is inductive.\nloop invariant j == 2*i is inductive.\nAssertion j == 2 * x: Valid"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant j == 2*i is partially proven to be inductive.\nloop invariant j == 2*x is preserved but not established.\nloop invariant j >= 0 is partially proven to be inductive.\nloop invariant 0 <= i <= x is partially proven to be inductive.\nloop invariant i <= x is partially proven to be inductive.\nloop invariant j <= 2*x is partially proven to be inductive.\nloop invariant i == x ==> j == 2*x is partially proven to be inductive.\nAssertion j == 2 * x: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return;\n\nvoid main()\n{\n  int j=0;\n  int i;\n  int x=100;\n   \n  /*@\nloop invariant i1: j == 2*i;\nloop invariant i2: j == 2*x;\nloop invariant i3: j >= 0;\nloop invariant i4: 0 <= i <= x;\nloop invariant i5: i <= x;\nloop invariant i6: j <= 2*x;\nloop invariant i7: i == x ==> j == 2*x;\n*/\nfor (i =0; i< x ; i++){\n    j = j + 2;\n  }\n\n  {;\n//@ assert(j == 2*x);\n}\n\n}\n",
        "combined_annotation_num_solver_calls": 2,
        "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid main()\n{\n  int j=0;\n  int i;\n  int x=100;\n   \n  /*@\nloop invariant i1: j == 2*i;\n\nloop invariant i3: j >= 0;\nloop invariant i4: 0 <= i <= x;\nloop invariant i5: i <= x;\nloop invariant i6: j <= 2*x;\nloop invariant i7: i == x ==> j == 2*x;\n*/\nfor (i =0; i< x ; i++){\n    j = j + 2;\n  }\n\n  {;\n//@ assert(j == 2*x);\n}\n\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c"
        ],
        "skipped": [],
        "total": 163,
        "success_count": 68,
        "failure_count": 95,
        "success_rate": 0.4171779141104294
    }
}