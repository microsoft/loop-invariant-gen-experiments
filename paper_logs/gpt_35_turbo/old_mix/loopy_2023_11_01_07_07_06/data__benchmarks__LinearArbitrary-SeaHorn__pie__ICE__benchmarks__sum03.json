{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  while(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  while(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The macro `assume(e)` returns 0 if the expression `e` evaluates to false.\n- The function `unknown_uint()` returns an arbitrary unsigned integer value.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the result of `unknown_uint()`.\n- `n1` is assigned the result of `unknown_uint()`.\n- `x` is initialized to 0.\n\nLoop condition:\n- The while loop condition is always true, so the loop will execute indefinitely.\n\nLoop invariants:\n- Since `a` is a constant defined as 1, we can add the loop invariant `sn == x` to ensure that `sn` is always equal to the number of times the loop has executed.\n- We can add the loop invariant `x >= 0` to ensure that `x` is always non-negative.\n- We can add the loop invariant `sn >= 0` to ensure that `sn` is always non-negative.\n- We can add the loop invariant `sn <= x` to ensure that `sn` is always less than or equal to `x`.\n- We can add the loop invariant `n1 >= loop1` to ensure that `n1` is always greater than or equal to `loop1`.\n- Since `unknown_uint()` returns an arbitrary unsigned integer value, we can add the implication `(loop1 == n1) ==> (loop1 <= x)` to make the loop invariant trivially true at the beginning of the loop.\n- We can add the implication `(loop1 == n1) ==> (sn == 0)` to make the loop invariant trivially true at the end of the loop.\n- Finally, we can add the loop invariant `sn == x*a` to ensure that `sn` is always equal to `x` multiplied by `a`.\n\nPutting all the loop invariants together, we get:\n\n```\n/*@ \n    loop invariant sn == x;\n    loop invariant x >= 0;\n    loop invariant sn >= 0;\n    loop invariant sn <= x;\n    loop invariant n1 >= loop1;\n    loop invariant sn == 0 ==> (loop1 != n1);\n    loop invariant (sn == x*a) ==> (sn==x || sn==0);\n*/\n``` \n\nNote that the assertion inside the loop is guarded by `{;}`, which means that it is always executed. Therefore, we don't need to use any implication for the assertion.",
            "Pre-conditions:\n- None.\n\nVariable assignments:\n- `sn` is assigned 0.\n- `loop1` is assigned the result of the `unknown_uint()` function.\n- `n1` is assigned the result of the `unknown_uint()` function.\n- `x` is assigned 0.\n\nLoop condition:\n- The loop runs infinitely as the condition is always true.\n\nLoop invariants:\n- `sn >= 0`: The sum `sn` is always greater than or equal to 0.\n- `x >= 0`: The variable `x` is always greater than or equal to 0.\n- `sn == x*a || sn == 0`: The sum `sn` is equal to `x*a` or 0. \n\nThese loop invariants hold true:\n1. Before the loop execution, `sn == 0`, `x == 0`, and the other invariants hold true.\n2. In every iteration of the loop, `sn` is incremented by `a`, `x` is incremented by 1, and the other invariants hold true.\n3. After the loop termination, the loop condition is always true, so the loop runs infinitely. Thus, the loop invariants continue to hold true. \n\nFinally, we can write the loop invariants in one code block as follows:\n\n```\n/*@ \n    loop invariant sn >= 0;\n    loop invariant x >= 0;\n    loop invariant sn == x*a || sn == 0;\n*/\n```",
            "Pre-conditions:\n- The macro `assume(e)` implies that the program will terminate if the expression `!(e)` evaluates to true.\n- The function `unknown_uint()` returns an unsigned integer value that is not known at compile time.\n\nVariable assignments:\n- Macro `a` is assigned the value 1.\n- Variable `sn` is initialized to 0.\n- Variables `loop1` and `n1` are assigned non-deterministic unsigned integer values.\n- Variable `x` is initialized to 0.\n\nLoop Condition:\n- The while loop condition is `while(1)`, which means that the loop will execute indefinitely. \n\nLoop Invariants:\n- `sn >= 0`\n- `x >= 0`\n- `sn == x * a`\n- `(sn != 0) ==> (x > 0)`\n\nExplanation of Loop Invariants:\n- `sn >= 0`: Since `sn` is initialized to 0, and it is incremented by `a` in each iteration of the loop, `sn` can never be negative.\n- `x >= 0`: Since `x` is initialized to 0, and it is incremented by 1 in each iteration of the loop, `x` can never be negative.\n- `sn == x * a`: This is the main loop invariant. Since `sn` is incremented by `a` in each iteration of the loop and `x` is incremented by 1 in each iteration of the loop, this relationship must hold true in every iteration of the loop.\n- `(sn != 0) ==> (x > 0)`: This invariant is used to handle the assertion `sn==x*a || sn==0`. If `sn` is not equal to 0, then `x` must be greater than 0, otherwise the relationship `sn == x * a` would be violated. If `sn` is equal to 0, then the assertion is trivially true. \n\nWe can combine all the loop invariants in one block as follows:\n\n```\n/*@ \nloop invariant sn >= 0;\nloop invariant x >= 0;\nloop invariant sn == x * a;\nloop invariant (sn != 0) ==> (x > 0);\n*/\n```",
            "Pre-conditions:\n- The macro `assume(e)` takes a boolean expression `e` and returns 0 if `e` is false.\n- The function `unknown_uint()` returns an arbitrary non-negative integer.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the result of `unknown_uint()`.\n- `n1` is assigned the result of `unknown_uint()`.\n- `x` is initialized to 0.\n\nLoop condition:\n- The loop condition is `while(1)`, which is an infinite loop.\n\nLoop body:\n- `sn` is incremented by `a`.\n- `x` is incremented by 1.\n- The assertion `sn==x*a || sn == 0` is checked.\n\nWe need to find loop invariants that are true:\n- before the loop execution,\n- in every iteration of the loop, and\n- after the loop termination,\n\nsuch that the loop invariants imply the post-condition `sn==x*a || sn == 0`.\n\nFirst, we can note that the loop condition `while(1)` is always true and the loop does not have a break statement. Therefore, the loop will run indefinitely unless the program is terminated or returns 0 as a result of the `assume` macro.\n\nLoop invariant 1: `sn >= 0`\n- `sn` is initialized to 0 and is incremented by a non-negative value `a` in every iteration of the loop.\n- Therefore, `sn` is always non-negative.\n\nLoop invariant 2: `x >= 0`\n- `x` is initialized to 0 and is incremented by 1 in every iteration of the loop.\n- Therefore, `x` is always non-negative.\n\nLoop invariant 3: `sn <= x*a`\n- If `sn` is equal to `x*a`, then the assertion `sn==x*a || sn == 0` is true.\n- If `sn` is less than `x*a`, then `sn` will be incremented by a non-negative value `a` in the next iteration of the loop. Therefore, `sn` will eventually become equal to or greater than `x*a`.\n- Therefore, `sn` is always less than or equal to `x*a`.\n\nLoop invariant 4: `(sn == 0) ==> (x == 0)`\n- If `sn` is equal to 0, then the assertion `sn==x*a || sn == 0` is true only if `x` is also equal to 0.\n- Therefore, if `sn` is equal to 0, then `x` must also be equal to 0.\n\nPutting all the loop invariants together, we get:\n```\n/*@ \n    loop invariant sn >= 0;\n    loop invariant x >= 0;\n    loop invariant sn <= x*a;\n    loop invariant (sn == 0) ==> (x == 0);\n*/\n```",
            "Pre-conditions:\n- The macro `assume` takes an expression and if it evaluates to false, the function returns 0. \n- The external function `unknown_uint` returns an unsigned integer value whose value is unknown and cannot be assumed to be any specific value.\n- The macro `a` is defined as 1.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the value returned by `unknown_uint()`.\n- `n1` is assigned the value returned by `unknown_uint()`.\n- `x` is initialized to 0.\n\nLoop condition:\n- The loop condition is `while(1)`, which means the loop runs indefinitely.\n\nLoop invariants:\n- `sn == x*a || sn == 0`: This invariant holds before the loop execution because `sn` is initialized to 0 and `x` is initialized to 0. This invariant holds in every iteration of the loop because `sn` is updated by adding the value of `a` to it, and `x` is incremented by 1. This invariant holds after the loop termination because the loop runs indefinitely, and the invariant is true for all possible values of `sn` and `x`.\n- `x >= 0`: This invariant holds before the loop execution because `x` is initialized to 0, and 0 is greater than or equal to 0. This invariant holds in every iteration of the loop because `x` is incremented by 1, and adding 1 to a non-negative integer results in a non-negative integer. This invariant holds after the loop termination because the loop runs indefinitely, and `x` is always non-negative.\n- `loop1 >= 0`: This invariant holds before the loop execution because `loop1` is assigned the value returned by `unknown_uint()`, which is an unsigned integer and is non-negative. This invariant holds in every iteration of the loop because `loop1` is not modified inside the loop. This invariant holds after the loop termination because the loop runs indefinitely, and `loop1` is always non-negative.\n- `n1 >= 0`: This invariant holds before the loop execution because `n1` is assigned the value returned by `unknown_uint()`, which is an unsigned integer and is non-negative. This invariant holds in every iteration of the loop because `n1` is not modified inside the loop. This invariant holds after the loop termination because the loop runs indefinitely, and `n1` is always non-negative.\n\nPutting it all together, the loop invariants are:\n```\n/*@ \n    loop invariant sn == x*a || sn == 0;\n    loop invariant x >= 0;\n    loop invariant loop1 >= 0;\n    loop invariant n1 >= 0;\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant sn == x;\n    loop invariant x >= 0;\n    loop invariant sn >= 0;\n    loop invariant sn <= x;\n    loop invariant n1 >= loop1;\n    loop invariant sn == 0 ==> (loop1 != n1);\n    loop invariant (sn == x*a) ==> (sn==x || sn==0);\n*/",
            "/*@ \n    loop invariant sn >= 0;\n    loop invariant x >= 0;\n    loop invariant sn == x*a || sn == 0;\n*/",
            "/*@ \nloop invariant sn >= 0;\nloop invariant x >= 0;\nloop invariant sn == x * a;\nloop invariant (sn != 0) ==> (x > 0);\n*/",
            "/*@ \n    loop invariant sn >= 0;\n    loop invariant x >= 0;\n    loop invariant sn <= x*a;\n    loop invariant (sn == 0) ==> (x == 0);\n*/",
            "/*@ \n    loop invariant sn == x*a || sn == 0;\n    loop invariant x >= 0;\n    loop invariant loop1 >= 0;\n    loop invariant n1 >= 0;\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant sn == x;\n    loop invariant x >= 0;\n    loop invariant sn >= 0;\n    loop invariant sn <= x;\n    loop invariant n1 >= loop1;\n    loop invariant sn == 0 ==> (loop1 != n1);\n    loop invariant (sn == x*a) ==> (sn==x || sn==0);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn == x is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant sn <= x is partially proven to be inductive.\nloop invariant n1 >= loop1 is preserved but not established.\nloop invariant sn == 0 ==> (loop1 != n1) is preserved but not established.\nloop invariant (sn == x*a) ==> (sn==x || sn==0) is partially proven to be inductive.\nAssertion sn == x * 1 || sn == 0: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\nloop invariant i2: x >= 0;\nloop invariant i3: sn >= 0;\nloop invariant i4: sn <= x;\n\n\nloop invariant i7: (sn == x*a) ==> (sn==x || sn==0);\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant sn >= 0;\n    loop invariant x >= 0;\n    loop invariant sn == x*a || sn == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn >= 0 is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant sn == x*a || sn == 0 is partially proven to be inductive.\nAssertion sn == x * 1 || sn == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn >= 0;\nloop invariant i2: x >= 0;\nloop invariant i3: sn == x*a || sn == 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ \nloop invariant sn >= 0;\nloop invariant x >= 0;\nloop invariant sn == x * a;\nloop invariant (sn != 0) ==> (x > 0);\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant sn >= 0 is inductive.\nloop invariant x >= 0 is inductive.\nloop invariant sn == x * a is inductive.\nloop invariant (sn != 0) ==> (x > 0) is inductive.\nAssertion sn == x * 1 || sn == 0: Valid"
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant sn >= 0;\n    loop invariant x >= 0;\n    loop invariant sn <= x*a;\n    loop invariant (sn == 0) ==> (x == 0);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn >= 0 is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant sn <= x*a is partially proven to be inductive.\nloop invariant (sn == 0) ==> (x == 0) is partially proven to be inductive.\nAssertion sn == x * 1 || sn == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn >= 0;\nloop invariant i2: x >= 0;\nloop invariant i3: sn <= x*a;\nloop invariant i4: (sn == 0) ==> (x == 0);\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant sn == x*a || sn == 0;\n    loop invariant x >= 0;\n    loop invariant loop1 >= 0;\n    loop invariant n1 >= 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn == x*a || sn == 0 is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant loop1 >= 0 is partially proven to be inductive.\nloop invariant n1 >= 0 is partially proven to be inductive.\nAssertion sn == x * 1 || sn == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x*a || sn == 0;\nloop invariant i2: x >= 0;\nloop invariant i3: loop1 >= 0;\nloop invariant i4: n1 >= 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant sn == x is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant sn <= x is partially proven to be inductive.\nloop invariant n1 >= loop1 is preserved but not established.\nloop invariant sn == 0 ==> (loop1 != n1) is preserved but not established.\nloop invariant (sn == x*a) ==> (sn==x || sn==0) is partially proven to be inductive.\nloop invariant sn == x*a || sn == 0 is partially proven to be inductive.\nloop invariant sn == x * a is partially proven to be inductive.\nloop invariant (sn != 0) ==> (x > 0) is partially proven to be inductive.\nloop invariant sn <= x*a is partially proven to be inductive.\nloop invariant (sn == 0) ==> (x == 0) is partially proven to be inductive.\nloop invariant loop1 >= 0 is partially proven to be inductive.\nloop invariant n1 >= 0 is partially proven to be inductive.\nAssertion sn == x * 1 || sn == 0: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\nloop invariant i2: x >= 0;\nloop invariant i3: sn >= 0;\nloop invariant i4: sn <= x;\nloop invariant i5: n1 >= loop1;\nloop invariant i6: sn == 0 ==> (loop1 != n1);\nloop invariant i7: (sn == x*a) ==> (sn==x || sn==0);\nloop invariant i8: sn == x*a || sn == 0;\nloop invariant i9: sn == x * a;\nloop invariant i10: (sn != 0) ==> (x > 0);\nloop invariant i11: sn <= x*a;\nloop invariant i12: (sn == 0) ==> (x == 0);\nloop invariant i13: loop1 >= 0;\nloop invariant i14: n1 >= 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
        "combined_annotation_num_solver_calls": 2,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#define a (1)\n\nint main() { \n  int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x;\nloop invariant i2: x >= 0;\nloop invariant i3: sn >= 0;\nloop invariant i4: sn <= x;\n\n\nloop invariant i7: (sn == x*a) ==> (sn==x || sn==0);\nloop invariant i8: sn == x*a || sn == 0;\nloop invariant i9: sn == x * a;\nloop invariant i10: (sn != 0) ==> (x > 0);\nloop invariant i11: sn <= x*a;\nloop invariant i12: (sn == 0) ==> (x == 0);\nloop invariant i13: loop1 >= 0;\nloop invariant i14: n1 >= 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c"
        ],
        "skipped": [],
        "total": 209,
        "success_count": 96,
        "failure_count": 113,
        "success_rate": 0.45933014354066987
    }
}