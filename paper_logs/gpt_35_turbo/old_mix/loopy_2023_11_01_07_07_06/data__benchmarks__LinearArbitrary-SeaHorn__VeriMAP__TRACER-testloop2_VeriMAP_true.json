{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
        "benchmark_code": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  while (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  while (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The program assumes the existence of a function `errorFn`.\n- The program assumes the existence of a macro `assume`.\n- The variable `NONDET` is not initialized and could have garbage value.\n- The variable `i` is not initialized and could have garbage value.\n- The variable `N` is not initialized and could have garbage value.\n- The variable `a` is not initialized and could have garbage value.\n\nVariable assignments:\n- If `NONDET` is greater than 0, `x` is assigned 1, else `x` is assigned 2.\n\nLoop analysis:\n- The loop condition is `i<N`.\n- The loop body does not modify `x`.\n- The loop body increments the value of `i` by 1.\n\nPost-condition:\n- The assertion `!(x>2)` holds at the end of the program.\n\nLoop invariants:\n- Since `i` is not initialized and could have a garbage value, we need to add a conjunction that bounds the minimum and maximum values that `i` can take. Let `i_min` be the minimum value that `i` can take and `i_max` be the maximum value that `i` can take. Then, the loop invariant for `i` is: \n    ```\n    loop invariant i_min <= i <= i_max;\n    ```\n- Since `N` is not initialized and could have a garbage value, we need to add a conjunction that bounds the minimum and maximum values that `N` can take. Let `N_min` be the minimum value that `N` can take and `N_max` be the maximum value that `N` can take. Then, the loop invariant for `N` is:\n    ```\n    loop invariant N_min <= N <= N_max;\n    ```\n- Since `x` is assigned either 1 or 2, we can add a conjunction that bounds the minimum and maximum values that `x` can take. Let `x_min` be the minimum value that `x` can take and `x_max` be the maximum value that `x` can take. Then, the loop invariant for `x` is:\n    ```\n    loop invariant x_min <= x <= x_max;\n    ```\n- Since the loop body does not modify `x`, we can add a conjunction that states that `x` does not change during the loop execution. Let `x_0` be the initial value of `x`. Then, the loop invariant for `x` is:\n    ```\n    loop invariant \\forall integer j; i <= j < N ==> x == x_0;\n    ```\n- Since the loop body increments `i` by 1, we can add a conjunction that states that `i` increases by 1 in each iteration of the loop. Let `i_0` be the initial value of `i`. Then, the loop invariant for `i` is:\n    ```\n    loop invariant \\forall integer j; i_0 <= j < i ==> j+1 == i;\n    ```\n- Since the post-condition is guarded by the condition `x>2`, we need to use an implication to make the invariant trivially true when `x<=2`. Let `b` be the boolean expression `x>2`. Then, the loop invariant for the assertion is:\n    ```\n    loop invariant (b ==> !(x>2));\n    ```\n\nPutting it all together:\n```\n#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@ \n    loop invariant i_min <= i <= i_max;\n    loop invariant N_min <= N <= N_max;\n    loop invariant x_min <= x <= x_max;\n    loop invariant \\forall integer j; i <= j < N ==> x == x_0;\n    loop invariant \\forall integer j; i_0 <= j < i ==> j+1 == i;\n    loop invariant (x>2 ==> !(x>2));\n  */\n  while (i<N){\n    i=i+1;\n  }\n\n  {;\n    //@ assert(!(x >2 ));\n  }\n\n  return;\n\n}\n```",
            "Pre-conditions:\n- None\n\nVariable assignments:\n- `int NONDET;`: A non-deterministic integer variable.\n- `int i,N;`: Two integer variables that are not initialized.\n- `int a;`: An integer variable that is not used.\n- `int x;`: An integer variable that is initialized based on the value of `NONDET`.\n\nLoop condition:\n- `i<N`\n\nPost-condition:\n- `!(x>2)`\n\nLoop invariants:\n- `i >= 0`\n- `i <= N`\n- `x == 1 ==> i >= 0`\n- `x == 1 ==> i <= N`\n- `x == 2 ==> i >= 0`\n- `x == 2 ==> i <= N`\n- `(NONDET <= 0 && x == 2) ==> !(x > 2)`\n- `(NONDET > 0 && x == 1) ==> !(x > 2)`\n\nExplanation:\n- `i >= 0` and `i <= N` ensure that `i` stays within the bounds of the loop.\n- `x == 1 ==> i >= 0` and `x == 1 ==> i <= N` are needed because if `x` is initialized to 1, we need to ensure that `i` stays within the loop bounds.\n- Similarly, `x == 2 ==> i >= 0` and `x == 2 ==> i <= N` are needed if `x` is initialized to 2.\n- `(NONDET <= 0 && x == 2) ==> !(x > 2)` and `(NONDET > 0 && x == 1) ==> !(x > 2)` are needed because if `NONDET` is less than or equal to 0 and `x` is initialized to 2, or if `NONDET` is greater than 0 and `x` is initialized to 1, then we know that `!(x > 2)` must hold. This is because `x` can only be 1 or 2, and in both cases `x > 2` is false.",
            "First, let's note the pre-conditions and variable assignments:\n- The program defines a macro `assume(e)` that returns if the expression `!(e)` is true.\n- The program defines a function `errorFn()` that has an infinite loop.\n- The program declares and initializes the following variables:\n  - `int NONDET` (initialized with a non-deterministic value)\n  - `int i` (initialized with a garbage value)\n  - `int N` (initialized with a garbage value)\n  - `int a` (initialized with a garbage value)\n  - `int x` (initialized based on the value of `NONDET`)\n\nThe loop condition is `i<N`. The loop body is empty.\n\nNow, let's find the necessary loop invariants:\n- Before the loop execution:\n  - `i <= N`\n  - `x <= 2`\n  - `x >= 1`\n  - `NONDET > 0 ==> x == 1`\n  - `NONDET <= 0 ==> x == 2`\n  - `a` can have any value, so we don't need to include it in the loop invariant.\n\n- In every iteration of the loop:\n  - `i <= N`\n  - `x <= 2`\n  - `x >= 1`\n  - `NONDET > 0 ==> x == 1`\n  - `NONDET <= 0 ==> x == 2`\n  - `a` can have any value, so we don't need to include it in the loop invariant.\n\n- After the loop termination:\n  - `i >= N`\n  - `x <= 2`\n  - `x >= 1`\n  - `NONDET > 0 ==> x == 1`\n  - `NONDET <= 0 ==> x == 2`\n  - `a` can have any value, so we don't need to include it in the loop invariant.\n\nFinally, we can combine all the loop invariants into one code block:\n```\n/*@\n  loop invariant i <= N;\n  loop invariant x <= 2;\n  loop invariant x >= 1;\n  loop invariant NONDET > 0 ==> x == 1;\n  loop invariant NONDET <= 0 ==> x == 2;\n  loop invariant i >= N || (i < N && \\false);\n*/\n``` \n\nNote that the last invariant is necessary because the loop body is empty, so we need to add a false condition to make the implication always true.",
            "First, let's note the pre-conditions and variable assignments in the program:\n- The program defines a macro `assume` which checks the given condition and returns if it is false.\n- The program defines a function `errorFn` which goes into an infinite loop.\n- The program has a `main` function which declares five variables `NONDET`, `i`, `N`, `a`, and `x`.\n- The program assigns either 1 or 2 to `x` depending on the value of `NONDET`.\n- The program has a while loop that increments `i` until it reaches `N`.\n- Finally, the program has an assertion that checks that `x` is not greater than 2.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is `i<N`.\n- The loop body just increments `i`.\n\nNow, let's find the necessary loop invariants of the while loop to help Frama-C verify the post-condition:\n- `i <= N`: This invariant is true before the loop execution because `i` and `N` are both uninitialized and can have any value. This invariant is true in every iteration of the loop because `i` is incremented by 1 in each iteration. This invariant is also true after the loop termination because the loop terminates when `i` becomes equal to or greater than `N`.\n- `x == 1 || x == 2`: This invariant is true before the loop execution because `x` is assigned either 1 or 2. This invariant is true in every iteration of the loop because the loop body does not modify `x`. This invariant is also true after the loop termination because the loop does not modify `x`.\n- `!(x > 2) ==> i <= N`: This invariant is true before the loop execution because `x` is assigned either 1 or 2 and `i` and `N` are both uninitialized and can have any value. This invariant is true in every iteration of the loop because `i` is incremented by 1 in each iteration and `x` is not modified inside the loop. This invariant is also true after the loop termination because the loop terminates when `i` becomes equal to or greater than `N`. Finally, the assertion `!(x > 2) ==> i <= N` implies the post-condition `!(x > 2)`.\n\nPutting all the loop invariants together, we get:\n```\n/*@\n    loop invariant i <= N;\n    loop invariant x == 1 || x == 2;\n    loop invariant !(x > 2) ==> i <= N;\n*/\n```",
            "First, let's note the pre-conditions and variable assignments in the program:\n- The `errorFn()` function is not used in this program.\n- The `assume()` macro is used to add an assumption that must be true for the program to continue executing. If the assumption is false, the program will terminate.\n- The program declares and initializes the following variables:\n  - `NONDET` is declared but not initialized, so it could have any garbage value.\n  - `i` is declared but not initialized, so it could have any garbage value.\n  - `N` is not declared or initialized, so we do not know its value.\n  - `a` is declared but not used in the program.\n  - `x` is initialized to either 1 or 2 depending on the value of `NONDET`.\n\nNext, let's analyze the loop body and note the loop condition:\n- The loop body is empty, so nothing is happening inside the loop.\n- The loop condition is `i<N`, which means the loop will execute as long as `i` is less than `N`.\n\nNow, let's output the loop invariants for the while loop:\n```\n/*@\nloop invariant 0 <= i; // i is non-negative\nloop invariant i <= N; // i is always less than or equal to N\nloop invariant x == 1 ==> !(i >= N); // if x is 1, then i must be less than N\nloop invariant x == 2 ==> !(i < N); // if x is 2, then i must be greater than or equal to N\nloop invariant i == N ==> x <= 2; // if i equals N, then x must be less than or equal to 2\nloop invariant i != N ==> x >= 1; // if i is not equal to N, then x must be greater than or equal to 1\n*/\n```\nExplanation of the loop invariants:\n- `0 <= i` and `i <= N` bound the possible values that `i` can take during the loop execution.\n- `x == 1 ==> !(i >= N)` and `x == 2 ==> !(i < N)` take into account the initialization of `x` and ensure that the loop will terminate only if `i` reaches the appropriate limit for the value of `x`.\n- `i == N ==> x <= 2` and `i != N ==> x >= 1` take into account the post-condition assertion and ensure that it will be true only if `i` reaches `N` and `x` is less than or equal to 2 or greater than or equal to 1, respectively."
        ],
        "annotation_blocks": [
            "    loop invariant i_min <= i <= i_max;",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None\n\nVariable assignments:\n- `int NONDET;`: A non-deterministic integer variable.\n- `int i,N;`: Two integer variables that are not initialized.\n- `int a;`: An integer variable that is not used.\n- `int x;`: An integer variable that is initialized based on the value of `NONDET`.\n\nLoop condition:\n- `i<N`\n\nPost-condition:\n- `!(x>2)`\n\nLoop invariants:\n- `i >= 0`\n- `i <= N`\n- `x == 1 ==> i >= 0`\n- `x == 1 ==> i <= N`\n- `x == 2 ==> i >= 0`\n- `x == 2 ==> i <= N`\n- `(NONDET <= 0 && x == 2) ==> !(x > 2)`\n- `(NONDET > 0 && x == 1) ==> !(x > 2)`\n\nExplanation:\n- `i >= 0` and `i <= N` ensure that `i` stays within the bounds of the loop.\n- `x == 1 ==> i >= 0` and `x == 1 ==> i <= N` are needed because if `x` is initialized to 1, we need to ensure that `i` stays within the loop bounds.\n- Similarly, `x == 2 ==> i >= 0` and `x == 2 ==> i <= N` are needed if `x` is initialized to 2.\n- `(NONDET <= 0 && x == 2) ==> !(x > 2)` and `(NONDET > 0 && x == 1) ==> !(x > 2)` are needed because if `NONDET` is less than or equal to 0 and `x` is initialized to 2, or if `NONDET` is greater than 0 and `x` is initialized to 1, then we know that `!(x > 2)` must hold. This is because `x` can only be 1 or 2, and in both cases `x > 2` is false."
            ],
            "/*@\n  loop invariant i <= N;\n  loop invariant x <= 2;\n  loop invariant x >= 1;\n  loop invariant NONDET > 0 ==> x == 1;\n  loop invariant NONDET <= 0 ==> x == 2;\n  loop invariant i >= N || (i < N && \\false);\n*/",
            "/*@\n    loop invariant i <= N;\n    loop invariant x == 1 || x == 2;\n    loop invariant !(x > 2) ==> i <= N;\n*/",
            "/*@\nloop invariant 0 <= i; // i is non-negative\nloop invariant i <= N; // i is always less than or equal to N\nloop invariant x == 1 ==> !(i >= N); // if x is 1, then i must be less than N\nloop invariant x == 2 ==> !(i < N); // if x is 2, then i must be greater than or equal to N\nloop invariant i == N ==> x <= 2; // if i equals N, then x must be less than or equal to 2\nloop invariant i != N ==> x >= 1; // if i is not equal to N, then x must be greater than or equal to 1\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "    loop invariant i_min <= i <= i_max;",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 14: unbound logic variable i_max. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@\n\n*/\nwhile (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None\n\nVariable assignments:\n- `int NONDET;`: A non-deterministic integer variable.\n- `int i,N;`: Two integer variables that are not initialized.\n- `int a;`: An integer variable that is not used.\n- `int x;`: An integer variable that is initialized based on the value of `NONDET`.\n\nLoop condition:\n- `i<N`\n\nPost-condition:\n- `!(x>2)`\n\nLoop invariants:\n- `i >= 0`\n- `i <= N`\n- `x == 1 ==> i >= 0`\n- `x == 1 ==> i <= N`\n- `x == 2 ==> i >= 0`\n- `x == 2 ==> i <= N`\n- `(NONDET <= 0 && x == 2) ==> !(x > 2)`\n- `(NONDET > 0 && x == 1) ==> !(x > 2)`\n\nExplanation:\n- `i >= 0` and `i <= N` ensure that `i` stays within the bounds of the loop.\n- `x == 1 ==> i >= 0` and `x == 1 ==> i <= N` are needed because if `x` is initialized to 1, we need to ensure that `i` stays within the loop bounds.\n- Similarly, `x == 2 ==> i >= 0` and `x == 2 ==> i <= N` are needed if `x` is initialized to 2.\n- `(NONDET <= 0 && x == 2) ==> !(x > 2)` and `(NONDET > 0 && x == 1) ==> !(x > 2)` are needed because if `NONDET` is less than or equal to 0 and `x` is initialized to 2, or if `NONDET` is greater than 0 and `x` is initialized to 1, then we know that `!(x > 2)` must hold. This is because `x` can only be 1 or 2, and in both cases `x > 2` is false.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@\n  loop invariant i <= N;\n  loop invariant x <= 2;\n  loop invariant x >= 1;\n  loop invariant NONDET > 0 ==> x == 1;\n  loop invariant NONDET <= 0 ==> x == 2;\n  loop invariant i >= N || (i < N && \\false);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i <= N is preserved but not established.\nloop invariant x <= 2 is partially proven to be inductive.\nloop invariant x >= 1 is partially proven to be inductive.\nloop invariant NONDET > 0 ==> x == 1 is partially proven to be inductive.\nloop invariant NONDET <= 0 ==> x == 2 is partially proven to be inductive.\nloop invariant i >= N || (i < N && \\false) is preserved but not established.\nAssertion !(x > 2): Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@\n\nloop invariant i2: x <= 2;\nloop invariant i3: x >= 1;\nloop invariant i4: NONDET > 0 ==> x == 1;\nloop invariant i5: NONDET <= 0 ==> x == 2;\n\n*/\nwhile (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@\n    loop invariant i <= N;\n    loop invariant x == 1 || x == 2;\n    loop invariant !(x > 2) ==> i <= N;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i <= N is preserved but not established.\nloop invariant x == 1 || x == 2 is partially proven to be inductive.\nloop invariant !(x > 2) ==> i <= N is partially proven to be inductive.\nAssertion !(x > 2): Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@\n\nloop invariant i2: x == 1 || x == 2;\n\n*/\nwhile (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@\nloop invariant 0 <= i; // i is non-negative\nloop invariant i <= N; // i is always less than or equal to N\nloop invariant x == 1 ==> !(i >= N); // if x is 1, then i must be less than N\nloop invariant x == 2 ==> !(i < N); // if x is 2, then i must be greater than or equal to N\nloop invariant i == N ==> x <= 2; // if i equals N, then x must be less than or equal to 2\nloop invariant i != N ==> x >= 1; // if i is not equal to N, then x must be greater than or equal to 1\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= i is preserved but not established.\nloop invariant i <= N is preserved but not established.\nloop invariant x == 1 ==> !(i >= N) is neither established nor preserved.\nloop invariant x == 2 ==> !(i < N) is preserved but not established.\nloop invariant i == N ==> x <= 2 is established but not preserved.\nloop invariant i != N ==> x >= 1 is partially proven to be inductive.\nAssertion !(x > 2): Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@\n\n\n\n\n\nloop invariant i6: i != N ==> x >= 1;\n*/\nwhile (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 14: unbound logic variable i_max. Ignoring loop annotation",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@\nloop invariant i1: i_min <= i <= i_max;\nloop invariant i2: i <= N;\nloop invariant i3: x <= 2;\nloop invariant i4: x >= 1;\nloop invariant i5: NONDET > 0 ==> x == 1;\nloop invariant i6: NONDET <= 0 ==> x == 2;\nloop invariant i7: i >= N || (i < N && \\false);\nloop invariant i8: x == 1 || x == 2;\nloop invariant i9: !(x > 2) ==> i <= N;\nloop invariant i10: 0 <= i;\nloop invariant i11: x == 1 ==> !(i >= N);\nloop invariant i12: x == 2 ==> !(i < N);\nloop invariant i13: i == N ==> x <= 2;\nloop invariant i14: i != N ==> x >= 1;\n*/\nwhile (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
        "combined_annotation_num_solver_calls": 4,
        "code_after_prune": "#define assume(e) if(!(e)) return;\n\nvoid errorFn() {ERROR: goto ERROR;}\nvoid main(){\n\n  int NONDET;\n  int i,N;\n  int a;\n  int x;\n\n  if (NONDET > 0) x=1; else x=2;\n\n  /*@\n\n\nloop invariant i3: x <= 2;\nloop invariant i4: x >= 1;\nloop invariant i5: NONDET > 0 ==> x == 1;\nloop invariant i6: NONDET <= 0 ==> x == 2;\n\nloop invariant i8: x == 1 || x == 2;\n\n\n\n\nloop invariant i13: i == N ==> x <= 2;\nloop invariant i14: i != N ==> x >= 1;\n*/\nwhile (i<N){\n    i=i+1;\n  }\n\n  {;\n//@ assert(!( x >2 ));\n}\n\nreturn;\n\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c"
        ],
        "skipped": [],
        "total": 243,
        "success_count": 117,
        "failure_count": 126,
        "success_rate": 0.48148148148148145
    }
}