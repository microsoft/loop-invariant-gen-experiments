{
    "log": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while (x >= 0 && x + y >= 0) {\n        x = x + y + z;\n        y = -z - 1;\n    }\n    return 0;\n}",
        "success": true,
        "simple_variants": [
            [
                "x + y"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while (x >= 0 && x + y >= 0) {\n        x = x + y + z;\n        y = -z - 1;\n    }\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "At the beginning of each loop, the variables `x` and `y` are live. They are both changed inside the loop. \n\nThe loop continues while `x` is non-negative and `x + y` is non-negative. \n\nThe changes to `x` and `y` inside the loop depend on the initial values of `x`, `y`, and `z`. \n\nThe loop variant we can choose is `x + y` because its value is always decreasing in each iteration (since `y` is changed to `-z - 1` in each iteration, and `z` is not modified in the loop). \n\nThe ranking function is:\n\n```\n/*@\n    loop variant x + y;\n*/\n```\n\nThis is a valid ranking function because it decreases in every loop iteration and is greater than or equal to zero while the loop is executing. This means that the loop will eventually terminate.",
            "Firstly, we need to identify the variables that are live at the loop head. In this case, those are `x`, `y`, and `z`.\n\nSecondly, we analyze the loop body. We can see that `x` is updated as `x + y + z` and `y` is updated as `-z - 1`. \n\nThe loop continues as long as `x` is non-negative and `x + y` is non-negative. \n\nTherefore, the ranking function can be `x + y`, as this value is non-negative at the start of every loop iteration and strictly decreases with each iteration (since `y` is updated as `-z - 1` in every iteration, and `z` is constant within the loop). \n\nThus, the ranking function in ACSL syntax would be:\n```\n/*@\n    loop variant x + y;\n*/\n```\n\nThis is a valid ranking function because it is always positive as long as the loop is executing (as per the loop condition `x >= 0 && x + y >= 0`) and strictly decreases with every loop iteration.",
            "First, note that the variables `x`, `y`, and `z` are live at the loop head. \n\nThe loop continues as long as `x` and `x+y` are greater than or equal to 0. \n\nLooking at the loop body, we see that `x` is updated to `x+y+z` and `y` is updated to `-z-1` in each iteration. \n\nA possible ranking function for this loop could be `x+y`. This expression is live at the loop head and is decreased in each iteration because `y` is updated to `-z-1`, which is less than the old `y`. \n\nThe ranking function is positive during loop execution as required by the loop condition `x+y >= 0`. \n\nSo the ranking function in ACSL syntax would be:\n```\n/*@\n    loop variant x + y;\n*/\n```",
            "The variables x and y are live at the loop head, so they are the ones that we need to focus on. The starting values or constraints for x and y are not given, they are assigned to the value of an unknown_int() function, so they can be any integer value.\n\nIn the loop, x is being updated as x + y + z and y as -z - 1. The value of z is not changed inside the loop. \n\nSince both x and y are positive for the loop to continue, we need to find a function that decreases with every iteration of the loop and is positive while the loop is executing.\n\nOne possible ranking function is x + y. \n\nThe reason this is a valid ranking function is that:\n\n- It is positive while the loop is executing (as the loop continues while x >= 0 and x + y >= 0).\n- It decreases with every iteration of the loop. After each iteration, x is updated as x + y + z and y is updated as -z - 1. This makes the sum x + y smaller after each iteration, since the new value of y is -z -1 which is likely to be negative as z is not changing.\n\nSo, the ranking function in ACSL syntax would be:\n\n```c\n/*@\n    loop variant x + y;\n*/\n```\n\nThis ranking function helps prove that the loop must terminate since it is decreasing on each iteration and is positive while the loop is executing.",
            "The initial values of the variables x, y, z are unknown. However, the loop guard is `x >= 0 && x + y >= 0`.\n\nThis means that `x` and `x + y` must be non-negative for the loop to continue executing. Therefore, these two expressions are the constraints that the variables live at the loop head must satisfy.\n\nIn the loop body, `x` is incremented by `y` and `z`, and `y` is updated to `-z - 1`.\n\nFrom this, we can see that `x` and `y` are updated in every iteration of the loop, while `z` remains constant.\n\nA possible ranking function is `x + y`.\n\nThis is because `x + y` is always non-negative at the loop head (due to the loop guard), and decreases in every iteration of the loop (since `x` is incremented by `y` and `z`, and `y` is updated to `-z - 1`).\n\nTherefore, the ranking function for this loop is `x + y`.\n\nHere is the loop with the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x + y;\n*/\nwhile (x >= 0 && x + y >= 0) {\n    x = x + y + z;\n    y = -z - 1;\n}\n```"
        ],
        "simple_variant_log": {
            "success": true,
            "['x + y']": {
                "variant": [
                    "x + y"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\n    loop invariant x + y >= 0;\n*/",
                    "/*@\n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= 0;\n    loop invariant x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= 0;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\n    loop invariant x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n    loop invariant \\at(z, LoopEntry) == z;\n*/",
                    "/*@ \n    loop invariant x + y <= \\at(x + y, LoopEntry);\n    loop invariant x >= 0;\n    loop invariant x + y >= 0;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= -1;\n    loop invariant z == \\at(z, LoopEntry);\n    loop invariant x + y >= 0;\n    loop invariant x + y <= \\at(x + y, LoopEntry);\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression becomes positive and decreases, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while (x >= 0 && x + y >= 0) {\n        x = x + y + z;\n        y = -z - 1;\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x + y)**, for the loop in the program above. Let's think step by step."
                    },
                    "At the loop head, the live variables are x, y, and z. The loop condition is \"x >= 0 && x + y >= 0\" and the given ranking function is \"x + y\".\n\nLet's consider the loop invariants that are true:\n\n(i) before the loop execution,\n(ii) in every iteration of the loop and\n(iii) after the loop termination,\nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n\nFrom the loop condition, we know that \"x\" and \"x + y\" are both non-negative at the start of each loop iteration. From the code in the loop body, we see that \"x\" is updated to \"x + y + z\" and \"y\" is updated to \"-z - 1\". \n\nBased on this analysis, the following loop invariants can be formulated:\n\n```\n/*@ \n    loop invariant x >= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\n    loop invariant x + y >= 0;\n*/\n```\nThe first loop invariant states that the current value of \"x\" is greater than or equal to the sum of the initial values of \"x\" and \"y\". This is derived from the update rule for \"x\" in the loop body.\n\nThe second loop invariant states that the sum of the initial values of \"x\" and \"y\" is greater than or equal to the current value of \"x + y\". This is derived from the loop condition and the update rules for \"x\" and \"y\" in the loop body.\n\nThe third loop invariant states that the value of \"x + y\" is non-negative. This is derived from the loop condition.\n\nThese loop invariants imply that the ranking function \"x + y\" decreases with every iteration of the loop, thus supporting the termination of the loop.",
                    "- The loop condition is `(x >= 0 && x + y >= 0)`.\n- The variables live at the loop head are `x`, `y`, and `z`.\n- The ranking function is `(x + y)`.\n- The loop body updates `x` and `y` as follows: `x = x + y + z; y = -z - 1;`.\n\nLet's write down the loop invariants:\n\n```\n/*@\n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= 0;\n    loop invariant x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n*/\n```\nIn the loop invariants above:\n- The first invariant is the loop condition `x >= 0`, which is guaranteed to be true at the start of each loop iteration.\n- The second invariant is the loop condition `x + y >= 0`, which is also guaranteed to be true at the start of each loop iteration.\n- The third invariant is derived from the loop body and the ranking function. As `x` is updated to `x + y + z` and `y` is updated to `-z - 1`, the value of `x + y` in the current iteration will always be less than or equal to its value in the previous iteration. Therefore, the ranking function `(x + y)` is non-increasing, which supports termination.",
                    "The variables that are live at the loop head are **x**, **y**, and **z**.\n\nThe loop condition is **(x >= 0 && x + y >= 0)**, and the ranking function given is **(x + y)**.\n\nBefore the loop execution, the values of **x**, **y**, and **z** are unknown.\n\nIn every iteration of the loop:\n- **x** is updated to **x + y + z**\n- **y** is updated to **-z - 1**\n\nAfter the loop termination, we know that **x** is negative or **x + y** is negative.\n\nThe loop invariants that support the ranking function and prove the loop termination are:\n- At the loop entry, **x** and **x + y** are non-negative.\n- In every iteration, **x** and **y** are updated, but **z** remains the same.\n- If **x** becomes negative, the loop terminates.\n- If **x + y** becomes negative, the loop terminates.\n\nHere are the loop invariants:\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= 0;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\n    loop invariant x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n    loop invariant \\at(z, LoopEntry) == z;\n*/\n```",
                    "First, we note that the variables `x`, `y`, and `z` can initially hold any arbitrary integer values.\n\nThe loop condition is `(x >= 0 && x + y >= 0)`. The loop variant is `(x + y)`. \n\nWe are required to find loop invariants that imply that `(x + y)` decreases with every loop iteration.\n\nThe loop body is:\n```\nx = x + y + z;\ny = -z - 1;\n```\nTo find the loop invariants, let's analyze the loop body.\n\nAfter the first line of the loop body, `x` is updated to `x + y + z`. On the second line, `y` is updated to `-z - 1`. This results in the new value of `x + y` being `x + y + z - z - 1` which equals to `x + y - 1`.\n\nThis implies that `x + y` decreases by 1 in each loop iteration. Hence, the loop will terminate when `x + y < 0` or when `x < 0`.\n\nBased on these observations, the loop invariants are:\n```\n/*@ \n    loop invariant x + y <= \\at(x + y, LoopEntry);\n    loop invariant x >= 0;\n    loop invariant x + y >= 0;\n*/\n```\nThese invariants are true before the loop execution, in every iteration of the loop, and after the loop termination. These loop invariants imply that the loop variant `(x + y)` decreases with every iteration, therefore, the loop terminates.",
                    "- At the loop head, the variables **x**, **y**, and **z** are live.\n- The loop condition is **(x >= 0 && x + y >= 0)**.\n- Given the ranking function **(x + y)**.\n- The loop body is modifying **x** and **y**.\n\nConsider the following loop invariants:\n\n- **x** and **y** are always greater than or equal to **-1**.\n- **x** is always greater than or equal to **0**.\n- **z** remains the same throughout the loop.\n- The sum of **x** and **y** is always greater than or equal to **0**.\n- The sum of **x** and **y** decreases with every iteration of the loop.\n\nWriting these loop invariants as ACSL annotations:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= -1;\n    loop invariant z == \\at(z, LoopEntry);\n    loop invariant x + y >= 0;\n    loop invariant x + y <= \\at(x + y, LoopEntry);\n*/\n```"
                ],
                "inductive_invariants": "loop invariant i2: \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\nloop invariant i6: x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\nloop invariant i7: \\at(z, LoopEntry) == z;\nloop invariant i8: x + y <= \\at(x + y, LoopEntry);\nloop invariant i11: z == \\at(z, LoopEntry);",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    /*@\nloop invariant i2: \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\nloop invariant i6: x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\nloop invariant i7: \\at(z, LoopEntry) == z;\nloop invariant i8: x + y <= \\at(x + y, LoopEntry);\nloop invariant i11: z == \\at(z, LoopEntry);\nloop variant x + y;\n*/\nwhile (x >= 0 && x + y >= 0) {\n        x = x + y + z;\n        y = -z - 1;\n    }\n    return 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y is inductive.\nloop invariant x + y <= \\at(x, LoopEntry) + \\at(y, LoopEntry) is inductive.\nloop invariant \\at(z, LoopEntry) == z is inductive.\nloop invariant x + y <= \\at(x + y, LoopEntry) is inductive.\nloop invariant z == \\at(z, LoopEntry) is inductive.\n\n\nLoop variant is Valid."
                    }
                ],
                "success": true
            }
        },
        "simple_variant_success": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Benghazi_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c"
        ],
        "skipped": [],
        "total": 58,
        "success_count": 88,
        "failure_count": 58,
        "success_rate": 1.5172413793103448
    }
}