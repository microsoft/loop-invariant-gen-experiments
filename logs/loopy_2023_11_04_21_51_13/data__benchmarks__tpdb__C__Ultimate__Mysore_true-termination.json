{
    "log": {
        "file": "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n\tint x = unknown_int();\n\tint c = unknown_int();\n\tif (c < 2) {\n\t\treturn 0;\n\t}\n\twhile (x + c >= 0) {\n\t\tx = x - c;\n\t\tc = c + 1;\n\t}\n\treturn 0;\n}",
        "success": true,
        "simple_variants": [
            [
                "x + c"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n\tint x = unknown_int();\n\tint c = unknown_int();\n\tif (c < 2) {\n\t\treturn 0;\n\t}\n\twhile (x + c >= 0) {\n\t\tx = x - c;\n\t\tc = c + 1;\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n1. x is an unknown integer.\n2. c is an unknown integer, but it is constrained to be greater than or equal to 2.\n\nNow, analyze the loop body:\n\n1. In each iteration, x is updated by subtracting c from its current value.\n2. In each iteration, c is updated by adding 1 to its current value.\n\nThe loop condition is `x + c >= 0`. We need to find a ranking function that decreases with every iteration and is positive while the loop is executing.\n\nA valid ranking function for this loop is `x + c`. Here's why:\n\n1. The loop condition ensures that `x + c >= 0`, so the ranking function is positive while the loop is executing.\n2. In each iteration, x is decreased by c, and c is increased by 1. Since c is always greater than or equal to 2, the net change in `x + c` is `-c + 1`. This value is negative, so the ranking function decreases with every iteration.\n\nNow, let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x + c;\n*/\n```",
            "1. Starting values or constraints for the variables:\n- x: x can be any integer as it is assigned the result of unknown_int().\n- c: c can be any integer as it is assigned the result of unknown_int(). However, the program returns if c < 2, so we know that c >= 2.\n\n2. Analyze the loop body:\n- The loop continues as long as x + c >= 0.\n- In each iteration of the loop, x is updated with x - c, and c is updated with c + 1.\n\n3. Ranking function:\nConsider the function f(x, c) = x + c. Initially, f(x, c) >= 0 for the loop to start. In each iteration, x is updated to x - c and c is updated to c + 1, so f(x, c) is updated to (x - c) + (c + 1) = x + 1. Since c >= 2, x is always reduced by at least 1 in each iteration, so the ranking function is decreasing. The loop continues as long as f(x, c) >= 0, so the ranking function is positive while the loop is executing.\n\nOutput the ranking function in ACSL syntax:\n```\n/*@\n    loop variant x + c;\n*/\n```",
            "1. First, let's identify the variables that are live at the loop head: `x` and `c`.\n2. Next, we analyze the loop body and find a ranking function involving the variables in the loop body. We need an expression that decreases with every iteration and is positive while the loop is executing.\n\nIn the loop body, the value of `x` is decreased by `c`, and the value of `c` is increased by 1 in each iteration. The loop continues as long as `x + c >= 0`. We can use the sum of `x` and `c` as our ranking function.\n\nHere is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x + c;\n*/\n```\n\nThis ranking function is valid because it decreases with every iteration (since `x` decreases by `c` and `c` increases by 1) and is positive while the loop is executing (because the loop condition requires `x + c >= 0`).",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head.\n\nx = unknown_int();\nc = unknown_int();\nif (c < 2) {\n    return 0;\n}\n\nHere, `x` is an unknown integer, and `c` is an unknown integer with a constraint that it must be greater than or equal to 2.\n\nNow, let's analyze the loop body:\n\nwhile (x + c >= 0) {\n    x = x - c;\n    c = c + 1;\n}\n\nIn each iteration of the loop, `x` is decremented by the value of `c`, and `c` is incremented by 1. The loop continues as long as the sum of `x` and `c` is greater than or equal to 0.\n\nNow, let's find a ranking function involving the variables `x` and `c`. Since `c` is always positive and increasing, we can use `x + c` as the ranking function.\n\nThe ranking function is:\n\n```\n/*@\n    loop variant x + c;\n*/\n```\n\nThis ranking function is valid because:\n1. It is decreasing with every iteration of the loop, as `x` is decremented by `c`, and `c` is incremented by 1.\n2. It evaluates to a positive value while the loop is executing, as the loop condition is `x + c >= 0`.",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- x is an unknown integer value.\n- c is an unknown integer value, with the constraint that c >= 2.\n\nNext, let's analyze the loop body:\n- x is updated to x - c\n- c is updated to c + 1\n\nNow, we will find a ranking function involving the variables in the loop body. A suitable ranking function in this case is (x + c). \n\nLet's explain why it is a valid ranking function:\n1. The loop condition is (x + c >= 0), so the value of the ranking function is positive while the loop is executing.\n2. In every iteration of the loop, x is updated to (x - c), and c is updated to (c + 1). Thus, the new value of x + c in the next iteration is (x - c) + (c + 1) = x + 1. Since x + 1 is strictly less than x + c, the ranking function is decreasing with every iteration of the loop.\n\nTherefore, the ranking function is valid. We can now output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x + c;\n*/\n```"
        ],
        "simple_variant_log": {
            "success": true,
            "['x + c']": {
                "variant": [
                    "x + c"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant c >= 2;\n    loop invariant \\at(x + c, LoopEntry) >= 0;\n    loop invariant x + c <= \\at(x + c, LoopEntry) - (\\at(c, LoopEntry) - 1);\n    loop invariant x + c < 0;\n*/",
                    "/*@ \n    loop invariant c >= 2;\n    loop invariant x + c >= 0;\n    loop invariant \\at(x, LoopEntry) - x >= \\at(c, LoopEntry);\n    loop invariant \\at(c, LoopEntry) < c <= \\at(c, LoopEntry) + \\at(x, LoopEntry) / \\at(c, LoopEntry);\n*/",
                    "/*@ \n    loop invariant c >= 2;\n    loop invariant x + c >= \\at(x + c, LoopEntry) - c;\n*/",
                    "/*@ \n    loop invariant c >= 2;\n    loop invariant \\at(x, LoopEntry) - x >= c - \\at(c, LoopEntry);\n    loop invariant x + c >= 0;\n*/",
                    "/*@ \n    loop invariant c >= 2;\n    loop invariant c <= \\at(c, LoopEntry) + 1;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant x + c <= \\at(x, LoopEntry) + \\at(c, LoopEntry);\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression becomes positive and decreases, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n\tint x = unknown_int();\n\tint c = unknown_int();\n\tif (c < 2) {\n\t\treturn 0;\n\t}\n\twhile (x + c >= 0) {\n\t\tx = x - c;\n\t\tc = c + 1;\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x + c)**, for the loop in the program above. Let's think step by step."
                    },
                    "- The starting values for the variables `x` and `c` are arbitrary, but `c` is constrained to be at least 2.\n- The loop condition is `x + c >= 0`.\n- The given ranking function is `x + c`.\n\nWe can derive the following loop invariants:\n\n- Before the loop execution, `x + c` is non-negative.\n- In every iteration of the loop, `x + c` decreases by `c - 1`.\n- After the loop termination, `x + c` is negative.\n\nThe loop invariants are as follows:\n\n```\n/*@ \n    loop invariant c >= 2;\n    loop invariant \\at(x + c, LoopEntry) >= 0;\n    loop invariant x + c <= \\at(x + c, LoopEntry) - (\\at(c, LoopEntry) - 1);\n    loop invariant x + c < 0;\n*/\n```\n\nThese invariants imply that the ranking function decreases with every iteration, which proves the termination of the loop.",
                    "- The variables live at the loop head are `x` and `c`.\n- The loop condition is `x + c >= 0`.\n- The ranking function is `x + c`.\n\nThe loop invariants that support the validity of the ranking function and prove the termination of the loop are as follows:\n\n```\n/*@ \n    loop invariant c >= 2;\n    loop invariant x + c >= 0;\n    loop invariant \\at(x, LoopEntry) - x >= \\at(c, LoopEntry);\n    loop invariant \\at(c, LoopEntry) < c <= \\at(c, LoopEntry) + \\at(x, LoopEntry) / \\at(c, LoopEntry);\n*/\n```\nExplanation:\n\n- `c >= 2` is invariant because `c` is always incremented inside the loop, and the loop is only entered if `c >= 2`.\n- `x + c >= 0` is the loop condition, so it is trivially a loop invariant.\n- `\\at(x, LoopEntry) - x >= \\at(c, LoopEntry)` expresses that `x` is decremented by at least `c` in each iteration. This, together with `c >= 2`, ensures that `x + c` decreases in each iteration.\n- `\\at(c, LoopEntry) < c <= \\at(c, LoopEntry) + \\at(x, LoopEntry) / \\at(c, LoopEntry)` bounds the value of `c` from below and above. The lower bound is trivial. The upper bound ensures that `c` does not increase too much, so that `x + c` can become negative, which would contradict the loop condition. This, together with `c >= 2` and `\\at(x, LoopEntry) - x >= \\at(c, LoopEntry)`, ensures that the loop terminates.",
                    "The program starts by initializing two variables, `x` and `c`, with unknown values. If `c` is less than 2, the program terminates early. If `c` is greater than or equal to 2, the program enters a loop that continues until `x + c` is negative. In each iteration of the loop, `x` is decreased by `c` and `c` is increased by 1.\n\nThe loop variant provided is `x + c`, which decreases with each iteration of the loop as `x` decreases and `c` increases. To prove that this loop variant is correct, we need to find invariants that are true before the loop starts, during each iteration of the loop, and after the loop ends.\n\nHere are the loop invariants:\n\n```\n/*@ \n    loop invariant c >= 2;\n    loop invariant x + c >= \\at(x + c, LoopEntry) - c;\n*/\n```\n\nExplanation:\n\n1. `c >= 2`: This invariant is true before the loop starts because of the conditional statement before the loop. It remains true during each iteration because `c` is only increased.\n\n2. `x + c >= \\at(x + c, LoopEntry) - c`: This invariant is true during each iteration because `x` is decreased by `c` and `c` is increased by 1 in each iteration. This ensures that the value of `x + c` in the current iteration is always less than or equal to the value of `x + c` in the previous iteration minus `c`. This invariant supports the loop variant because it ensures that `x + c` decreases in every iteration of the loop.",
                    "- The loop condition is `(x + c >= 0)`.\n- The variables that are live at the loop head are `x` and `c`.\n- The ranking function is `(x + c)`.\n- The loop invariant should state that the ranking function `(x + c)` is non-negative and decreases with every iteration of the loop.\n\nThe loop invariants that support the validity of the ranking function `(x + c)` are:\n\n```\n/*@ \n    loop invariant c >= 2;\n    loop invariant \\at(x, LoopEntry) - x >= c - \\at(c, LoopEntry);\n    loop invariant x + c >= 0;\n*/\n```\n- `c >= 2` : This is true before the loop because of the condition `if (c < 2) return 0;` and remains true in every iteration of the loop as `c` is always incremented.\n- `\\at(x, LoopEntry) - x >= c - \\at(c, LoopEntry)` : This is true because in every iteration of the loop, `x` is decreased by `c` and `c` is incremented by `1`. So, the difference between the old and new values of `x` is always greater than or equal to the difference between the old and new values of `c`.\n- `x + c >= 0` : This is the loop condition and is always true during loop execution. When the loop terminates, `x + c` is negative which signifies that the ranking function has decreased in every iteration of the loop.\n\nThese loop invariants imply that the ranking function `(x + c)` is always non-negative and decreases with every iteration of the loop, therefore proving the termination of the loop.",
                    "The loop condition is (x + c >= 0), the loop variant is (x + c), and the loop body updates are x = x - c and c = c + 1.\n\nBefore the loop, the value of c is positive as it is guaranteed by the if condition (c < 2). The value of x can be any integer.\n\nInside the loop, the loop variant (x + c) decreases as x is reduced by c and c is increased by 1 in every iteration.\n\nAfter the loop, the loop condition is false, so (x + c < 0).\n\nNow, we are ready to write down the loop invariants that are true before the loop, during every iteration of the loop, and after the loop terminates. These loop invariants support the loop variant (x + c) and prove the loop termination.\n\n```\n/*@ \n    loop invariant c >= 2;\n    loop invariant c <= \\at(c, LoopEntry) + 1;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant x + c <= \\at(x, LoopEntry) + \\at(c, LoopEntry);\n*/\n```\n\nThe first invariant is true because the value of c is initially at least 2 and it only increases inside the loop.\n\nThe second invariant is true because the value of c increases by 1 in each iteration.\n\nThe third invariant is true because the value of x decreases in each iteration.\n\nThe fourth invariant guarantees that the loop variant (x + c) decreases in each iteration.\n\nAfter the loop, the loop condition is false so (x + c < 0). Therefore, the loop terminates."
                ],
                "inductive_invariants": "loop invariant i1: c >= 2;\nloop invariant i9: \\at(x, LoopEntry) - x >= c - \\at(c, LoopEntry);\nloop invariant i11: x <= \\at(x, LoopEntry);\nloop invariant i12: x + c <= \\at(x, LoopEntry) + \\at(c, LoopEntry);",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n\tint x = unknown_int();\n\tint c = unknown_int();\n\tif (c < 2) {\n\t\treturn 0;\n\t}\n\t/*@\nloop invariant i1: c >= 2;\nloop invariant i9: \\at(x, LoopEntry) - x >= c - \\at(c, LoopEntry);\nloop invariant i11: x <= \\at(x, LoopEntry);\nloop invariant i12: x + c <= \\at(x, LoopEntry) + \\at(c, LoopEntry);\nloop variant x + c;\n*/\nwhile (x + c >= 0) {\n\t\tx = x - c;\n\t\tc = c + 1;\n\t}\n\treturn 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant c >= 2 is inductive.\nloop invariant \\at(x, LoopEntry) - x >= c - \\at(c, LoopEntry) is inductive.\nloop invariant x <= \\at(x, LoopEntry) is inductive.\nloop invariant x + c <= \\at(x, LoopEntry) + \\at(c, LoopEntry) is inductive.\n\n\nLoop variant is Valid."
                    }
                ],
                "success": true
            }
        },
        "simple_variant_success": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c"
        ],
        "skipped": [],
        "total": 31,
        "success_count": 55,
        "failure_count": 31,
        "success_rate": 1.7741935483870968
    }
}