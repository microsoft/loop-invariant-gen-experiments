{
    "log": {
        "file": "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n\twhile (0) {\n\t}\n\treturn 0;\n}\n",
        "success": false,
        "simple_variants": [
            [
                "1"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n\twhile (0) {\n\t}\n\treturn 0;\n}\n\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "In this program, the loop is an empty `while (0)` loop. This loop will never be executed because the loop condition is always false (0). Since the loop does not have any variables or any body to analyze, there is no ranking function needed. The loop is trivially terminating.",
            "In this given program, the while loop has the condition (0), which is a constant value and evaluates to false. This means that the loop will never execute, and there is no need for a ranking function as the loop is guaranteed to not run and therefore terminate.\n\nHowever, if you still want a ranking function for this loop, you can use any arbitrary positive constant value, as the loop will not execute, and the value will not decrease or change.\n\nHere's an example of a ranking function:\n\n```\n/*@\n    loop variant 1;\n*/\n```",
            "In the given program, the loop will never execute because the loop condition is `while (0)`. This means that the loop is not dependent on any variables and will never run. Therefore, there is no need for a ranking function in this case, as the loop will never execute and will always terminate.",
            "In this given program, there is a loop with the condition `while (0)`. This condition is always false, and therefore, the loop will never execute. Since the loop doesn't execute, there are no live variables at the loop head, and no loop body to analyze.\n\nAs a result, there is no need for a ranking function in this case.",
            "In this case, the loop condition is `0`, which is a constant value and always false. This means that the loop will never execute, and there is no need for a ranking function. The loop is trivially terminated since it doesn't run at all."
        ],
        "simple_variant_log": {
            "success": false,
            "['1']": {
                "variant": [
                    "1"
                ],
                "invariant_code_blocks": [
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "Since this is an empty loop with a condition that is always false, there are no variables or expressions to analyze. The loop never executes. Therefore, there are no loop invariants that can be defined for this loop. \n\nThe ranking function is a constant function and does not decrease with each iteration, because there are no iterations. Therefore, this ranking function does not prove the termination of the loop. However, the loop does terminate because its condition is always false."
                    ],
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "This is a trivial case as the loop condition is always `false`, which means the loop will never execute. The loop variant `(1)` is also trivial in this case as there are no variables to consider. So, there are no loop invariants to state."
                    ],
                    "/*@ \n    loop invariant \\true;\n*/",
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "Since the loop condition is always false, the loop will never execute. Thus, there are no loop invariants to output. The loop trivially terminates."
                    ],
                    "/*@ \n    loop invariant \\true;\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression becomes positive and decreases, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n\twhile (0) {\n\t}\n\treturn 0;\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(1)**, for the loop in the program above. Let's think step by step."
                    },
                    "Since this is an empty loop with a condition that is always false, there are no variables or expressions to analyze. The loop never executes. Therefore, there are no loop invariants that can be defined for this loop. \n\nThe ranking function is a constant function and does not decrease with each iteration, because there are no iterations. Therefore, this ranking function does not prove the termination of the loop. However, the loop does terminate because its condition is always false.",
                    "This is a trivial case as the loop condition is always `false`, which means the loop will never execute. The loop variant `(1)` is also trivial in this case as there are no variables to consider. So, there are no loop invariants to state.",
                    "The program given has an empty while loop with a condition that is always false (while(0)). This means that the loop is never entered, and thus it trivially terminates. \n\nHowever, since the task is to provide loop invariants to prove a ranking function, we can assume a trivial ranking function that is always constant (for example, 1). \n\nGiven the ranking function 1, and the fact that the loop is never entered, the following loop invariants can be provided:\n\n```\n/*@ \n    loop invariant \\true;\n*/\n```\n\nThis loop invariant is true before the loop execution, during every iteration of the loop (which are zero), and after the loop termination. It supports the constant ranking function because it does not contradict the fact that the ranking function remains constant (since the loop is never entered).",
                    "Since the loop condition is always false, the loop will never execute. Thus, there are no loop invariants to output. The loop trivially terminates.",
                    "Given the provided code, there is no explicit ranking function, as the loop condition is \"0\", which means the loop does not get executed at all. However, since we are asked to consider a ranking function of **(1)**, we can still provide a loop invariant that holds before and after the (non-executed) loop.\n\nLoop invariant:\n```\n/*@ \n    loop invariant \\true;\n*/\n```\nThis loop invariant always holds true, regardless of the loop's execution, as it is not dependent on any variables or conditions."
                ],
                "error": "",
                "success": false
            }
        },
        "simple_variant_success": false,
        "lexicographic_variants": [],
        "lexicographic_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head. A ranking function can be used to prove that a loop terminates.\nA lexicographic ranking function is a sequence of expressions with the property that each expression must be positive for the loop to execute.\nFor example, if (e1, e2, e3) is a lexicographic ranking function, then e1 is positive and decreases, or e1 remains the same and e2 is positive and decreases, or e1 and e2 remain the same and e3 is positive and decreases. This can be extended to as many expressions as needed.\nFind the lexicographic ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function such that:\n    - The first expression in the ranking function is positive and decreases.\n    - If the first expression remains the same, the second expression is positive and decreases.\n    - If the first and second expressions remain the same, the third expression is positive and decreases and so on.\n- Output the ranking function in one code block, in ACSL syntax, in their lexicographic order. For example, if the ranking function is (v1, v2), output it as:\n```\n/*@\n    loop variant v1;\n    loop variant v2;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n\twhile (0) {\n\t}\n\treturn 0;\n}\n\n```\nFind a lexicographic ranking function for the loop in the given program, such that the first expression decreases with every iteration of the loop, and evaluates to a positive value while the loop is executing.\nIf the first expression remains constant, then the second expression should decrease with every iteration of the loop, and evaluate to a positive value while the loop is executing, and so on.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step."
            },
            "The given program has a loop that will never be executed because its condition is `0` (which is equivalent to `false`). Therefore, there is no need for a ranking function in this case because the loop will never run and thus there is no need to prove termination.",
            "The loop in the program is an empty loop that will never execute since the condition for the loop is `0` which is a constant and equivalent to `false`. Hence, there are no variables that change inside the loop or have an effect on the loop's termination. In other words, there is no lexicographic ranking function because the loop does not execute. \n\nIn a program that has a loop which executes, we would identify the variables that change within the loop and look for a sequence of expressions (the lexicographic ranking function) such that the first expression decreases with every iteration of the loop and evaluates to a positive value while the loop is executing, and so on. But in this case, since the loop does not execute, there is no such function.",
            "The given loop is empty and the condition for the loop to execute is \"0\", which is always false. Therefore, this loop will never execute, and there is no need for a ranking function.",
            "The loop in the given program is an empty loop with the condition `0`, which means it will never execute. Therefore, there are no variables live at the loop head, and the loop does not have a ranking function as it does not execute at all. Hence, there is no lexicographic ranking function for this loop.",
            "The given program has an empty loop with the loop condition being '0' (which is equivalent to 'false'). This loop condition makes the loop non-executable as the condition is always false, meaning the loop body will never be executed. \n\nSince the loop will not execute, it is trivially terminating and thus no need for a ranking function. So, there is no lexicographic ranking function for this loop."
        ],
        "lexicographic_variant_log": {
            "success": false
        },
        "lexicographic_variant_success": false,
        "multi_phase_variants": [
            [
                "0"
            ]
        ],
        "multi_phase_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head. A ranking function can be used to prove that a loop terminates.\nA multi-phase ranking function is a sequence of ranking functions that can be used to prove termination of a loop.\nIn a multi-phase ranking function, the first expression decreases with successive iterations of the loop, and when it becomes non-positive, the second expression decreases and so on.\nFor example, if (e1, e2, e3) is a multi-phase ranking function, we begin with e1 being positive. Once e1 becomes non-positive, we move on to e2, which decreases with every loop iteration. Once e2 becomes non-positive, we move on to e3 which decreases till it becomes non-positive and the loop terminates.\nFind the multi-phase ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function such that:\n    - The first expression decreases in the first iteration of the loop and continues to decrease\n    - The second expression decreases once the first expression becomes zero or negative\n    - so on... till the last expression decreases till the loop terminates.\n- Output the ranking function in one code block, in ACSL syntax, in the order they decrease, in different lines. For example,\n```\n/*@\n    loop variant v1;\n    loop variant v2;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n\twhile (0) {\n\t}\n\treturn 0;\n}\n\n```\n\nFind a multi-phase ranking function such that, the first expression decreases with successive iterations of the loop. When the first expression becomes non-positive, the second expression decreases with successive iterations of the loop. This goes on until the last expression becomes non-positive and the loop terminates.\n\nFor the first expression in the ranking function, always choose an expression that immediately decreases with every iteration of the loop. \nFor the second expression, find an expression that decreases once the first expression becomes zero or negative, and so on.\n\nUse non-deterministically updated variables only if such variables are definitely decreasing with every iteration of the loop at some point.\n\nAdding a non-positive expression to a positive expression could result in a non-positive expression. \n\nFind the ranking function for the loop in the given program. Let's think step by step."
            },
            "The given program has a loop with a constant condition \"0\", which means the loop will never execute. Therefore, there is no need for a ranking function, as the loop doesn't iterate. The program will directly move to the return statement.\n\nHowever, to fulfill the requirement of providing a ranking function, we can use a dummy one:\n\n```\n/*@\n    loop variant 0;\n*/\n```\n\nSince the loop never iterates, the ranking function will never decrease and remains non-positive (0), and the loop terminates immediately.",
            "In the given program, the loop has no body and the loop condition is \"0\", which is a constant false value. It means that the loop will never execute, and there is no need for a ranking function to prove its termination, as it terminates immediately.\n\nHowever, if you still want to provide a ranking function for this loop, you can use a constant value that is non-positive, as the loop never iterates, and the ranking function would be valid.\n\nThe ranking function for this loop would be:\n\n```\n/*@\n    loop variant 0;\n*/\n```",
            "The given program has a loop with a condition \"0\", which means the loop will never be executed. There's no need to find a multi-phase ranking function since the loop will not run and it trivially terminates.",
            "There is no ranking function needed for this loop because the loop condition is `0`, which is always false. The loop will never be executed, and therefore it trivially terminates.",
            "The given program has a while loop with a condition `0`, which means the loop will never be executed. In this case, we do not need a multi-phase ranking function, as the loop does not perform any iterations and terminates immediately."
        ],
        "multi_phase_variant_log": {
            "success": false,
            "['0']": {
                "variant": [
                    "0"
                ],
                "invariant_code_blocks": [
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "The given program contains an empty loop that never executes as the loop condition is always false. Hence, there are no variables live at the loop head. The ranking function is a constant 0. \n\nSince the loop never executes, the ranking function does not decrease with every iteration. In fact, there is no iteration at all. \n\nWe can say that the loop trivially terminates as it never enters an execution cycle. Therefore, no loop invariants are needed to support the ranking function or to prove loop termination. \n\nHence, no loop invariants can be generated for this program."
                    ],
                    "/*@ \n    loop invariant \\true;\n*/",
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "Since the loop condition is always false, the loop will never execute. Hence, there is no need for a ranking function or loop invariants to prove termination. The loop is trivially terminating."
                    ],
                    "/*@ \n    loop invariant \\false;\n*/",
                    "/*@ \n    loop invariant \\true;\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression becomes positive and decreases, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n\twhile (0) {\n\t}\n\treturn 0;\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(0)**, for the loop in the program above. Let's think step by step."
                    },
                    "The given program contains an empty loop that never executes as the loop condition is always false. Hence, there are no variables live at the loop head. The ranking function is a constant 0. \n\nSince the loop never executes, the ranking function does not decrease with every iteration. In fact, there is no iteration at all. \n\nWe can say that the loop trivially terminates as it never enters an execution cycle. Therefore, no loop invariants are needed to support the ranking function or to prove loop termination. \n\nHence, no loop invariants can be generated for this program.",
                    "The given loop is an empty loop with the condition **0**. This means that the loop is never executed. \n\nSince the loop is never executed, there are no variables that are live at the loop head. Therefore, we don't have any ranking function or loop invariants to prove the termination of the loop.\n\nThe loop invariant in this case is a trivial one - true, because the condition of the loop is always false, so the loop body is never executed. \n\nHere is the loop invariant:\n```\n/*@ \n    loop invariant \\true;\n*/\n```",
                    "Since the loop condition is always false, the loop will never execute. Hence, there is no need for a ranking function or loop invariants to prove termination. The loop is trivially terminating.",
                    "The program contains an empty loop that never executes because the loop condition is always false (0). Therefore, there are no variables live at the loop head, and there is no loop body to analyze. \n\nWe need to find loop invariants that support the loop variant (0). Since the loop never executes, any invariant will trivially hold. The loop variant is a constant (0), which does not change with iterations because there are no iterations.\n\nWe have a trivial loop invariant: the loop condition is always false.\n\nHere are the loop invariants:\n\n```c\n/*@ \n    loop invariant \\false;\n*/\n```\nThese invariants hold (i) before the loop execution, (ii) in every iteration of the loop (though there are no iterations), and (iii) after the loop termination. They imply that the loop variant (0) does not change with iterations because there are no iterations.",
                    "- The loop in the program is a degenerate case of a loop as it never executes, due to its condition being always false (while(0)).\n- Therefore, we can consider the ranking function to be the constant function 0. \n- Since the loop does not execute, it doesn't have any effect on the state of the program. So, we do not need to consider any variables or their values.\n- The loop invariant will be a tautology, meaning it will always hold true.\n\nHence, the loop invariant for this program would be:\n\n```c\n/*@ \n    loop invariant \\true;\n*/\n```"
                ],
                "error": "",
                "success": false
            }
        },
        "multi_phase_variant_success": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c"
        ],
        "skipped": [],
        "total": 31,
        "success_count": 55,
        "failure_count": 31,
        "success_rate": 1.7741935483870968
    }
}