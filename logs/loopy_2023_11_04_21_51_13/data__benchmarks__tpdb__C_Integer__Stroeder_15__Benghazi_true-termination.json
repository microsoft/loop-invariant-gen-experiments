{
    "log": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Benghazi_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main()\n{\n    int x, d1, d2, d1old;\n\td1 = 73;\n\td2 = 74;\n\tx = unknown_int();\n\twhile (x >= 0) {\n\t\tx = x - d1;\n\t\td1old = d1;\n\t\td1 = d2 + 1;\n\t\td2 = d1old + 1;\n\t}\n\treturn 0;\n}",
        "success": true,
        "simple_variants": [
            [
                "x"
            ],
            [
                "x + d1"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main()\n{\n    int x, d1, d2, d1old;\n\td1 = 73;\n\td2 = 74;\n\tx = unknown_int();\n\twhile (x >= 0) {\n\t\tx = x - d1;\n\t\td1old = d1;\n\t\td1 = d2 + 1;\n\t\td2 = d1old + 1;\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "1. Starting values or constraints for the variables that are live at the loop head:\n   - `x` is an unknown integer value, so we don't have any constraints on it.\n   - `d1` starts at 73.\n   - `d2` starts at 74.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body:\n   - In the loop, `x` is being decreased by `d1` in each iteration.\n   - `d1` is being increased by `d2 + 1` in each iteration.\n   - `d2` is being increased by `d1old + 1` in each iteration.\n\n3. Based on the analysis, we can find a ranking function that decreases with every iteration and is positive while the loop is executing. In this case, the ranking function will be the value of `x`.\n\nThe ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant x;\n*/\n```\n\nExplanation:\n\n- The value of `x` is non-negative at the start of the loop (`x >= 0`).\n- The value of `x` is decreased by `d1` in each iteration, making it decrease with every iteration.\n- The loop terminates when `x` becomes negative (`x < 0`).\n\nThis ranking function is valid as it satisfies the requirements of being positive while the loop is executing, and decreasing with every iteration.",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head:\n   - `x` is an unknown integer\n   - `d1` starts at 73\n   - `d2` starts at 74\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body:\n   - `x` is decreased by `d1` in every iteration\n   - `d1` is updated to `d2 + 1`\n   - `d2` is updated to `d1old + 1`, where `d1old` is the previous value of `d1`\n\nNow, let's find the ranking function. Since `x` is decreasing by `d1` in every iteration and `d1` is always positive, we can use `x` as our ranking function:\n\n```\n/*@\n    loop variant x;\n*/\n```\n\nThis is a valid ranking function because:\n   - The value of `x` decreases with every iteration of the loop since it's subtracted by `d1`, which is positive.\n   - The value of `x` must be positive for the loop to continue executing, as the loop condition is `x >= 0`.",
            "1. Starting values or constraints for the variables that are live at the loop head:\n   - d1 = 73\n   - d2 = 74\n   - x is an unknown integer\n\n2. Analyzing the loop body:\n   - x is decremented by d1 in each iteration\n   - d1 and d2 are incremented by 1 in each iteration\n\n3. Finding a ranking function involving the variables in the loop body:\n   - Since x is decreasing in each iteration and d1 is increasing, we can use the expression x + d1 as the ranking function. This expression will decrease in every iteration and will be positive as long as the loop is executing.\n\nOutput the ranking function in one code block, in ACSL syntax:\n\n```\n/*@\n    loop variant x + d1;\n*/\n```",
            "1. Starting values or constraints for the variables live at the loop head:\n   - `x` is an unknown integer, so we don't have any constraints on its initial value.\n   - `d1` is initialized to 73, and `d2` is initialized to 74.\n\n2. Analyze the loop body:\n   - `x` is decreasing in every iteration because it's being subtracted by `d1`.\n   - `d1` is updated to `d2 + 1` in every iteration.\n   - `d2` is updated to `d1old + 1` in every iteration, where `d1old` is the old value of `d1`.\n\n3. Finding the ranking function:\n   Since `x` is decreasing by at least `d1` in every iteration, and `d1` is always positive (starting from 73 and increasing), we can use `x` as the ranking function. The value of `x` is always positive when the loop is executing, and it's decreasing with each iteration.\n\nOutput the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "1. The starting values or constraints for the variables that are live at the loop head are:\n- `x` is initialized with an unknown integer value.\n- `d1` is initialized with 73.\n- `d2` is initialized with 74.\n\n2. Analyze the loop body:\n- The loop continues as long as `x` is greater than or equal to 0.\n- In each iteration, `x` is updated to `x - d1`.\n- `d1` is updated to `d2 + 1`.\n- `d2` is updated to `d1old + 1`.\n\nNow, let's find the ranking function.\n\nSince `x` is decreasing in every iteration by the value of `d1`, and `d1` is always positive (as it is initialized with 73 and updated with `d2 + 1` which is also always positive), the ranking function can be `x`. \n\nThe ranking function is:\n\n```\n/*@\n    loop variant x;\n*/\n```\n\nThis ranking function is valid because:\n- It decreases with every iteration of the loop (as `x` is updated to `x - d1`, and `d1` is always positive).\n- It is positive as long as the loop is executing (as the loop continues while `x >= 0`)."
        ],
        "simple_variant_log": {
            "success": true,
            "['x']": {
                "variant": [
                    "x"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant \\at(d1, LoopEntry) == 73;\n    loop invariant \\at(d2, LoopEntry) == 74;\n    loop invariant d1old == \\at(d1, LoopEntry) - 1;\n    loop invariant d1 == \\at(d2, LoopEntry) + 1;\n    loop invariant d2 == \\at(d1old, LoopEntry) + 1;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant d1 > 0;\n    loop invariant d2 > 0;\n    loop invariant d1 == d2 - 1;\n    loop invariant d1 > \\at(d1, LoopEntry);\n*/",
                    "/*@ \n    loop invariant d1 >= 73;\n    loop invariant d2 >= 74;\n    loop invariant d1 == \\at(d2 + 1, LoopEntry);\n    loop invariant d2 == \\at(d1old + 1, LoopEntry);\n    loop invariant d1old == \\at(d1, LoopEntry);\n    loop invariant d1old >= 73;\n    loop invariant x == \\at(x - d1, LoopEntry);\n    loop invariant x >= -d1;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant d1 > 0;\n    loop invariant d2 > 0;\n    loop invariant d1 >= 73;\n    loop invariant d2 >= 74;\n    loop invariant d1 <= \\at(d1, LoopEntry) + 1;\n    loop invariant d2 <= \\at(d1, LoopEntry) + 2;\n    loop invariant \\at(x, LoopEntry) >= x;\n*/",
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant d1 == \\at(d1, LoopEntry) + 1;\n    loop invariant d2 == \\at(d1, LoopEntry) + 2;\n    loop invariant x <= \\at(x, LoopEntry);\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression becomes positive and decreases, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main()\n{\n    int x, d1, d2, d1old;\n\td1 = 73;\n\td2 = 74;\n\tx = unknown_int();\n\twhile (x >= 0) {\n\t\tx = x - d1;\n\t\td1old = d1;\n\t\td1 = d2 + 1;\n\t\td2 = d1old + 1;\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x)**, for the loop in the program above. Let's think step by step."
                    },
                    "- The loop condition is **x >= 0**. \n- The variables **x**, **d1**, **d2**, and **d1old** are live at the loop head.\n- The ranking function for this loop is **x**. \n- The ranking function value is non-negative and decreases with each iteration of the loop.\n- The variables **x**, **d1**, **d2**, and **d1old** are updated within the loop.\n- Before the loop, **d1 = 73** and **d2 = 74**, and **x** can be any integer value.\n\nFrom the analysis of the loop body, the following loop invariants can be inferred:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant \\at(d1, LoopEntry) == 73;\n    loop invariant \\at(d2, LoopEntry) == 74;\n    loop invariant d1old == \\at(d1, LoopEntry) - 1;\n    loop invariant d1 == \\at(d2, LoopEntry) + 1;\n    loop invariant d2 == \\at(d1old, LoopEntry) + 1;\n*/\n```\n\nThese loop invariants are true before the loop execution, in every iteration of the loop, and after the loop termination. They imply that the ranking function, **x**, decreases with every iteration, proving the termination of the loop.",
                    "The initial values of the variables are:\n- `d1` is 73\n- `d2` is 74\n- `x` is an unknown integer\n\nThe loop condition is `x >= 0`.\n\nInside the loop body, \n- `x` is reduced by `d1`, \n- `d1` and `d2` are both increased by 1 in a roundabout way. \n\nThe ranking function is `x`, which is guaranteed to decrease in each iteration because `x` is decreased by `d1` and `d1` is always positive.\n\nThe loop invariants that support the validity of the ranking function and prove the termination of the loop are:\n- `x` is always non-negative at the loop head\n- `d1` is always positive\n- `d2` is always positive\n- `d1` is always equal to `d2 - 1`\n- `d1` is always greater than its previous value at the loop head\n\nThese can be written in ACSL as follows:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant d1 > 0;\n    loop invariant d2 > 0;\n    loop invariant d1 == d2 - 1;\n    loop invariant d1 > \\at(d1, LoopEntry);\n*/\n```",
                    "In the program, the loop condition is `x >= 0`. The ranking function is `x`. The ranking function is initialized to some unknown integer value and is decremented by `d1` in every iteration of the loop.\n\nBefore the loop execution, we know that `d1 = 73` and `d2 = 74`. During the loop, `d1` and `d2` are updated such that `d1 = d2 + 1` and `d2 = d1old + 1`. We can also note that `d1` and `d2` are always positive.\n\nWe can now output the loop invariants.\n\n```\n/*@ \n    loop invariant d1 >= 73;\n    loop invariant d2 >= 74;\n    loop invariant d1 == \\at(d2 + 1, LoopEntry);\n    loop invariant d2 == \\at(d1old + 1, LoopEntry);\n    loop invariant d1old == \\at(d1, LoopEntry);\n    loop invariant d1old >= 73;\n    loop invariant x == \\at(x - d1, LoopEntry);\n    loop invariant x >= -d1;\n*/\n```\nThese loop invariants imply that `x` decreases with every iteration of the loop, thereby supporting the ranking function and proving the termination of the loop.",
                    "The loop variant here is **x**. At the start of each loop iteration, **x** is non-negative. In each loop iteration, **x** is decremented by **d1** and **d1** is incremented by 1. Hence, **x** strictly decreases in each loop iteration.\n\nThe loop condition is **x >= 0**. This means that the loop continues as long as **x** is non-negative.\n\nBefore the loop execution, **d1** and **d2** are initialized to 73 and 74 respectively. Inside the loop, **d1** and **d2** are updated such that they are always greater than their initial values. Hence, **d1** and **d2** are always positive.\n\nThe loop invariants that support the loop variant and prove the termination of the loop are:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant d1 > 0;\n    loop invariant d2 > 0;\n    loop invariant d1 >= 73;\n    loop invariant d2 >= 74;\n    loop invariant d1 <= \\at(d1, LoopEntry) + 1;\n    loop invariant d2 <= \\at(d1, LoopEntry) + 2;\n    loop invariant \\at(x, LoopEntry) >= x;\n*/\n```\n\nThese invariants are true before the loop execution, in every iteration of the loop and after the loop termination. They imply that **x** decreases with every iteration, proving the termination of the loop.",
                    "The variables live at the loop head are x, d1, and d2. Their initial values are unknown except d1 = 73 and d2 = 74.\n\nThe loop condition is x >= 0.\n\nThe loop variant is x, which is the only value changing in the loop.\n\nThe loop invariant should describe the relation between x, d1, and d2, and state that x is non-negative and decreases in every iteration.\n\nThe loop invariants are:\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant d1 == \\at(d1, LoopEntry) + 1;\n    loop invariant d2 == \\at(d1, LoopEntry) + 2;\n    loop invariant x <= \\at(x, LoopEntry);\n*/\n```\n\nThese loop invariants are valid:\n\n(i) before the loop execution: \n    - x is non-negative as per the loop condition, \n    - d1 == 73 + 1 = 74, \n    - d2 == 73 + 2 = 75, \n    - and x is less than or equal to its initial value.\n\n(ii) in every iteration of the loop:\n    - x is non-negative as per the loop condition, \n    - d1 increases by 1 in every iteration, \n    - d2 is always one more than the old value of d1, \n    - and x decreases in every iteration by the value of d1, which is always greater than 0.\n\n(iii) after the loop termination: \n    - the loop terminates when x becomes negative, so the loop invariants are not valid after the loop termination. However, they support the fact that the loop variant decreases with every iteration, proving the loop's termination."
                ],
                "inductive_invariants": "loop invariant i2: \\at(d1, LoopEntry) == 73;\nloop invariant i3: \\at(d2, LoopEntry) == 74;\nloop invariant i7: d1 > 0;\nloop invariant i8: d2 > 0;\nloop invariant i11: d1 >= 73;\nloop invariant i12: d2 >= 74;\nloop invariant i21: \\at(x, LoopEntry) >= x;\nloop invariant i25: x <= \\at(x, LoopEntry);",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main()\n{\n    int x, d1, d2, d1old;\n\td1 = 73;\n\td2 = 74;\n\tx = unknown_int();\n\t/*@\nloop invariant i2: \\at(d1, LoopEntry) == 73;\nloop invariant i3: \\at(d2, LoopEntry) == 74;\nloop invariant i7: d1 > 0;\nloop invariant i8: d2 > 0;\nloop invariant i11: d1 >= 73;\nloop invariant i12: d2 >= 74;\nloop invariant i21: \\at(x, LoopEntry) >= x;\nloop invariant i25: x <= \\at(x, LoopEntry);\nloop variant x;\n*/\nwhile (x >= 0) {\n\t\tx = x - d1;\n\t\td1old = d1;\n\t\td1 = d2 + 1;\n\t\td2 = d1old + 1;\n\t}\n\treturn 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant \\at(d1, LoopEntry) == 73 is inductive.\nloop invariant \\at(d2, LoopEntry) == 74 is inductive.\nloop invariant d1 > 0 is inductive.\nloop invariant d2 > 0 is inductive.\nloop invariant d1 >= 73 is inductive.\nloop invariant d2 >= 74 is inductive.\nloop invariant \\at(x, LoopEntry) >= x is inductive.\nloop invariant x <= \\at(x, LoopEntry) is inductive.\n\n\nLoop variant is Valid."
                    }
                ],
                "success": true
            }
        },
        "simple_variant_success": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Benghazi_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c"
        ],
        "skipped": [],
        "total": 39,
        "success_count": 70,
        "failure_count": 39,
        "success_rate": 1.794871794871795
    }
}