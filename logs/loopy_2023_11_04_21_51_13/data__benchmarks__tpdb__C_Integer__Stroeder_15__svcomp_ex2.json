{
    "log": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    }\n    return 0;\n}",
        "success": true,
        "simple_variants": [
            [
                "z - y"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    }\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "This program contains a while loop that continues to execute as long as `y < z` and `flag > 0`. Inside this loop, `y` is potentially updated according to the conditions: `y > 0` and `x > 1` or `y > 0` and `x < -1`. If neither of these conditions are true, `flag` is set to 0, which would cause the loop to terminate. \n\nA suitable ranking function for this loop is `z - y`. This value is initially positive as `y < z` is a loop condition. This value is also decreasing with each iteration of the loop as `y` is increasing. \n\nTherefore, `z - y` is a valid ranking function for this loop. \n\nThe following is the ACSL syntax for the ranking function:\n\n```c\n/*@\n    loop variant z - y;\n*/\n```",
            "The loop in the given program continues to execute as long as `y < z` and `flag > 0`. The value of `y` changes within the loop depending on the conditions.\n\nIn the loop, the value of `y` gets multiplied by `x` or `-x` (if `y > 0` and `x` is either greater than `1` or less than `-1`) or the loop stops (`flag = 0`). \n\nTaking this into account, a suitable ranking function could be `z - y`. \n\nThis is because the value of `y` is increasing in each loop iteration (either by multiplication with `x` or `-x`), thus `z - y` is decreasing. The loop continues to execute as long as `y < z` which ensures that `z - y` is always positive during loop execution.\n\nTherefore, the ranking function in ACSL syntax would be:\n\n```\n/*@\n    loop variant z - y;\n*/\n```\n\nThis ranking function is valid as it respects the conditions of being positive during the loop execution and decreasing with each loop iteration.",
            "The loop in the program continues to execute as long as `y < z` and `flag > 0`. Inside the loop, `y` is multiplied by either `x` or `-x` depending on the value of `x`, and `flag` is set to 0 if neither condition is met. `c` is incremented by 1 at every iteration but does not affect the loop termination. \n\nThe loop termination depends on the value of `y`, `z`, `x`, and `flag`. If `flag` becomes 0, the loop terminates. If `y >= z`, the loop also terminates. The loop variant should involve these variables.\n\nOne possible ranking function is `z - y`. This function decreases with every iteration of the loop since `y` is either multiplied by `x` or `-x` (where `x` is larger than 1 or less than -1) and thus `y` is getting closer to `z` with each iteration. \n\nIn ACSL syntax, the ranking function would be:\n\n```\n/*@\n    loop variant z - y;\n*/\n```\nThis ranking function is valid because it decreases with each iteration of the loop, is positive for the loop to continue executing, and reaches 0 or a negative value when the loop terminates.",
            "In the given program, the variables that are live at the loop head are `y`, `z`, and `flag`.\n\n`y` and `z` are arbitrary integers and `flag` is a boolean variable initialized to 1.\n\nLooking at the loop body:\n\n- `y` is multiplied by `x` or `-x` if `y > 0` and `x > 1` or `x < -1` respectively.\n- If neither of these conditions are met, `flag` is set to 0, which stops the loop.\n\nThe loop continues as long as `y < z` and `flag > 0`. \n\nThe `flag` variable, being a boolean, could act as a potential ranking function as it changes its value to 0 when the loop is to be stopped. However, it does not decrease with each iteration of the loop, and hence is not a valid ranking function.\n\nThe `c` variable, which increments by 1 in each loop iteration, is also not a valid ranking function because it increases rather than decreases with each iteration. \n\nThe variable `y` is multiplied by `x` or `-x` in each iteration of the loop, but its value doesn't necessarily decrease with each iteration. \n\nThe variable `z` remains constant throughout the loop, hence it cannot be a ranking function.\n\nThere is no valid ranking function involving the variables in the loop body alone. However, if we consider the difference between `z` and `y`, it is a valid ranking function. The value of `z - y` is always positive as long as the loop is executing and it decreases with every iteration of the loop.\n\nThe ranking function for the loop in the given program is `z - y`.\n\nHere is the loop with the ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant z - y;\n*/\nwhile ((y < z) && (flag > 0)) {\n    if ((y > 0) && (x > 1)) {\n        y = x*y;\n    } else {\n        if ((y > 0) && (x < -1)) {\n            y = -x*y;\n        } else {\n            flag = 0;\n        }\n    }\n    c = c + 1;\n}\n```",
            "The loop in this program is controlled by the variables `y`, `z`, and `flag`. The loop continues as long as `y < z` and `flag > 0`.\n\nInside the loop, `y` is updated based on the conditions `y > 0` and `x > 1` or `y > 0` and `x < -1`. If neither of these conditions is met, `flag` is set to `0` which would break the loop. \n\nFrom this, we can infer that `y` is increasing or decreasing in each iteration. This makes it difficult to find a simple ranking function. The variables `x`, `y`, and `z` are initialized with unknown values, so we cannot make any assumptions about them.\n\nThe only variable that always increases is `c`, but it is not directly involved in the loop condition.\n\nIf we consider the worst-case scenario, the loop would iterate until `y` is no longer less than `z`, assuming `flag` remains `1`. If `y` is multiplied by `x` or `-x` in each iteration, and `x` or `-x` is greater than `1` in absolute value, then `y` would eventually reach `z`. Therefore, `z - y` could be a valid ranking function because it decreases in each iteration and is positive as long as the loop continues.\n\nLet's use `z - y` as the ranking function.\n\nHere is the loop variant in ACSL syntax:\n```c\n/*@\n    loop variant z - y;\n*/\n```\nThis ranking function `z - y` is valid because it decreases with each iteration of the loop (assuming `x` or `-x` is greater than `1` in absolute value) and is positive as long as `y < z`, which is part of the loop condition. If `x` or `-x` is not greater than `1` in absolute value, `flag` would be set to `0` and the loop would terminate."
        ],
        "simple_variant_log": {
            "success": false,
            "['z - y']": {
                "variant": [
                    "z - y"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant c >= 0;\n    loop invariant flag >= 0;\n    loop invariant flag <= 1;\n    loop invariant y <= z;\n    loop invariant y <= \\at(y, LoopEntry) * (\\at(x, LoopEntry) < -1 ? -\\at(x, LoopEntry) : \\at(x, LoopEntry)) ==> \\at(x, LoopEntry) != 1;\n*/",
                    "/*@ \n    loop invariant y >= 0;\n    loop invariant y < z;\n    loop invariant flag > 0;\n    loop invariant c >= 0;\n    loop invariant z - y >= 0;\n*/",
                    "/*@ \n    loop invariant c == 0 && flag == 1;\n    loop invariant y <= \\at(y, LoopEntry) * x;\n    loop invariant y <= \\at(y, LoopEntry) * -x;\n    loop invariant flag <= \\at(flag, LoopEntry);\n    loop invariant c >= \\at(c, LoopEntry) + 1;\n*/",
                    "/*@\n    loop invariant y <= z;\n    loop invariant flag >= 0;\n    loop invariant flag <= 1;\n    loop invariant \\at(y, LoopEntry) <= y;\n    loop invariant (x > 1 && y > 0) ==> y >= \\at(y, LoopEntry) * x;\n    loop invariant (x < -1 && y > 0) ==> y >= \\at(y, LoopEntry) * -x;\n    loop invariant (x <= 1 || y <= 0) ==> flag == 0;\n    loop invariant c >= \\at(c, LoopEntry);\n    loop invariant c == \\at(c, LoopEntry) + 1;\n*/",
                    "/*@ \n    loop invariant c >= 0;\n    loop invariant z == \\at(z, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry) ==> y <= z;\n    loop invariant y > \\at(y, LoopEntry) ==> y >= z;\n    loop invariant flag == 0 ==> y >= z || x == 0;\n    loop invariant flag == 1 ==> y < z && x != 0;\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression starts decreasing and is positive, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(z - y)**, for the loop in the program above. Let's think step by step."
                    },
                    "Firstly, let's note the variables that are live at the loop head: `c`, `flag`, `x`, `y`, and `z`.\n\nThe loop condition is `(y < z) && (flag > 0)`. \n\nThe loop variant is `z - y`.\n\nNow, we need to find the loop invariants.\n\nBefore the loop execution, we know that `c` is 0 and `flag` is 1. We don't know anything about `x`, `y`, and `z` as they are non-deterministic.\n\nIn every iteration of the loop, we have several conditions. \n\n- If `y > 0` and `x > 1`, then `y` is multiplied by `x`. This makes `y` increase. But if `y` is increasing, then the loop condition `y < z` ensures that `z` is always greater than `y`. \n- If `y > 0` and `x < -1`, then `y` is multiplied by `-x` which is a positive value. Again, `y` is increasing and `z` remains greater than `y` because of the loop condition.\n- If `y` is not greater than 0 or `x` is not greater than 1 or less than -1, then `flag` is set to 0 and the loop will terminate in the next iteration.\n\nAfter the loop termination, `flag` must be 0 or `y` must be greater or equal to `z`.\n\nLet's output the loop invariants.\n\n```c\n/*@ \n    loop invariant c >= 0;\n    loop invariant flag >= 0;\n    loop invariant flag <= 1;\n    loop invariant y <= z;\n    loop invariant y <= \\at(y, LoopEntry) * (\\at(x, LoopEntry) < -1 ? -\\at(x, LoopEntry) : \\at(x, LoopEntry)) ==> \\at(x, LoopEntry) != 1;\n*/\n```",
                    "The loop condition is `(y < z) && (flag > 0)`. This means that the loop terminates when `y >= z` or `flag <= 0`.\n\nThe given ranking function is `(z - y)`, which is always non-negative when `y < z`. This decreases with every iteration of the loop, as `y` increases with every iteration.\n\nThe loop modifies the variables `y`, `flag`, and `c`. The variable `x` is not modified inside the loop.\n\nThe loop invariant about `y` being less than `z` is `(y < z)` and `y` being non-negative is `(y >= 0)`. \n\nThe loop invariant about `flag` is `(flag > 0)`. This implies that `flag` is non-zero and positive within the loop body.\n\nThe loop invariant about `c` is `(c >= 0)`. This implies that `c` is non-negative.\n\nThe invariants `(y >= 0)`, `(y < z)`, `(flag > 0)`, and `(c >= 0)` hold true before the loop execution, during every iteration of the loop, and after the loop termination.\n\nThe loop invariant `(z - y >= 0)` holds true before the loop execution, during every iteration of the loop, and after the loop termination.\n\nFrom these invariants, we can conclude that the given ranking function `(z - y)` decreases with every iteration of the loop, and thus, the loop terminates.\n\nThe loop invariants are as follows:\n\n```\n/*@ \n    loop invariant y >= 0;\n    loop invariant y < z;\n    loop invariant flag > 0;\n    loop invariant c >= 0;\n    loop invariant z - y >= 0;\n*/\n```",
                    "The loop condition is `(y < z) && (flag > 0)`. This implies that the loop terminates when either `y >= z` or `flag <= 0`. The ranking function is `z - y`, which decreases in every iteration of the loop. Now, let's find the loop invariants:\n\n- Before the loop execution: `y` and `z` are uninitialized and can have any value. `flag` is set to 1 and `c` is set to 0. Therefore, the loop invariant is `c == 0 && flag == 1`.\n\n- In every iteration of the loop: The loop body has three cases. In the first two cases, `y` is multiplied by `x` or `-x` (both of which are greater than 1 in absolute value), and in the third case, `flag` is set to 0. Therefore, the loop invariants are `y <= \\at(y, LoopEntry) * x` and `y <= \\at(y, LoopEntry) * -x` and `flag <= \\at(flag, LoopEntry)`. Also, `c` is incremented in every iteration, so another loop invariant is `c >= \\at(c, LoopEntry) + 1`.\n\n- After the loop termination: When the loop terminates, `y >= z` or `flag <= 0`. These are the loop invariants after the termination.\n\nIn ACSL, the loop invariants can be represented as:\n```\n/*@ \n    loop invariant c == 0 && flag == 1;\n    loop invariant y <= \\at(y, LoopEntry) * x;\n    loop invariant y <= \\at(y, LoopEntry) * -x;\n    loop invariant flag <= \\at(flag, LoopEntry);\n    loop invariant c >= \\at(c, LoopEntry) + 1;\n*/\n```",
                    "At the start, `c` is initialized to 0 and `flag` is initialized to 1. The values of `x`, `y`, and `z` are non-deterministic.\n\nIn the loop, `y` is multiplied by `x` or `-x` when `y > 0` and `x > 1` or `x < -1` respectively. Otherwise, `flag` is set to 0. `c` is incremented in every iteration.\n\nThe loop condition is `(y < z) && (flag > 0)`.\n\nThe loop variant is `(z - y)`. It is positive and decreases with each iteration of the loop as `y` is multiplied by `x` or `-x`, making `y` larger, or the loop terminates.\n\nThe loop invariant before the loop execution, in every iteration of the loop and after the loop termination, such that the loop invariant implies that the ranking function decreases with every iteration, can be:\n\n```\n/*@\n    loop invariant y <= z;\n    loop invariant flag >= 0;\n    loop invariant flag <= 1;\n    loop invariant \\at(y, LoopEntry) <= y;\n    loop invariant (x > 1 && y > 0) ==> y >= \\at(y, LoopEntry) * x;\n    loop invariant (x < -1 && y > 0) ==> y >= \\at(y, LoopEntry) * -x;\n    loop invariant (x <= 1 || y <= 0) ==> flag == 0;\n    loop invariant c >= \\at(c, LoopEntry);\n    loop invariant c == \\at(c, LoopEntry) + 1;\n*/\n```\n\nThe first invariant `y <= z` is true because of the loop condition. If it were not true, the loop would not execute.\n\nThe second and third invariants `flag >= 0` and `flag <= 1` are true because `flag` is initialized to 1 and it can only be set to 0 in the loop.\n\nThe fourth invariant `\\at(y, LoopEntry) <= y` is true because `y` is either multiplied by `x` or `-x`, making it larger, or it remains the same.\n\nThe fifth invariant `(x > 1 && y > 0) ==> y >= \\at(y, LoopEntry) * x` is true because when `x > 1` and `y > 0`, `y` is multiplied by `x`.\n\nThe sixth invariant `(x < -1 && y > 0) ==> y >= \\at(y, LoopEntry) * -x` is true because when `x < -1` and `y > 0`, `y` is multiplied by `-x`.\n\nThe seventh invariant `(x <= 1 || y <= 0) ==> flag == 0` is true because when `x <= 1` or `y <= 0`, `flag` is set to 0.\n\nThe eighth invariant `c >= \\at(c, LoopEntry)` is true because `c` is incremented in every iteration.\n\nThe ninth invariant `c == \\at(c, LoopEntry) + 1` is true because `c` is incremented exactly by 1 in every iteration.\n\nThese invariants, together with the loop condition, imply that `(z - y)` decreases with every iteration of the loop. This ensures that the loop terminates.",
                    "- The loop condition is `(y < z) && (flag > 0)`.\n- The loop variant is `z - y`.\n- The variables live at the loop head are `c`, `flag`, `x`, `y`, and `z`.\n\nFrom the loop condition and body, we can see that:\n- `z` is not modified in the loop, so its value remains the same in every iteration.\n- `y` is modified in the loop only when `(y > 0) && (x != 0)`, and it is always multiplied by `x` or `-x` which makes `y` increase or decrease.\n- `flag` is set to `0` when `y <= 0` or `x == 0` which will exit the loop.\n- `c` is incremented in each loop iteration and does not affect the loop termination condition.\n\nSo, the loop invariants that support the loop variant are:\n```\n/*@ \n    loop invariant c >= 0;\n    loop invariant z == \\at(z, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry) ==> y <= z;\n    loop invariant y > \\at(y, LoopEntry) ==> y >= z;\n    loop invariant flag == 0 ==> y >= z || x == 0;\n    loop invariant flag == 1 ==> y < z && x != 0;\n*/\n```\nThese loop invariants imply that the loop variant `z - y` decreases with every iteration, and thus prove the termination of the loop."
                ],
                "inductive_invariants": "loop invariant i1: c >= 0;\nloop invariant i2: flag >= 0;\nloop invariant i3: flag <= 1;\nloop invariant i13: flag <= \\at(flag, LoopEntry);\nloop invariant i15: \\at(y, LoopEntry) <= y;\nloop invariant i19: c >= \\at(c, LoopEntry);\nloop invariant i21: z == \\at(z, LoopEntry);",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    /*@\nloop invariant i1: c >= 0;\nloop invariant i2: flag >= 0;\nloop invariant i3: flag <= 1;\nloop invariant i13: flag <= \\at(flag, LoopEntry);\nloop invariant i15: \\at(y, LoopEntry) <= y;\nloop invariant i19: c >= \\at(c, LoopEntry);\nloop invariant i21: z == \\at(z, LoopEntry);\nloop variant z - y;\n*/\nwhile ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    }\n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant c >= 0 is inductive.\nloop invariant flag >= 0 is inductive.\nloop invariant flag <= 1 is inductive.\nloop invariant flag <= \\at(flag, LoopEntry) is inductive.\nloop invariant \\at(y, LoopEntry) <= y is inductive.\nloop invariant c >= \\at(c, LoopEntry) is inductive.\nloop invariant z == \\at(z, LoopEntry) is inductive.\n\n\nLoop variant is Invalid."
                    }
                ],
                "success": false
            }
        },
        "simple_variant_success": false,
        "lexicographic_variants": [
            [
                "z - y",
                "flag"
            ],
            [
                "z - y",
                "(x >= 0 ? x - 1 : 1 - x)"
            ]
        ],
        "lexicographic_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head. A ranking function can be used to prove that a loop terminates.\nA lexicographic ranking function is a sequence of expressions with the property that each expression must be positive for the loop to execute.\nFor example, if (e1, e2, e3) is a lexicographic ranking function, then e1 is positive and decreases, or e1 remains the same and e2 is positive and decreases, or e1 and e2 remain the same and e3 is positive and decreases. This can be extended to as many expressions as needed.\nFind the lexicographic ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function such that:\n    - The first expression in the ranking function is positive and decreases.\n    - If the first expression remains the same, the second expression is positive and decreases.\n    - If the first and second expressions remain the same, the third expression is positive and decreases and so on.\n- Output the ranking function in one code block, in ACSL syntax, in their lexicographic order. For example, if the ranking function is (v1, v2), output it as:\n```\n/*@\n    loop variant v1;\n    loop variant v2;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    }\n    return 0;\n}\n```\nFind a lexicographic ranking function for the loop in the given program, such that the first expression decreases with every iteration of the loop, and evaluates to a positive value while the loop is executing.\nIf the first expression remains constant, then the second expression should decrease with every iteration of the loop, and evaluate to a positive value while the loop is executing, and so on.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step."
            },
            "First, let's identify the variables that are live at the loop head. These are `y`, `z`, and `flag`.\n\nNow, let's analyze the loop body and find a ranking function. We can see that `y` and `z` are both involved in the loop condition, and `flag` controls whether the loop will continue executing. \n\nThe loop condition is `(y < z) && (flag > 0)`. So, for the loop to execute, `y` must be less than `z`, and `flag` must be positive.\n\nLet's consider the different cases in the loop body:\n\n1. If `(y > 0) && (x > 1)`, then `y` is updated to `x * y`. In this case, `y` increases.\n2. If `(y > 0) && (x < -1)`, then `y` is updated to `-x * y`. In this case, `y` also increases.\n3. If neither of the above conditions is met, `flag` is set to 0, and the loop will not execute again.\n\nNow let's find a lexicographic ranking function:\n\n- For the first expression, we can use `z - y`, as it is positive when the loop is executing (`y < z`), and it decreases whenever `y` increases.\n- For the second expression, we can use `flag`, as it is positive when the loop is executing (`flag > 0`) and it decreases to 0 when none of the conditions in the loop body is met.\n\nSo, the lexicographic ranking function is (z - y, flag).\n\nIn ACSL syntax, the ranking function can be written as:\n\n```\n/*@\n    loop variant z - y;\n    loop variant flag;\n*/\n```",
            "First, let's identify the loop head and the variables that are live at the loop head. The loop head is the while loop condition `((y < z) && (flag > 0))`. The live variables at the loop head are y, z, and flag.\n\nNow, let's analyze the loop body to find a ranking function. There are three cases in the loop body:\n1. If (y > 0) && (x > 1), y is multiplied by x, which increases y.\n2. If (y > 0) && (x < -1), y is multiplied by -x, which also increases y.\n3. If neither of the above conditions is true, flag is set to 0.\n\nSince y increases in the first two cases and the loop continues only if y < z, we can conclude that z is an upper bound for y. Also, if the loop continues to execute, flag must be positive.\n\nWe can use these observations to construct the lexicographic ranking function (z - y, flag):\n\n```\n/*@\n    loop variant z - y;\n    loop variant flag;\n*/\n```\n\nThis ranking function is valid because:\n1. The first expression (z - y) is positive and decreases as y increases in each iteration of the loop.\n2. If the first expression remains the same (which it won't since y increases), the second expression (flag) is positive and decreases when set to 0, terminating the loop.",
            "First, let's identify the variables that are live at the loop head:\n- y\n- z\n- flag\n- x\n\nNow let's analyze the loop body and find a lexicographic ranking function:\n1. If y <= 0 or x == 1 or x == -1, the loop will terminate because flag will be set to 0.\n2. If y > 0 and x > 1, y = x*y, which means y increases.\n3. If y > 0 and x < -1, y = -x*y, which means y also increases.\n\nWe can observe that in both cases (2) and (3), y increases. Since y starts below z, there must be an upper bound for y, and y must eventually reach or surpass z, making the loop terminate.\n\nA possible lexicographic ranking function is (z - y, flag). Let's analyze why this is a valid ranking function:\n- (z - y) is positive and decreases: As y increases in each iteration, z - y decreases. It is also positive because y < z in the loop condition.\n- If (z - y) remains the same, flag is positive and decreases: This case is not possible because y always increases in each iteration, so (z - y) cannot remain the same. But if it were to happen, the loop would terminate because flag would be set to 0.\n\nTherefore, the lexicographic ranking function is (z - y, flag), and it can be written in ACSL syntax as:\n\n```c\n/*@\n    loop variant z - y;\n    loop variant flag;\n*/\n```",
            "First, we need to make note of the starting values or constraints for the variables that are live at the loop head:\n\n1. `y` is initialized with `unknown_int()`, so it can be any integer value.\n2. `z` is initialized with `unknown_int()`, so it can be any integer value.\n3. `flag` is initialized to 1.\n\nNow, let's analyze the loop body. The loop executes while `(y < z)` and `(flag > 0)`. Inside the loop, there are three cases:\n\n1. If `(y > 0)` and `(x > 1)`, `y` is updated to `x * y`.\n2. If `(y > 0)` and `(x < -1)`, `y` is updated to `-x * y`.\n3. Otherwise, `flag` is set to 0, which will terminate the loop.\n\nWe need to find a lexicographic ranking function such that the first expression decreases with every iteration of the loop and evaluates to a positive value while the loop is executing. If the first expression remains constant, then the second expression should decrease with every iteration of the loop, and evaluate to a positive value while the loop is executing, and so on.\n\nThe ranking function for this loop is as follows:\n```\n/*@\n    loop variant z - y;\n    loop variant flag;\n*/\n```\n\nExplanation:\n1. The first expression `z - y` is positive while the loop is executing, as `(y < z)`. It decreases with every iteration of the loop because `y` is being multiplied by a factor greater than 1 (either `x` or `-x`) when `(y > 0)` and `(x > 1)` or `(x < -1)`. In the case where `y` is not updated, `flag` is set to 0, which terminates the loop.\n2. The second expression `flag` is positive while the loop is executing, as `(flag > 0)`. It decreases with every iteration of the loop where `y` is not updated and becomes 0, which terminates the loop.\n\nThus, this lexicographic ranking function proves that the loop terminates.",
            "First, let's identify the variables that are live at the loop head:\n- y\n- z\n- flag\n- x\n\nNow, let's analyze the loop body and find a ranking function.\n\nThe loop condition is `(y < z) && (flag > 0)`.\n\nThere are three cases within the loop body:\n1. `(y > 0) && (x > 1)`: In this case, `y` is updated to `x*y`, so `y` increases.\n2. `(y > 0) && (x < -1)`: In this case, `y` is updated to `-x*y`, so `y` also increases.\n3. Else: In this case, `flag` is set to `0`, which will break the loop.\n\nFor the ranking function, we need expressions that are positive and decrease in at least one of the cases. Since `y` increases in both cases 1 and 2, we can use the difference between `z` and `y` as the first expression in the ranking function.\n\nThe second expression should decrease whenever the first expression remains the same. In this case, we can use the absolute value of `x - 1` (since `x` is either greater than 1 or less than -1) as the second expression.\n\nSo, our lexicographic ranking function is (z - y, |x - 1|). In ACSL syntax:\n\n```\n/*@\n    loop variant z - y;\n    loop variant (x >= 0 ? x - 1 : 1 - x);\n*/\n```"
        ],
        "lexicographic_variant_log": {
            "success": true,
            "['z - y', 'flag']": {
                "variant": [
                    "z - y",
                    "flag"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant c >= 0;\n    loop invariant flag == 0 || flag == 1;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry) ==> y < z;\n*/",
                    "/*@ \n    loop invariant 0 <= c;\n    loop invariant 0 <= y <= z;\n    loop invariant 0 <= flag <= 1;\n    loop invariant (y < z && flag > 0) ==> x != 0;\n    loop invariant (y < z && flag > 0) ==> (y > 0) ==> x > 1;\n    loop invariant (y < z && flag > 0) ==> (y > 0) ==> x < -1;\n*/",
                    "/*@ \n    loop invariant 0 <= c;\n    loop invariant 0 <= flag <= 1;\n    loop invariant \\at(y, LoopEntry) <= y <= z;\n    loop invariant (y > 0 && x > 1) ==> (y < y * x);\n    loop invariant (y > 0 && x < -1) ==> (y < -x * y);\n*/",
                    "/*@ \n    loop invariant 0 <= c;\n    loop invariant 0 <= flag <= 1;\n    loop invariant y <= z;\n    loop invariant (y < z && flag > 0) ==> (y > 0 && (x > 1 || x < -1));\n    loop invariant (y < z && flag > 0) ==> y < \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant flag >= 0;\n    loop invariant c >= 0;\n    loop invariant c == \\at(c, LoopEntry) + 1;\n    loop invariant y <= z;\n    loop invariant y >= \\at(y, LoopEntry) * (x > 1 ? x : (x < -1 ? -x : 1));\n    loop invariant z == \\at(z, LoopEntry);\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression starts decreasing and is positive, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    while ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(z - y, flag)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's identify the starting values or constraints for the variables that are live at the loop head:\n\n1. `c` starts at 0.\n2. `flag` starts at 1.\n3. `x`, `y`, and `z` are assigned values from the `unknown_int()` function, so we don't know their initial values.\n\nNext, let's analyze the loop body:\n\nThe loop condition is `(y < z) && (flag > 0)`. The given ranking function is `(z - y, flag)`.\n\nNow let's find the loop invariants:\n\n1. `c` is non-negative and increases with each iteration.\n2. `flag` is either 0 or 1.\n3. `y` is non-negative.\n4. `y` is less than or equal to `z` during the loop execution.\n\nHere are the loop invariants:\n\n```\n/*@ \n    loop invariant c >= 0;\n    loop invariant flag == 0 || flag == 1;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry) ==> y < z;\n*/\n```",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- c = 0\n- flag = 1\n- x, y, and z are unknown integers\n\nNext, let's analyze the loop condition and the given ranking function:\n- Loop condition: (y < z) && (flag > 0)\n- Ranking function: (z - y, flag)\n\nNow let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant 0 <= c;\n    loop invariant 0 <= y <= z;\n    loop invariant 0 <= flag <= 1;\n    loop invariant (y < z && flag > 0) ==> x != 0;\n    loop invariant (y < z && flag > 0) ==> (y > 0) ==> x > 1;\n    loop invariant (y < z && flag > 0) ==> (y > 0) ==> x < -1;\n*/\n```",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- c = 0\n- flag = 1\n- x = unknown_int()\n- y = unknown_int()\n- z = unknown_int()\n\nNext, let's analyze the loop body and the given ranking function (z - y, flag):\n\nLoop condition: (y < z) && (flag > 0)\n\nRanking function: (z - y, flag)\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant 0 <= c;\n    loop invariant 0 <= flag <= 1;\n    loop invariant \\at(y, LoopEntry) <= y <= z;\n    loop invariant (y > 0 && x > 1) ==> (y < y * x);\n    loop invariant (y > 0 && x < -1) ==> (y < -x * y);\n*/\n```",
                    "First, let's note the starting values for the live variables at the loop head:\n- c starts at 0\n- flag starts at 1\n- x, y, and z are assigned unknown_int() values\n\nNow let's analyze the loop body and its condition:\n- Loop condition: (y < z) && (flag > 0)\n- Loop body: \n  - If (y > 0) && (x > 1), y = x*y\n  - Else if (y > 0) && (x < -1), y = -x*y\n  - Else, flag = 0\n\nNow we can output loop invariants that support the validity of the ranking function (z - y, flag) and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant 0 <= c;\n    loop invariant 0 <= flag <= 1;\n    loop invariant y <= z;\n    loop invariant (y < z && flag > 0) ==> (y > 0 && (x > 1 || x < -1));\n    loop invariant (y < z && flag > 0) ==> y < \\at(y, LoopEntry);\n*/\n```",
                    "Let's first analyze the loop condition, variables and their constraints:\n\n1. Loop condition: (y < z) && (flag > 0)\n2. Variables and constraints:\n   - c: initialized to 0 and incremented by 1 in each iteration.\n   - flag: initialized to 1, and can be set to 0 inside the loop.\n   - x, y, and z: initialized with unknown_int() and can have any integer value.\n\nNow, let's find the loop invariants that support the loop variant (z - y, flag):\n\n1. Before the loop execution:\n   - flag >= 0\n   - c == 0\n\n2. In every iteration of the loop:\n   - flag >= 0\n   - c >= 0\n   - c == \\at(c, LoopEntry) + 1\n   - y <= z\n   - y >= \\at(y, LoopEntry) * (x > 1 ? x : (x < -1 ? -x : 1))\n   - z == \\at(z, LoopEntry)\n\n3. After the loop termination:\n   - y >= z || flag <= 0\n\nNow, let's output the loop invariants:\n\n```\n/*@ \n    loop invariant flag >= 0;\n    loop invariant c >= 0;\n    loop invariant c == \\at(c, LoopEntry) + 1;\n    loop invariant y <= z;\n    loop invariant y >= \\at(y, LoopEntry) * (x > 1 ? x : (x < -1 ? -x : 1));\n    loop invariant z == \\at(z, LoopEntry);\n*/\n```"
                ],
                "inductive_invariants": "loop invariant i1: c >= 0;\nloop invariant i2: flag == 0 || flag == 1;\nloop invariant i5: 0 <= c;\nloop invariant i7: 0 <= flag <= 1;\nloop invariant i12: (y > 0 && x > 1) ==> (y < y * x);\nloop invariant i13: (y > 0 && x < -1) ==> (y < -x * y);\nloop invariant i17: flag >= 0;\nloop invariant i20: z == \\at(z, LoopEntry);",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "typedef struct {\nint a;\nint b;\n} variant_expression;\n\n/*@\npredicate lexicographic(variant_expression v1, variant_expression v2) =\n(v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    //@ ghost variant_expression measure = { z - y, flag };\n/*@\nloop invariant i1: c >= 0;\nloop invariant i2: flag == 0 || flag == 1;\nloop invariant i5: 0 <= c;\nloop invariant i7: 0 <= flag <= 1;\nloop invariant i12: (y > 0 && x > 1) ==> (y < y * x);\nloop invariant i13: (y > 0 && x < -1) ==> (y < -x * y);\nloop invariant i17: flag >= 0;\nloop invariant i20: z == \\at(z, LoopEntry);\nloop invariant measure.a == z - y && measure.b == flag;\nloop variant measure for lexicographic;\n*/\nwhile ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    \n//@ ghost measure.a = z - y;\n//@ ghost measure.b = flag;\n}\n    return 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant c >= 0 is inductive.\nloop invariant flag == 0 || flag == 1 is inductive.\nloop invariant 0 <= c is inductive.\nloop invariant 0 <= flag <= 1 is inductive.\nloop invariant (y > 0 && x > 1) ==> (y < y * x) is inductive.\nloop invariant (y > 0 && x < -1) ==> (y < -x * y) is inductive.\nloop invariant flag >= 0 is inductive.\nloop invariant z == \\at(z, LoopEntry) is inductive.\n\n\nLoop variant is Valid."
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "typedef struct {\nint a;\nint b;\n} variant_expression;\n\n/*@\npredicate multi_phase(variant_expression v1, variant_expression v2) =\n(v1.a > v2.a && v1.a >= 0) ||\n (v1.a > v2.a && v1.a < 0 && v1.b > v2.b && v1.b >= 0);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int c, flag, x, y, z;\n    c = 0;\n    flag = 1;\n    x = unknown_int();\n    y = unknown_int();\n    z = unknown_int();\n    //@ ghost variant_expression measure = { z - y, flag };\n/*@\nloop invariant i1: c >= 0;\nloop invariant i2: flag == 0 || flag == 1;\nloop invariant i5: 0 <= c;\nloop invariant i7: 0 <= flag <= 1;\nloop invariant i12: (y > 0 && x > 1) ==> (y < y * x);\nloop invariant i13: (y > 0 && x < -1) ==> (y < -x * y);\nloop invariant i17: flag >= 0;\nloop invariant i20: z == \\at(z, LoopEntry);\nloop invariant measure.a == z - y && measure.b == flag;\nloop variant measure for multi_phase;\n*/\nwhile ((y < z) && (flag > 0)) {\n        if ((y > 0) && (x > 1)) {\n            y = x*y;\n        } else {\n            if ((y > 0) && (x < -1)) {\n                y = -x*y;\n            } else {\n                flag = 0;\n            }\n        }\n        c = c + 1;\n    \n//@ ghost measure.a = z - y;\n//@ ghost measure.b = flag;\n}\n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant c >= 0 is inductive.\nloop invariant flag == 0 || flag == 1 is inductive.\nloop invariant 0 <= c is inductive.\nloop invariant 0 <= flag <= 1 is inductive.\nloop invariant (y > 0 && x > 1) ==> (y < y * x) is inductive.\nloop invariant (y > 0 && x < -1) ==> (y < -x * y) is inductive.\nloop invariant flag >= 0 is inductive.\nloop invariant z == \\at(z, LoopEntry) is inductive.\n\n\nLoop variant is Invalid."
                    }
                ],
                "success": true
            }
        },
        "lexicographic_variant_success": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Benghazi_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DivMinus.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA5.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Waldkirch_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/easy1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/easy2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.08.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.01.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.02.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.03.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/McCarthyIterative.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MirrorInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c"
        ],
        "skipped": [],
        "total": 95,
        "success_count": 169,
        "failure_count": 95,
        "success_rate": 1.7789473684210526
    }
}