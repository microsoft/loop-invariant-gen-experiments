{
    "log": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int t;\n    x = unknown_int();\n    y = unknown_int();\n    \n    while (x > y) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    \n    return 0;\n}",
        "success": true,
        "simple_variants": [
            [
                "y - x"
            ],
            [
                "x - y"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int t;\n    x = unknown_int();\n    y = unknown_int();\n    \n    while (x > y) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    \n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "The variables live at the head of the loop are `x` and `y`. The loop continues to execute as long as `x` is greater than `y`.\n\nIn the loop body, the value of `x` is assigned to `y` and the value of `y` is assigned to `x`. This effectively swaps the values of `x` and `y`.\n\nSince the loop continues as long as `x` is greater than `y`, and the values of `x` and `y` are swapped in each iteration, we can infer that the difference `y - x` decreases with each iteration of the loop. \n\nTherefore, the ranking function for this loop is `y - x`. This function is valid because it decreases with each iteration of the loop and is positive while the loop is executing.\n\nIn ACSL syntax, the ranking function is expressed as follows:\n\n```\n/*@\n    loop variant y - x;\n*/\n```",
            "The loop is swapping the variables `x` and `y` if `x` is greater than `y`. Therefore, the loop will terminate when `x` is not greater than `y`. \n\nSo, we have the loop variant as `y - x`.\n\nThis is a valid ranking function because:\n\n1. It involves the variables `x` and `y` which are live at the loop head.\n2. It is decreasing with every iteration of the loop as `x` gets the value of `y` and `y` gets the value of `x` when `x` is greater than `y`.\n3. It is positive for the loop to continue executing as the loop condition is `x > y`.\n\nThe ranking function in ACSL syntax would be:\n```\n/*@\n    loop variant y - x;\n*/\n```",
            "At the start of the loop, we have two variables `x` and `y` which could have any integer values. \n\nIn the loop body, `x` and `y` are swapped if `x` is greater than `y`. So, the loop continues as long as `x` is greater than `y`. \n\nWe need a ranking function that is positive and decreasing. The difference `y - x` is a valid ranking function because:\n\n- It is positive while the loop continues (since `x` is greater than `y`).\n- It is decreasing because in each iteration, `x` becomes `y` and `y` becomes `x`, so the difference `y - x` decreases.\n\nSo, the ranking function for this loop is `y - x`.\n\nThe ACSL syntax for this ranking function is:\n```\n/*@\n    loop variant y - x;\n*/\n```",
            "The loop condition here is `x > y`. Therefore, the loop will continue to execute as long as `x` is greater than `y`.\n\nWithin the loop, the values of `x` and `y` are swapped. This means that `x` will always take the value of `y` in the next iteration, and `y` will take the current value of `x`.\n\nGiven that `x > y` for the loop to continue, it means that in each iteration `y` will take a value that is greater than its current value. Therefore, `y` increases with each iteration of the loop until `x` is no longer greater than `y`.\n\nA possible ranking function for this loop is `x - y`. This is because `x - y` will always be positive as long as `x > y`. Moreover, since `y` increases with each iteration (while `x` takes the current value of `y`), `x - y` will decrease with each iteration.\n\nTherefore, the ranking function in ACSL syntax is:\n\n```\n/*@\n    loop variant x - y;\n*/\n```\n\nThis ranking function is valid because it is positive while the loop is executing and decreases with each iteration of the loop.",
            "The loop in the program is swapping the values of `x` and `y` until `x` is less than or equal to `y`. Therefore, the loop is decreasing the value of `x` in each iteration (since `x` is assigned the value of `y`, which is less than `x`), and it is increasing the value of `y` (since `y` is assigned the value of `x`, which is greater than `y`).\n\nThe ranking function is `x - y`. At the beginning of each iteration of the loop, `x` is greater than `y` (since this is the loop condition), so the ranking function is positive. In each iteration of the loop, `x` is decreased and `y` is increased, so the value of the ranking function decreases.\n\nIn ACSL syntax, the ranking function is:\n```\n/*@\n    loop variant x - y;\n*/\n```"
        ],
        "simple_variant_log": {
            "success": true,
            "['y - x']": {
                "variant": [
                    "y - x"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x <= y;\n*/",
                    "/*@ \n    loop invariant \\at(y - x, LoopEntry) >= y - x;\n    loop invariant y >= x;\n*/",
                    "/*@ \n    loop invariant y >= x;\n    loop invariant y - x >= 0;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(x, LoopEntry) <= x;\n*/",
                    "/*@ \n    loop invariant \\at(y, LoopEntry) - x >= 0;\n    loop invariant y - x >= 0;\n*/",
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= y;\n    loop invariant x <= y;\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression starts decreasing and is positive, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int t;\n    x = unknown_int();\n    y = unknown_int();\n    \n    while (x > y) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    \n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(y - x)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, notice that the variables `x`, `y`, and `t` are live at the loop head. \nThe loop condition is `x > y`.\nThe ranking function is `y - x`, which is non-negative as `y` is always greater than or equal to `x` during the loop execution.\n\nBefore the loop execution, there are no constraints on the values of `x` and `y`. Therefore, we don't have any invariants for this part.\n\nDuring the loop execution, `x` and `y` are swapped if `x > y`. This ensures that `y >= x` after every iteration. \n\nAfter the loop termination, `x <= y`.\n\nNow, let's output the loop invariants:\n```\n/*@ \n    loop invariant x <= y;\n*/\n```\nThis loop invariant is enough to imply that the ranking function `y - x` is always non-negative and decreases with every iteration of the loop, thus proving the termination of the loop.",
                    "- The starting values of the variables are unknown. \n- The loop condition is `x > y`.\n- The loop variant is `y - x`.\n\nThe loop invariant that we can derive from these observations are:\n- `y - x` is always less than or equal to the value of `y - x` at the start of the loop.\n- `y` is always greater than or equal to `x`.\n\nThe loop invariants to support the loop variant `(y - x)` are:\n```c\n/*@ \n    loop invariant \\at(y - x, LoopEntry) >= y - x;\n    loop invariant y >= x;\n*/\n```",
                    "The loop condition is `x > y`, and the ranking function is `y - x`. \n\nBefore the loop execution, we don't know the relationship between `x` and `y` because they are assigned to unknown values. \n\nIn every iteration of the loop, `x` and `y` swap their values. If `x` was greater than `y`, after the swap, `y` becomes greater than `x`. \n\nAfter the loop termination, `x` is less than or equal to `y`.\n\nThe loop invariants that support the ranking function are:\n- `y - x` is non-negative. This is because `y` is always greater than or equal to `x` after each iteration and after the loop termination.\n- `y - x` decreases with every iteration. This is because after the swap, `y` is less than its previous value and `x` is greater than its previous value.\n\nThe loop invariants are:\n```\n/*@ \n    loop invariant y >= x;\n    loop invariant y - x >= 0;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(x, LoopEntry) <= x;\n*/\n```",
                    "- The variables live at the loop head are x and y.\n- The loop condition is (x > y).\n- The ranking function given is (y - x).\n\nNow, let's find the loop invariants.\n\n- Before the loop execution, we don't know any relation between x and y because they are assigned unknown values. So, no loop invariant can be determined at this point.\n- In every iteration of the loop, the values of x and y are swapped. This implies that the ranking function (y - x) is non-negative at the beginning of each loop iteration and decreases with each iteration of the loop.\n- After the loop termination, we know that x is not greater than y. This implies that (y - x) is non-negative.\n\nOutput the loop invariants as follows:\n\n```\n/*@ \n    loop invariant \\at(y, LoopEntry) - x >= 0;\n    loop invariant y - x >= 0;\n*/\n```",
                    "- At the beginning of the loop, the values of x, y, and t are unknown. However, we are given the loop condition \"x > y\". \n- The body of the loop swaps the values of x and y. \n- The ranking function is (y - x), which decreases with each iteration as y becomes x and x becomes y if x was initially greater than y.\n\nLet's generate the loop invariants:\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= y;\n    loop invariant x <= y;\n*/\n```\n- The first invariant indicates that the value of x at the beginning of the loop is greater than or equal to y. This is true since the loop condition is \"x > y\". \n- The second invariant indicates that x is always less than or equal to y during the loop execution. This is true since in the loop body, x is assigned the value of y and y is assigned the value of x, if x was initially greater than y. These invariants support the ranking function by ensuring that (y - x) decreases with each loop iteration."
                ],
                "inductive_invariants": "",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int t;\n    x = unknown_int();\n    y = unknown_int();\n    \n    /*@\n\nloop variant y - x;\n*/\nwhile (x > y) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    \n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "Loop variant is Invalid."
                    }
                ],
                "success": false
            },
            "['x - y']": {
                "variant": [
                    "x - y"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= y;\n    loop invariant \\at(y, LoopEntry) <= x;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y >= \\at(y, LoopEntry);\n    loop invariant x >= y;\n*/",
                    "/*@ \n    loop invariant \\at(x, LoopEntry) <= \\at(y, LoopEntry);\n    loop invariant \\at(y, LoopEntry) == \\at(x, LoopEntry);\n    loop invariant x <= y ==> x - y <= 0;\n*/",
                    "/*@ \n    loop invariant x <= \\at(y, LoopEntry);\n    loop invariant y == \\at(x, LoopEntry);\n    loop invariant x == \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant x <= y;\n    loop invariant x >= \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant (x - y) >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y >= \\at(y, LoopEntry);\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression starts decreasing and is positive, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int t;\n    x = unknown_int();\n    y = unknown_int();\n    \n    while (x > y) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    \n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x - y)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note the starting values of the variables. The variables `x` and `y` are initialized by the function `unknown_int()`, which can return any integer value. The variable `t` is not initialized.\n\nThe loop condition is `x > y`. In each iteration of the loop, `x` and `y` are swapped.\n\nThe ranking function (variant) is `(x - y)`.\n\nWe can now output the loop invariants. The loop invariant should be true before the loop starts, during each iteration of the loop, and after the loop has terminated.\n\nLoop invariants:\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= y;\n    loop invariant \\at(y, LoopEntry) <= x;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y >= \\at(y, LoopEntry);\n    loop invariant x >= y;\n*/\n```\nExplanation:\n\n- The first two invariants state that the values of `x` and `y` at the beginning of the loop are at least as large as `y` and at most as large as `x` respectively. This is because the loop condition is `x > y`, so `x` cannot be smaller than `y` and `y` cannot be larger than `x`.\n- The third and fourth invariants state that `x` and `y` do not increase during the loop. This is because in each iteration of the loop, `x` and `y` are swapped. If `x` and `y` do not increase, then the variant `(x - y)` must decrease.\n- The last invariant states that `x` is always larger or equal to `y`. This is because the loop condition is `x > y`, so the loop only continues if `x` is larger than `y`. When the loop terminates, `x` must be equal to `y`.",
                    "Before the loop starts, there are no constraints on the values of `x`, `y`, and `t`. They can be any arbitrary integer values.\n\nIn the loop, if `x` is greater than `y`, `x` and `y` are swapped. This means that after the swap, the new value of `x` is less than or equal to the old value of `y`, and the new value of `y` is equal to the old value of `x`.\n\nThe loop continues as long as `x` is greater than `y`. So, if `x` <= `y`, the loop terminates.\n\nThe loop variant is `x - y`. As the loop progresses, the difference `x - y` decreases. This is because `x` becomes less or equal to `y` after the swap. When `x` <= `y`, the loop terminates, and the loop variant becomes non-positive.\n\nSo, the loop invariants are:\n\n1. `x` is always less than or equal to the value of `y` at the beginning of the loop.\n2. `y` is always equal to the value of `x` at the beginning of the loop.\n3. The loop variant `x - y` is always non-positive after the loop terminates.\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) <= \\at(y, LoopEntry);\n    loop invariant \\at(y, LoopEntry) == \\at(x, LoopEntry);\n    loop invariant x <= y ==> x - y <= 0;\n*/\n```",
                    "The loop condition in the program is `(x > y)`. \n\nThe loop variant is `(x - y)`. \n\nAt the beginning of the loop, the value of `x` and `y` is non-deterministic. \n\nIn each iteration of the loop, `t` is assigned the value of `x`, `x` is assigned the value of `y`, and `y` is assigned the value of `t`. \n\nThe loop invariant that we can identify are:\n1. The value of `x` is always less than or equal to the value of `y` at the loop entry.\n2. The value of `y` always equals the value of `x` at the loop entry in the current iteration.\n3. The value of `x` always equals the value of `y` at the loop entry in the current iteration.\n\nThe loop invariants are:\n```\n/*@ \n    loop invariant x <= \\at(y, LoopEntry);\n    loop invariant y == \\at(x, LoopEntry);\n    loop invariant x == \\at(y, LoopEntry);\n*/\n```",
                    "Before the loop, the variables x and y can take any integer values. They are not bounded. The loop condition is x > y and the ranking function is (x - y).\n\nLet's analyze the loop body. The variable t is used to swap the values of x and y. So, after the swap, the new value of x is less than or equal to the old value of x. This makes the ranking function non-negative and decreasing.\n\nLet's write the loop invariants:\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant x <= y;\n    loop invariant x >= \\at(y, LoopEntry);\n*/\n```",
                    "- The loop condition is `(x > y)`.\n- The variables that are live at the loop head are `x` and `y`.\n- The ranking function is `(x - y)`.\n- The loop invariant `(x - y) >= 0` is true before the loop execution and in every iteration of the loop as x is always greater than y inside the loop.\n- The loop invariant `x <= \\at(x, LoopEntry)` is true in every iteration of the loop and after the loop termination as x is always replaced by the smaller value y in every iteration.\n- The loop invariant `y >= \\at(y, LoopEntry)` is true in every iteration of the loop and after the loop termination as y is always replaced by the larger value x in every iteration.\n\n```\n/*@ \n    loop invariant (x - y) >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y >= \\at(y, LoopEntry);\n*/\n```"
                ],
                "inductive_invariants": "loop invariant i3: x <= \\at(x, LoopEntry);\nloop invariant i4: y >= \\at(y, LoopEntry);\nloop invariant i8: x <= y ==> x - y <= 0;\nloop invariant i12: \\at(x, LoopEntry) >= x;",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int t;\n    x = unknown_int();\n    y = unknown_int();\n    \n    /*@\nloop invariant i3: x <= \\at(x, LoopEntry);\nloop invariant i4: y >= \\at(y, LoopEntry);\nloop invariant i8: x <= y ==> x - y <= 0;\nloop invariant i12: \\at(x, LoopEntry) >= x;\nloop variant x - y;\n*/\nwhile (x > y) {\n        t = x;\n        x = y;\n        y = t;\n    }\n    \n    return 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant x <= \\at(x, LoopEntry) is inductive.\nloop invariant y >= \\at(y, LoopEntry) is inductive.\nloop invariant x <= y ==> x - y <= 0 is inductive.\nloop invariant \\at(x, LoopEntry) >= x is inductive.\n\n\nLoop variant is Valid."
                    }
                ],
                "success": true
            }
        },
        "simple_variant_success": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Benghazi_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DivMinus.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA5.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/McCarthyIterative.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MirrorInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c"
        ],
        "skipped": [],
        "total": 82,
        "success_count": 112,
        "failure_count": 82,
        "success_rate": 1.3658536585365855
    }
}