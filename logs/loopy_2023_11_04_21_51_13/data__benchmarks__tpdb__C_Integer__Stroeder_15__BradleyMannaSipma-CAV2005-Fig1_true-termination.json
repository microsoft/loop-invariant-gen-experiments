{
    "log": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \twhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
        "success": true,
        "simple_variants": [
            [
                "y1 + y2"
            ],
            [
                "y1 > y2 ? y1 - y2 : y2 - y1"
            ],
            [
                "abs(y1 - y2)"
            ],
            [
                "(y1>y2) ? (y1-y2) : (y2-y1)"
            ]
        ],
        "simple_variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \twhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head. We have two variables: `y1` and `y2`. Both are initialized with `unknown_int()` and constrained to be positive integers (`y1 > 0` and `y2 > 0`).\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. The loop continues while `y1` is not equal to `y2`. In each iteration of the loop, either `y1` is decreased by `y2` or `y2` is decreased by `y1`. \n\nLet's consider the ranking function `y1 + y2`. This expression decreases with every iteration of the loop since either `y1` or `y2` is decreased in each iteration. Also, the ranking function will always be positive since both `y1` and `y2` are positive integers.\n\nThus, the ranking function for the loop is `y1 + y2`. In ACSL syntax, this would be:\n\n```\n/*@\n    loop variant y1 + y2;\n*/\n```",
            "1. Starting values or constraints for the variables that are live at the loop head:\n   - y1 > 0\n   - y2 > 0\n\n2. Analyze the loop body:\n   - If y1 > y2, then y1 = y1 - y2\n   - If y1 <= y2, then y2 = y2 - y1\n\n3. Find a ranking function involving the variables in the loop body. The loop continues as long as y1 != y2. We can choose the absolute difference between y1 and y2 as the ranking function.\n\nRanking function:\n```\n/*@\n    loop variant y1 > y2 ? y1 - y2 : y2 - y1;\n*/\n```\n\nThis ranking function is valid because it is always positive while the loop is executing (since y1 != y2), and it decreases with every iteration of the loop. In each iteration, either y1 or y2 is decreased, and the absolute difference between them gets smaller.",
            "1. At the beginning of the loop, we have the condition `y1 != y2` and the constraint `y1 > 0 && y2 > 0`.\n\n2. Inside the loop body, we have two branches:\n   - If `y1 > y2`, then `y1 = y1 - y2`.\n   - If `y1 <= y2`, then `y2 = y2 - y1`.\n\n3. From the loop body, we can observe that the value of either `y1` or `y2` decreases at each iteration. Since both `y1` and `y2` are always positive, their difference will also always be positive.\n\n4. A ranking function that decreases at each iteration and is always positive is the absolute difference between `y1` and `y2`: `abs(y1 - y2)`\n\nNow let's write the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant abs(y1 - y2);\n*/\n```",
            "First, let's note the starting values or constraints for the variables that are live at the loop head.\n\nAt the loop head, both `y1` and `y2` are live variables with the constraint that they are both positive integers (y1 > 0 && y2 > 0).\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body.\n\nThe loop continues executing as long as y1 != y2. Inside the loop, either y1 is decreased by y2 (if y1 > y2) or y2 is decreased by y1 (if y1 < y2). In either case, the difference between y1 and y2 is getting smaller in each iteration.\n\nA suitable ranking function would be the absolute difference between y1 and y2. This value decreases with every iteration and is always positive as long as the loop continues executing.\n\nWe can express this ranking function in ACSL syntax as follows:\n\n```\n/*@\n    loop variant (y1>y2) ? (y1-y2) : (y2-y1);\n*/\n```",
            "First, let's make a note of the starting values or constraints for the variables that are live at the loop head. The variables are `y1` and `y2`.\n\nAt the start of the loop, we have the following constraints:\n- `y1 > 0`\n- `y2 > 0`\n- `y1 != y2`\n\nNow let's analyze the loop body:\n\n```\nwhile (y1 != y2) {\n    if (y1 > y2) {\n        y1 = y1 - y2;\n    } else {\n        y2 = y2 - y1;\n    }\n}\n```\n\nIn every iteration of the loop, either `y1` or `y2` is decreased by the value of the other variable. Since both variables are positive and their values are different, at least one of them will be strictly decreased in each iteration.\n\nWe can now find a ranking function involving the variables in the loop body. Since the difference between `y1` and `y2` always decreases, and they are both positive, the absolute difference between them can be used as a ranking function.\n\nThe ranking function is:\n\n```\n/*@\n    loop variant y1 > y2 ? y1 - y2 : y2 - y1;\n*/\n```\n\nThis is a valid ranking function because it decreases with every iteration of the loop, and it is positive while the loop is executing."
        ],
        "simple_variant_log": {
            "success": true,
            "['y1 + y2']": {
                "variant": [
                    "y1 + y2"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant \\at(y1 + y2, LoopEntry) >= y1 + y2;\n    loop invariant (y1 > y2 ==> \\at(y1, LoopEntry) == y1 + \\at(y2, LoopEntry));\n    loop invariant (y2 >= y1 ==> \\at(y2, LoopEntry) == y2 + \\at(y1, LoopEntry));\n*/",
                    "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant \\at(y1+y2, LoopEntry) >= y1+y2;\n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant y1 >= y2 || y2 >= y1;\n*/",
                    "/*@\n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant \\at(y1 + y2, LoopEntry) >= y1 + y2;\n*/",
                    "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant y1 + y2 >= \\at(y1, LoopEntry) + \\at(y2, LoopEntry);\n    loop invariant y1 + y2 >= y1;\n    loop invariant y1 + y2 >= y2;\n    loop assigns y1, y2;\n    loop variant y1 + y2;\n*/",
                    "/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant \\at(y1, LoopEntry) == y1 || \\at(y1, LoopEntry) > y1;\n    loop invariant \\at(y2, LoopEntry) == y2 || \\at(y2, LoopEntry) > y2;\n    loop invariant \\at(y1, LoopEntry) + \\at(y2, LoopEntry) >= y1 + y2;\n*/"
                ],
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. \nA lexicographic ranking function is a sequence of expressions, where the expressions decrease lexicographically in every iteration of the loop. That is, the first expression decreases, or if it remains the same, the second expression decreases, and so on.\nA multi-phase ranking function is a sequence of expressions, where the expressions decrease in phases. That is, the first expression is positive and decreases initially, once it becomes negative, the second expression becomes positive and decreases, and so on.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \twhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(y1 + y2)**, for the loop in the program above. Let's think step by step."
                    },
                    "- The loop condition is `(y1 != y2)`.\n- The loop variant is `(y1 + y2)`.\n- At the start of the loop, `y1` and `y2` are both greater than 0.\n- In each iteration, either `y1` is decremented by `y2` or `y2` is decremented by `y1`.\n- Therefore, in each iteration, the value of `(y1 + y2)` decreases.\n- After the loop ends, `y1` and `y2` are equal.\n\nThe loop invariants that can be deduced from the above observations are as follows:\n```\n/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant \\at(y1 + y2, LoopEntry) >= y1 + y2;\n    loop invariant (y1 > y2 ==> \\at(y1, LoopEntry) == y1 + \\at(y2, LoopEntry));\n    loop invariant (y2 >= y1 ==> \\at(y2, LoopEntry) == y2 + \\at(y1, LoopEntry));\n*/\n```",
                    "First, we note that the variables live at the loop head are y1 and y2. The loop condition is (y1 != y2). The ranking function is (y1 + y2).\n\nThe loop invariant that is true before the loop execution is that both y1 and y2 are positive.\n\nThe loop invariant that is true in every iteration of the loop is that both y1 and y2 remain positive, and that the value of (y1 + y2) decreases in every iteration.\n\nThe loop invariant that is true after the loop termination is that y1 equals y2.\n\nThe loop invariant that bounds the maximum and minimum values of y1 and y2 is that they both are non-negative, since they start as positive and only decrease.\n\nThe loop invariant that states the relation between y1 and y2 is that one of them is always greater or equal to the other.\n\nNow, we can write the loop invariants:\n```\n/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant \\at(y1+y2, LoopEntry) >= y1+y2;\n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant y1 >= y2 || y2 >= y1;\n*/\n```",
                    "Given the loop condition and the loop body in the program, we can make the following observations:\n\n- The loop condition is **y1 != y2**. This means that the loop terminates when **y1** is equal to **y2**. \n- In the loop body, if **y1 > y2**, then **y1** is decreased by **y2**. Otherwise, **y2** is decreased by **y1**. \n- Therefore, at the beginning of each iteration, the ranking function **(y1 + y2)** is always non-negative and decreases with each iteration. \n- This is because, in each iteration of the loop, either **y1** or **y2** is decreased by the value of the other variable, which is always non-negative. \n- Therefore, the ranking function **(y1 + y2)** is a valid ranking function for this loop.\n\nBased on these observations, we can output the loop invariants as follows:\n\n```\n/*@\n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant \\at(y1 + y2, LoopEntry) >= y1 + y2;\n*/\n```\n\nHere, \n- The first two loop invariants state that **y1** and **y2** are always non-negative.\n- The third loop invariant states that the value of **(y1 + y2)** at the beginning of each loop iteration is greater than or equal to the current value of **(y1 + y2)**, implying that **(y1 + y2)** decreases with every iteration of the loop.",
                    "The variables that are live at the loop head are y1 and y2. The loop condition is (y1 != y2). The given ranking function is (y1 + y2). \n\n- Before the loop execution, y1 and y2 are positive and the sum (y1 + y2) is positive.\n- In every iteration of the loop, if y1 is greater than y2, y1 is reduced by y2 and the sum (y1 + y2) decreases. If y2 is greater than y1, y2 is reduced by y1 and the sum (y1 + y2) decreases.\n- After the loop termination, y1 is equal to y2.\n\nThe loop invariants that can be deduced from the above analysis are:\n- y1 and y2 are positive throughout the loop execution.\n- The sum (y1 + y2) is always positive and decreases in every iteration of the loop.\n- After the loop termination, y1 is equal to y2.\n\nThese can be written as ACSL loop invariants as follows:\n\n```\n/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant y1 + y2 >= \\at(y1, LoopEntry) + \\at(y2, LoopEntry);\n    loop invariant y1 + y2 >= y1;\n    loop invariant y1 + y2 >= y2;\n    loop assigns y1, y2;\n    loop variant y1 + y2;\n*/\n```",
                    "The loop in the program is:\n```\nwhile (y1 != y2) {\n    if (y1 > y2) {\n        y1 = y1 - y2;\n    } else {\n        y2 = y2 - y1;\n    }\n}\n```\nThe loop condition is `y1 != y2`.\n\nThe ranking function for the loop is `(y1 + y2)`.\n\nBefore the loop execution, `y1 > 0` and `y2 > 0`.\n\nIn every iteration of the loop, if `y1 > y2`, then `y1` is updated to `y1 - y2` and `y2` remains the same. If `y1 <= y2`, then `y2` is updated to `y2 - y1` and `y1` remains the same.\n\nAfter the loop termination, `y1 = y2`.\n\nThe loop invariants that support the validity of the ranking function and prove the termination of the loop are:\n```\n/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant \\at(y1, LoopEntry) == y1 || \\at(y1, LoopEntry) > y1;\n    loop invariant \\at(y2, LoopEntry) == y2 || \\at(y2, LoopEntry) > y2;\n    loop invariant \\at(y1, LoopEntry) + \\at(y2, LoopEntry) >= y1 + y2;\n*/\n```"
                ],
                "inductive_invariants": "loop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: \\at(y1 + y2, LoopEntry) >= y1 + y2;\nloop invariant i6: y1 > 0;\nloop invariant i7: y2 > 0;\nloop invariant i8: \\at(y1+y2, LoopEntry) >= y1+y2;\nloop invariant i9: y1 >= y2 || y2 >= y1;\nloop invariant i11: y1 + y2 >= y1;\nloop invariant i12: y1 + y2 >= y2;\nloop invariant i13: \\at(y1, LoopEntry) == y1 || \\at(y1, LoopEntry) > y1;\nloop invariant i14: \\at(y2, LoopEntry) == y2 || \\at(y2, LoopEntry) > y2;\nloop invariant i15: \\at(y1, LoopEntry) + \\at(y2, LoopEntry) >= y1 + y2;",
                "final_variant_candidates": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: \\at(y1 + y2, LoopEntry) >= y1 + y2;\nloop invariant i6: y1 > 0;\nloop invariant i7: y2 > 0;\nloop invariant i8: \\at(y1+y2, LoopEntry) >= y1+y2;\nloop invariant i9: y1 >= y2 || y2 >= y1;\nloop invariant i11: y1 + y2 >= y1;\nloop invariant i12: y1 + y2 >= y2;\nloop invariant i13: \\at(y1, LoopEntry) == y1 || \\at(y1, LoopEntry) > y1;\nloop invariant i14: \\at(y2, LoopEntry) == y2 || \\at(y2, LoopEntry) > y2;\nloop invariant i15: \\at(y1, LoopEntry) + \\at(y2, LoopEntry) >= y1 + y2;\nloop variant y1 + y2;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant y1 >= 0 is inductive.\nloop invariant y2 >= 0 is inductive.\nloop invariant \\at(y1 + y2, LoopEntry) >= y1 + y2 is inductive.\nloop invariant y1 > 0 is inductive.\nloop invariant y2 > 0 is inductive.\nloop invariant \\at(y1+y2, LoopEntry) >= y1+y2 is inductive.\nloop invariant y1 >= y2 || y2 >= y1 is inductive.\nloop invariant y1 + y2 >= y1 is inductive.\nloop invariant y1 + y2 >= y2 is inductive.\nloop invariant \\at(y1, LoopEntry) == y1 || \\at(y1, LoopEntry) > y1 is inductive.\nloop invariant \\at(y2, LoopEntry) == y2 || \\at(y2, LoopEntry) > y2 is inductive.\nloop invariant \\at(y1, LoopEntry) + \\at(y2, LoopEntry) >= y1 + y2 is inductive.\n\n\nLoop variant is Valid."
                    }
                ],
                "success": true
            }
        },
        "simple_variant_success": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Initialization_4_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Benghazi_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Collatz_unknown-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c"
        ],
        "skipped": [],
        "total": 39,
        "success_count": 70,
        "failure_count": 39,
        "success_rate": 1.794871794871795
    }
}