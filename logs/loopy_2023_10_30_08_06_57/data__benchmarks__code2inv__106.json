{
    "logs": {
        "file": "../data/benchmarks/code2inv/106.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    while ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    while ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The variables `a` and `m` are integers.\n- The variable `j` is an integer and is less than 1.\n- The variable `k` is an integer and is initialized to 0.\n- The variable `a` is less than or equal to `m`.\n\nLoop condition:\n- The loop continues as long as the value of `k` is less than 1.\n\nLoop Invariants:\n- Before the loop execution, `m` is greater than or equal to `a`.\n- In every iteration of the loop, either `m` is greater than or equal to `a` or `k` is equal to 1.\n- After the loop termination, `m` is greater than or equal to `a`.\n\nExplanation:\n- Before the loop execution, we know that `a` is less than or equal to `m` and the loop condition is such that it will execute at least once. Therefore, `m` is greater than or equal to `a`.\n- In every iteration of the loop, either `m` is greater than or equal to `a` or `k` is equal to 1. This is because if `m` is less than `a`, then `m` will be set equal to `a`. Otherwise, if `m` is already greater than or equal to `a`, the value of `m` remains unchanged and `k` is incremented by 1. Therefore, the invariant is true for every iteration of the loop.\n- After the loop termination, since the loop condition is such that it will terminate only when `k` is greater than or equal to 1, we know that `m` is greater than or equal to `a`. Therefore, the assertion holds true.\n\nBounds for variables:\n- Since there are no bounds for any of the variables, we do not need to add any conjunctions for bounding maximum and minimum values.\n\nRelations between variables:\n- Since there are no relations between any of the variables, we do not need to add any conjunctions for their relation.\n\nUsing implication:\n- Since the assertion is not guarded by any condition, we do not need to use implication for the invariant.\n- Since there are no non-deterministic variables, we do not need to use implication to make the invariant trivially true at any location.\n\nTherefore, the loop invariants for the given program are:\n```\n/*@ \n    loop invariant m >= a;\n    loop invariant (m >= a) || (k == 1);\n    loop invariant m >= a;\n*/\n```",
            "Pre-conditions:\n- The variables `a` and `m` are integers.\n- The variable `j` is an integer and it is less than `1`.\n- The variable `k` is an integer and it is initialized to `0`.\n- `a` is less than or equal to `m`.\n\nLoop condition:\n- The loop continues while `k` is less than `1`.\n\nPost-condition:\n- `a` is greater than or equal to `m`.\n\nLoop invariants:\n- Before the loop: Since `k` is initially `0` and `k` is always incremented by `1` in each iteration of the loop, we have `k < 1`. Therefore, `m` is greater than or equal to `a` before the loop execution.\n```\n/*@ loop invariant k < 1 ==> a <= m; */\n```\n- In every iteration: If `m` is less than `a`, then `m` is updated to `a`. Otherwise, `m` remains the same. In either case, `m` is greater than or equal to `a`. Therefore, `m` is greater than or equal to `a` in every iteration of the loop.\n```\n/*@ loop invariant a <= m; */\n```\n- After the loop termination: Since the loop condition is `k < 1` and `k` is incremented by `1` in each iteration, `k` is equal to `1` after the loop termination. Therefore, `m` is greater than or equal to `a` after the loop termination.\n```\n/*@ loop invariant k == 1 ==> a <= m; */\n```\n- Combining all loop invariants:\n```\n/*@ \n    loop invariant k < 1 ==> a <= m;\n    loop invariant a <= m;\n    loop invariant k == 1 ==> a <= m;\n*/\n```\n\nNote: There are no maximum or minimum bounds for any variable, and there is no relation between any two variables. Also, since all variables are initialized before the loop, we don't need to use any implication to make the loop invariants trivially true at the beginning of the loop. Similarly, since all variables are assigned valid values after the loop, we don't need to use any implication to make the loop invariants trivially true after the loop termination.",
            "Pre-conditions:\n- Variables `a`, `m`, `j` and `k` are declared but not initialized.\n- `a` is less than or equal to `m`.\n- `j` is less than 1.\n- `k` is initialized to 0.\n\nLoop condition:\n- `k` is less than 1.\n\nPost-condition:\n- `a` is greater than or equal to `m`.\n\nLoop Invariants:\n- Before the loop execution:\n    - `a <= m`\n    - `j < 1`\n    - `k == 0`\n- In every iteration of the loop:\n    - `k >= 0`\n    - `k <= 1`\n    - If `m < a` at the beginning of the iteration, then `m >= a` at the end of the iteration.\n    - If `m >= a` at the beginning of the iteration, then `m >= a` at the end of the iteration.\n- After the loop termination:\n    - `a >= m`\n\nExplanation:\n- Before the loop execution:\n    - `a <= m` is given as a pre-condition.\n    - `j < 1` is given as a pre-condition.\n    - `k == 0` is given as a pre-condition.\n- In every iteration of the loop:\n    - `k >= 0` is true because `k` is initialized to 0 and only incremented by 1 in each iteration.\n    - `k <= 1` is true because the loop condition is `k < 1` and `k` can only be incremented by 1 in each iteration.\n    - If `m < a` at the beginning of the iteration, then `m` is updated to `a` and `m >= a` at the end of the iteration.\n    - If `m >= a` at the beginning of the iteration, then `m >= a` at the end of the iteration because the loop body does not modify `m` in this case.\n- After the loop termination:\n    - The loop condition is `k < 1`, so `k` can only be 0 at the end of the loop. Therefore, `a >= m` because the loop body updates `m` to `a` if `m < a`, but `m` is not modified if `m >= a`.\n\nTherefore, the loop invariants are:\n```\n/*@ \n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k == 0;\n\n    loop invariant k >= 0;\n    loop invariant k <= 1;\n    loop invariant (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry));\n\n    loop assigns k;\n*/\n``` \nNote that we have used `\\at(var, LoopEntry)` to represent the value of a variable `var` at the beginning of the loop iteration. The `loop assigns` clause specifies that the loop only modifies the variable `k`.",
            "Pre-conditions and variable assignments:\n- The variable `a` is assigned but its value is unknown.\n- The variable `m` is assigned but its value is unknown.\n- The variables `j` and `k` are assigned 0.\n\nLoop condition:\n- The loop continues as long as the value of `k` is less than 1.\n\nLoop invariants:\n- Before the loop execution: `a <= m`\n- In every iteration of the loop:\n    - `k >= 0`\n    - If `m < a` holds before the execution of the loop body, then after the execution of the loop body, `m = a`.\n- After the loop termination: `a >= m`\n\nCombining all the loop invariants:\n```\n/*@\n    loop invariant a <= m;\n    loop invariant k >= 0;\n    loop invariant (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a);\n    loop invariant a >= m ==> k >= 1;\n*/\n```\n\nExplanation:\n- Before the loop starts, we know that `a` is less than or equal to `m`.\n- In every iteration of the loop, `k` is incremented by 1, so it is always greater than or equal to 0.\n- If `m` is less than `a` before the execution of the loop body, then `m` is updated to `a` inside the loop body. To express this, we write that if `m >= a` holds before the execution of the loop body, then for every `i` between 0 and `k-1`, `m >= a` continues to hold.\n- After the loop terminates, we know that `a` is greater than or equal to `m`.",
            "Pre-conditions:\n- The variables a, m, j are integers.\n- The variable k is an integer initialized to 0.\n- The macro `assume` is defined, which takes a boolean expression as input, and returns 0 if the expression is false.\n\nLoop Condition:\n- The loop runs while `k < 1`.\n\nLoop Invariants:\n- Before the loop execution, the assertion holds trivially since `k=0`.\n```\n/*@ \n    loop invariant k >= 0;\n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k <= 1;\n    loop invariant (a >= m) ==> (k==1);\n*/\n```\n- In every iteration of the loop, the following holds:\n  - If `m >= a` holds before the loop iteration, then the value of `m` is not changed in this iteration.\n  - If `m < a` holds before the loop iteration, then `m` is updated to the value of `a`.\n  - Since `k` is incremented by 1 in each iteration, it is less than or equal to 1 at any time during the loop.\n```\n/*@ \n    loop invariant k >= 0;\n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k <= 1;\n    loop invariant (a >= m) ==> (k==1);\n    loop invariant (m >= a) ==> (m \\at(loop_entry) >= m);\n    loop invariant (m < a) ==> (m \\at(loop_entry) == a);\n*/\n```\n- After the loop termination, since `k` is equal to 1, `a >= m` holds.\n```\n/*@ \n    loop invariant k >= 0;\n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k <= 1;\n    loop invariant (a >= m) ==> (k==1);\n    loop invariant (m >= a) ==> (m \\at(loop_entry) >= m);\n    loop invariant (m < a) ==> (m \\at(loop_entry) == a);\n    loop invariant k == 1 ==> (a >= m);\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant m >= a;\n    loop invariant (m >= a) || (k == 1);\n    loop invariant m >= a;\n*/",
            "/*@ loop invariant k < 1 ==> a <= m; */",
            "/*@ \n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k == 0;\n\n    loop invariant k >= 0;\n    loop invariant k <= 1;\n    loop invariant (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry));\n\n    loop assigns k;\n*/",
            "/*@\n    loop invariant a <= m;\n    loop invariant k >= 0;\n    loop invariant (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a);\n    loop invariant a >= m ==> k >= 1;\n*/",
            "/*@ \n    loop invariant k >= 0;\n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k <= 1;\n    loop invariant (a >= m) ==> (k==1);\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant m >= a;\n    loop invariant (m >= a) || (k == 1);\n    loop invariant m >= a;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant m >= a is inductive.\nloop invariant (m >= a) || (k == 1) is inductive.\nAssertion a >= m: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: m >= a;\nloop invariant i2: (m >= a) || (k == 1);\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ loop invariant k < 1 ==> a <= m; */",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant k < 1 ==> a <= m is inductive.\nAssertion a >= m: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: k < 1 ==> a <= m;\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k == 0;\n\n    loop invariant k >= 0;\n    loop invariant k <= 1;\n    loop invariant (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry));\n\n    loop assigns k;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant a <= m is partially proven to be inductive.\nloop invariant j < 1 is partially proven to be inductive.\nloop invariant k == 0 is established but not preserved.\nloop invariant k >= 0 is partially proven to be inductive.\nloop invariant k <= 1 is partially proven to be inductive.\nloop invariant (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry)) is partially proven to be inductive.\nAssertion a >= m: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: a <= m;\nloop invariant i2: j < 1;\n\nloop invariant i4: k >= 0;\nloop invariant i5: k <= 1;\nloop invariant i6: (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry));\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@\n    loop invariant a <= m;\n    loop invariant k >= 0;\n    loop invariant (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a);\n    loop invariant a >= m ==> k >= 1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant a <= m is partially proven to be inductive.\nloop invariant k >= 0 is partially proven to be inductive.\nloop invariant (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a) is partially proven to be inductive.\nloop invariant a >= m ==> k >= 1 is preserved but not established.\nAssertion a >= m: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: a <= m;\nloop invariant i2: k >= 0;\nloop invariant i3: (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a);\n\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant k >= 0;\n    loop invariant a <= m;\n    loop invariant j < 1;\n    loop invariant k <= 1;\n    loop invariant (a >= m) ==> (k==1);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant k >= 0 is partially proven to be inductive.\nloop invariant a <= m is partially proven to be inductive.\nloop invariant j < 1 is partially proven to be inductive.\nloop invariant k <= 1 is partially proven to be inductive.\nloop invariant (a >= m) ==> (k==1) is preserved but not established.\nAssertion a >= m: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: k >= 0;\nloop invariant i2: a <= m;\nloop invariant i3: j < 1;\nloop invariant i4: k <= 1;\n\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant m >= a is partially proven to be inductive.\nloop invariant (m >= a) || (k == 1) is partially proven to be inductive.\nloop invariant k < 1 ==> a <= m is partially proven to be inductive.\nloop invariant a <= m is partially proven to be inductive.\nloop invariant j < 1 is partially proven to be inductive.\nloop invariant k == 0 is established but not preserved.\nloop invariant k >= 0 is partially proven to be inductive.\nloop invariant k <= 1 is partially proven to be inductive.\nloop invariant (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry)) is partially proven to be inductive.\nloop invariant (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a) is partially proven to be inductive.\nloop invariant a >= m ==> k >= 1 is preserved but not established.\nloop invariant (a >= m) ==> (k==1) is partially proven to be inductive.\nAssertion a >= m: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: m >= a;\nloop invariant i2: (m >= a) || (k == 1);\nloop invariant i3: k < 1 ==> a <= m;\nloop invariant i4: a <= m;\nloop invariant i5: j < 1;\nloop invariant i6: k == 0;\nloop invariant i7: k >= 0;\nloop invariant i8: k <= 1;\nloop invariant i9: (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry));\nloop invariant i10: (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a);\nloop invariant i11: a >= m ==> k >= 1;\nloop invariant i12: (a >= m) ==> (k==1);\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
        "combined_annotation_num_solver_calls": 4,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int a,m,j,k;\n\n    assume(a <= m);\n    assume(j < 1);\n    k = 0;\n\n    /*@\nloop invariant i1: m >= a;\nloop invariant i2: (m >= a) || (k == 1);\nloop invariant i3: k < 1 ==> a <= m;\nloop invariant i4: a <= m;\nloop invariant i5: j < 1;\n\nloop invariant i7: k >= 0;\nloop invariant i8: k <= 1;\nloop invariant i9: (m < a ==> m >= \\at(a, LoopEntry)) && (m >= a ==> m >= \\at(m, LoopEntry));\nloop invariant i10: (m >= a ==> \\forall integer i; 0 <= i < k ==> m >= a);\n\n\n*/\nwhile ( k < 1) {\n        if(m < a) {\n            m = a;\n        }\n        k = k + 1;\n    }\n\n    {;\n//@ assert( a >= m);\n}\n\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/code2inv/1.c",
            "../data/benchmarks/code2inv/2.c",
            "../data/benchmarks/code2inv/3.c",
            "../data/benchmarks/code2inv/4.c",
            "../data/benchmarks/code2inv/5.c",
            "../data/benchmarks/code2inv/8.c",
            "../data/benchmarks/code2inv/10.c",
            "../data/benchmarks/code2inv/12.c",
            "../data/benchmarks/code2inv/15.c",
            "../data/benchmarks/code2inv/17.c",
            "../data/benchmarks/code2inv/20.c",
            "../data/benchmarks/code2inv/22.c",
            "../data/benchmarks/code2inv/25.c",
            "../data/benchmarks/code2inv/30.c",
            "../data/benchmarks/code2inv/34.c",
            "../data/benchmarks/code2inv/35.c",
            "../data/benchmarks/code2inv/36.c",
            "../data/benchmarks/code2inv/38.c",
            "../data/benchmarks/code2inv/40.c",
            "../data/benchmarks/code2inv/42.c",
            "../data/benchmarks/code2inv/43.c",
            "../data/benchmarks/code2inv/44.c",
            "../data/benchmarks/code2inv/45.c",
            "../data/benchmarks/code2inv/46.c",
            "../data/benchmarks/code2inv/47.c",
            "../data/benchmarks/code2inv/48.c",
            "../data/benchmarks/code2inv/50.c",
            "../data/benchmarks/code2inv/51.c",
            "../data/benchmarks/code2inv/52.c",
            "../data/benchmarks/code2inv/54.c",
            "../data/benchmarks/code2inv/55.c",
            "../data/benchmarks/code2inv/56.c",
            "../data/benchmarks/code2inv/57.c",
            "../data/benchmarks/code2inv/58.c",
            "../data/benchmarks/code2inv/63.c",
            "../data/benchmarks/code2inv/64.c",
            "../data/benchmarks/code2inv/66.c",
            "../data/benchmarks/code2inv/69.c",
            "../data/benchmarks/code2inv/71.c",
            "../data/benchmarks/code2inv/74.c",
            "../data/benchmarks/code2inv/76.c",
            "../data/benchmarks/code2inv/77.c",
            "../data/benchmarks/code2inv/78.c",
            "../data/benchmarks/code2inv/79.c",
            "../data/benchmarks/code2inv/80.c",
            "../data/benchmarks/code2inv/81.c",
            "../data/benchmarks/code2inv/82.c",
            "../data/benchmarks/code2inv/83.c",
            "../data/benchmarks/code2inv/85.c",
            "../data/benchmarks/code2inv/86.c",
            "../data/benchmarks/code2inv/87.c",
            "../data/benchmarks/code2inv/88.c",
            "../data/benchmarks/code2inv/89.c",
            "../data/benchmarks/code2inv/91.c",
            "../data/benchmarks/code2inv/92.c",
            "../data/benchmarks/code2inv/94.c",
            "../data/benchmarks/code2inv/95.c",
            "../data/benchmarks/code2inv/96.c",
            "../data/benchmarks/code2inv/97.c",
            "../data/benchmarks/code2inv/102.c",
            "../data/benchmarks/code2inv/103.c",
            "../data/benchmarks/code2inv/105.c"
        ],
        "failure": [
            "../data/benchmarks/code2inv/7.c",
            "../data/benchmarks/code2inv/9.c",
            "../data/benchmarks/code2inv/11.c",
            "../data/benchmarks/code2inv/13.c",
            "../data/benchmarks/code2inv/14.c",
            "../data/benchmarks/code2inv/19.c",
            "../data/benchmarks/code2inv/21.c",
            "../data/benchmarks/code2inv/23.c",
            "../data/benchmarks/code2inv/24.c",
            "../data/benchmarks/code2inv/26.c",
            "../data/benchmarks/code2inv/27.c",
            "../data/benchmarks/code2inv/29.c",
            "../data/benchmarks/code2inv/31.c",
            "../data/benchmarks/code2inv/32.c",
            "../data/benchmarks/code2inv/33.c",
            "../data/benchmarks/code2inv/41.c",
            "../data/benchmarks/code2inv/59.c",
            "../data/benchmarks/code2inv/60.c",
            "../data/benchmarks/code2inv/61.c",
            "../data/benchmarks/code2inv/62.c",
            "../data/benchmarks/code2inv/65.c",
            "../data/benchmarks/code2inv/67.c",
            "../data/benchmarks/code2inv/68.c",
            "../data/benchmarks/code2inv/70.c",
            "../data/benchmarks/code2inv/72.c",
            "../data/benchmarks/code2inv/75.c",
            "../data/benchmarks/code2inv/84.c",
            "../data/benchmarks/code2inv/101.c",
            "../data/benchmarks/code2inv/104.c",
            "../data/benchmarks/code2inv/106.c"
        ],
        "skipped": [
            "../data/benchmarks/code2inv/6.c",
            "../data/benchmarks/code2inv/16.c",
            "../data/benchmarks/code2inv/18.c",
            "../data/benchmarks/code2inv/28.c",
            "../data/benchmarks/code2inv/37.c",
            "../data/benchmarks/code2inv/39.c",
            "../data/benchmarks/code2inv/49.c",
            "../data/benchmarks/code2inv/53.c",
            "../data/benchmarks/code2inv/73.c",
            "../data/benchmarks/code2inv/90.c",
            "../data/benchmarks/code2inv/93.c",
            "../data/benchmarks/code2inv/98.c",
            "../data/benchmarks/code2inv/99.c",
            "../data/benchmarks/code2inv/100.c"
        ],
        "total": 92,
        "success_count": 62,
        "failure_count": 30,
        "success_rate": 0.6739130434782609
    }
}