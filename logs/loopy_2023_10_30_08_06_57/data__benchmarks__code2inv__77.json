{
    "logs": {
        "file": "../data/benchmarks/code2inv/77.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint main() {\n  \n  int i;\n  int x;\n  int y;\n  \n  (i = 0);\n  assume((x >= 0));\n  assume((y >= 0));\n  assume((x >= y));\n  \n  while (unknown()) {\n    if ( (i < y) )\n    {\n    (i  = (i + 1));\n    }\n\n  }\n  \nif ( (i < y) )\n{;\n//@ assert( (i < x) );\n}\n\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint main() {\n  \n  int i;\n  int x;\n  int y;\n  \n  (i = 0);\n  assume((x >= 0));\n  assume((y >= 0));\n  assume((x >= y));\n  \n  while (unknown()) {\n    if ( (i < y) )\n    {\n    (i  = (i + 1));\n    }\n\n  }\n  \nif ( (i < y) )\n{;\n//@ assert( (i < x) );\n}\n\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- `x` is an integer variable and its value is greater than or equal to 0.\n- `y` is an integer variable and its value is greater than or equal to 0.\n- `x` is greater than or equal to `y`.\n\nLoop condition:\n- `unknown()` returns a non-zero integer value.\n\nPost-condition:\n- If the loop terminates, then `i` is less than `y`. \n\nLoop invariants:\n- Before the loop execution:\n  - `i` is equal to 0.\n  - `x` is greater than or equal to 0.\n  - `y` is greater than or equal to 0.\n  - `x` is greater than or equal to `y`.\n\n- In every iteration of the loop:\n  - `i` is less than or equal to `y`.\n  - `i` is greater than or equal to 0.\n\n- After the loop termination:\n  - Either the loop condition is false, or `i` is greater than or equal to `y`.\n  - If `i` is less than `y`, then `i` is less than `x`.\n\nAll these loop invariants can be expressed in ACSL as follows:\n```\n/*@ \n  loop invariant i >= 0 && i <= y;\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x >= y;\n  \n  loop invariant (unknown() && i < y) ==> (i + 1) >= 0 && (i + 1) <= y;\n  loop invariant !(unknown()) ==> (i >= y);\n  \n  loop variant (y - i); \n*/\n``` \nIn the loop invariants above, the first four invariants are the pre-conditions. The next two invariants are for the loop body. The first of these invariants is true in every iteration of the loop, and it ensures that the value of `i` is within the range of 0 to `y`. The second invariant is true after the loop termination, and it ensures that if the loop condition is false, then the value of `i` is greater than or equal to `y`.\n\nThe last loop invariant is the loop variant, which ensures that the loop makes progress towards termination. The loop variant is an expression that decreases in value in every iteration of the loop until it reaches a lower bound, at which point the loop terminates. In this case, the loop variant is `y - i`. Since `i` can increase by at most 1 in every iteration and `y` is constant, the loop variant decreases by at least 1 in every iteration. Therefore, the loop variant is a decreasing expression.",
            "Pre-conditions:\n- The variable `i` is initialized to 0.\n- The variables `x` and `y` are non-negative integers such that `x >= y`.\n\nLoop condition:\n- The loop will run as long as the function `unknown()` returns a non-zero value.\n\nPost-condition:\n- If the loop terminates, then `i < x`.\n\nLoop invariants:\n- Before the loop: `i >= 0`, `x >= 0`, `y >= 0`, `x >= y`.\n- In every iteration of the loop: \n    - `i >= 0`, `x >= 0`, `y >= 0`, `x >= y`.\n    - If `i < y`, then `i+1 <= y`.\n- After the loop:\n    - If `i >= y`, then `i >= x`.\n    - If `i < y`, then `i < x`.\n\nExplanation:\n- Before the loop, we have to ensure that the variables `i`, `x`, and `y` are non-negative integers and `x >= y`.\n- In every iteration of the loop, the variables `i`, `x`, and `y` do not change. Therefore, we can reuse the invariants from before the loop.\n- Inside the loop, if `i < y`, then we increment `i` by 1. Therefore, we need to ensure that `i+1 <= y`. This ensures that `i` does not exceed `y`.\n- After the loop, if `i >= y`, then `i` is greater than or equal to `y`, which means that it is also greater than or equal to `x` since `x >= y`. If `i < y`, then `i` is less than `y`, which means that it is less than `x` since `x >= y`. Therefore, we get the two conditions: `i >= x` when `i >= y` and `i < x` when `i < y`.",
            "Pre-conditions and variable assignments:\n- The variable `i` is initialized to 0.\n- The variables `x` and `y` are assumed to be non-negative, and `x` is assumed to be greater than or equal to `y`.\n\nLoop condition:\n- The loop continues as long as the result of the function `unknown()` is non-zero. Since the function `unknown()` is non-deterministic, we cannot make any assumptions about the number of loop iterations or the values of variables at the end of the loop.\n\nLoop Invariants:\n- Since we do not have any information about the number of loop iterations, we cannot use the loop counter `i` as a loop invariant.\n\n- The variable `x` is assumed to be greater than or equal to `y`. Therefore, we can use the following loop invariant:\n```\n/*@ loop invariant x >= y; */\n```\n\n- Within the loop, if `i` is less than `y`, then `i` is incremented by 1. Therefore, we can use the following loop invariant:\n```\n/*@ loop invariant i >= 0 && i <= y; */\n```\n\n- The assertion `i < x` is guarded by the condition `i < y`. Therefore, we need to use an implication to make the assertion true at the end of the loop:\n```\n/*@ loop invariant i < y ==> i < x; */\n```\n\n- We do not have any information about the values of `x` and `y` at the end of the loop. Therefore, we need to use an implication to make the loop invariant trivially true at the end of the loop:\n```\n/*@ loop invariant !unknown() ==> (x >= y && i >= 0 && i <= y && (i < y ==> i < x)); */\n```\n\nPutting everything together, we get the following loop invariants:\n```\n/*@ \n    loop invariant x >= y;\n    loop invariant i >= 0 && i <= y;\n    loop invariant i < y ==> i < x;\n    loop invariant !unknown() ==> (x >= y && i >= 0 && i <= y && (i < y ==> i < x));\n*/\n```",
            "Pre-conditions:\n\n- The variable `i` is initialized to `0`.\n- The variables `x` and `y` are non-negative and `x >= y`.\n\nLoop condition:\n- The loop executes as long as the result of the call to `unknown()` is non-zero.\n\nLoop invariants:\n\n- Before the loop execution: \n\n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - If the loop is entered, `i` is less than or equal to `y`. `(i <= y)`\n    \n- In every iteration of the loop:\n\n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - If the loop is entered, `i` is less than or equal to `y`. `(i <= y)`\n    - If `i` is less than `y`, then `i` is incremented by `1`. `(i < y) ==> (i' == i + 1)`\n    \n- After the loop termination:\n    \n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - Either the loop was never entered, in which case the post-condition trivially holds, or if the loop was entered, then `i` is greater than or equal to `y` and less than `x`. `(i >= y) && (i < x)`\n    - If `i` is less than `y`, then the loop was never entered and the post-condition trivially holds. If `i` is greater than or equal to `y`, then `i` is less than `x`. Therefore, `(i < y) ==> (i < x)` is always true. So the post-condition holds. `(i < y) ==> (i < x)`",
            "Pre-conditions:\n- `x` and `y` are non-negative integers.\n- `x >= y`\n- `i` is initialized to 0.\n\nLoop condition:\n- `unknown()` returns a non-zero value.\n\nPost-condition:\n- `i < x` if `i < y` at the end of the loop.\n\nLoop invariants:\n- `0 <= i`\n- `0 <= x`\n- `0 <= y`\n- `i <= y`\n- `i <= x`\n- `x >= y`\n\nExplanation:\n- `0 <= i` is true before the loop execution, and it remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `0 <= x` and `0 <= y` are true before the loop execution, and they remain true in every iteration, since there are no assignments to `x` or `y` in the loop body.\n- `i <= y` is true before the loop execution, since `i` is initialized to 0 and `y` is non-negative. It remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `i <= x` is true before the loop execution, since `i` is initialized to 0 and `x` is non-negative. It remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `x >= y` is true before the loop execution, and it remains true in every iteration, since there are no assignments to `x` or `y` in the loop body.\n- `i < y ==> i < x` is true after the loop termination, since the assertion is guarded by `i < y` and `i <= x` holds as an invariant. Therefore, `i < y` implies `i < x`."
        ],
        "annotation_blocks": [
            "/*@ \n  loop invariant i >= 0 && i <= y;\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x >= y;\n  \n  loop invariant (unknown() && i < y) ==> (i + 1) >= 0 && (i + 1) <= y;\n  loop invariant !(unknown()) ==> (i >= y);\n  \n  loop variant (y - i); \n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The variable `i` is initialized to 0.\n- The variables `x` and `y` are non-negative integers such that `x >= y`.\n\nLoop condition:\n- The loop will run as long as the function `unknown()` returns a non-zero value.\n\nPost-condition:\n- If the loop terminates, then `i < x`.\n\nLoop invariants:\n- Before the loop: `i >= 0`, `x >= 0`, `y >= 0`, `x >= y`.\n- In every iteration of the loop: \n    - `i >= 0`, `x >= 0`, `y >= 0`, `x >= y`.\n    - If `i < y`, then `i+1 <= y`.\n- After the loop:\n    - If `i >= y`, then `i >= x`.\n    - If `i < y`, then `i < x`.\n\nExplanation:\n- Before the loop, we have to ensure that the variables `i`, `x`, and `y` are non-negative integers and `x >= y`.\n- In every iteration of the loop, the variables `i`, `x`, and `y` do not change. Therefore, we can reuse the invariants from before the loop.\n- Inside the loop, if `i < y`, then we increment `i` by 1. Therefore, we need to ensure that `i+1 <= y`. This ensures that `i` does not exceed `y`.\n- After the loop, if `i >= y`, then `i` is greater than or equal to `y`, which means that it is also greater than or equal to `x` since `x >= y`. If `i < y`, then `i` is less than `y`, which means that it is less than `x` since `x >= y`. Therefore, we get the two conditions: `i >= x` when `i >= y` and `i < x` when `i < y`."
            ],
            "/*@ loop invariant x >= y; */",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n\n- The variable `i` is initialized to `0`.\n- The variables `x` and `y` are non-negative and `x >= y`.\n\nLoop condition:\n- The loop executes as long as the result of the call to `unknown()` is non-zero.\n\nLoop invariants:\n\n- Before the loop execution: \n\n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - If the loop is entered, `i` is less than or equal to `y`. `(i <= y)`\n    \n- In every iteration of the loop:\n\n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - If the loop is entered, `i` is less than or equal to `y`. `(i <= y)`\n    - If `i` is less than `y`, then `i` is incremented by `1`. `(i < y) ==> (i' == i + 1)`\n    \n- After the loop termination:\n    \n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - Either the loop was never entered, in which case the post-condition trivially holds, or if the loop was entered, then `i` is greater than or equal to `y` and less than `x`. `(i >= y) && (i < x)`\n    - If `i` is less than `y`, then the loop was never entered and the post-condition trivially holds. If `i` is greater than or equal to `y`, then `i` is less than `x`. Therefore, `(i < y) ==> (i < x)` is always true. So the post-condition holds. `(i < y) ==> (i < x)`"
            ],
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- `x` and `y` are non-negative integers.\n- `x >= y`\n- `i` is initialized to 0.\n\nLoop condition:\n- `unknown()` returns a non-zero value.\n\nPost-condition:\n- `i < x` if `i < y` at the end of the loop.\n\nLoop invariants:\n- `0 <= i`\n- `0 <= x`\n- `0 <= y`\n- `i <= y`\n- `i <= x`\n- `x >= y`\n\nExplanation:\n- `0 <= i` is true before the loop execution, and it remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `0 <= x` and `0 <= y` are true before the loop execution, and they remain true in every iteration, since there are no assignments to `x` or `y` in the loop body.\n- `i <= y` is true before the loop execution, since `i` is initialized to 0 and `y` is non-negative. It remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `i <= x` is true before the loop execution, since `i` is initialized to 0 and `x` is non-negative. It remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `x >= y` is true before the loop execution, and it remains true in every iteration, since there are no assignments to `x` or `y` in the loop body.\n- `i < y ==> i < x` is true after the loop termination, since the assertion is guarded by `i < y` and `i <= x` holds as an invariant. Therefore, `i < y` implies `i < x`."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n  loop invariant i >= 0 && i <= y;\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x >= y;\n  \n  loop invariant (unknown() && i < y) ==> (i + 1) >= 0 && (i + 1) <= y;\n  loop invariant !(unknown()) ==> (i >= y);\n  \n  loop variant (y - i); \n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 20: unexpected token ')'",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint main() {\n  \n  int i;\n  int x;\n  int y;\n  \n  (i = 0);\n  assume((x >= 0));\n  assume((y >= 0));\n  assume((x >= y));\n  \n  /*@\nloop invariant i1: i >= 0 && i <= y;\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x >= y;\n\n\n*/\nwhile (unknown()) {\n    if ( (i < y) )\n    {\n    (i  = (i + 1));\n    }\n\n  }\n  \nif ( (i < y) )\n{;\n//@ assert( (i < x) );\n}\n\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The variable `i` is initialized to 0.\n- The variables `x` and `y` are non-negative integers such that `x >= y`.\n\nLoop condition:\n- The loop will run as long as the function `unknown()` returns a non-zero value.\n\nPost-condition:\n- If the loop terminates, then `i < x`.\n\nLoop invariants:\n- Before the loop: `i >= 0`, `x >= 0`, `y >= 0`, `x >= y`.\n- In every iteration of the loop: \n    - `i >= 0`, `x >= 0`, `y >= 0`, `x >= y`.\n    - If `i < y`, then `i+1 <= y`.\n- After the loop:\n    - If `i >= y`, then `i >= x`.\n    - If `i < y`, then `i < x`.\n\nExplanation:\n- Before the loop, we have to ensure that the variables `i`, `x`, and `y` are non-negative integers and `x >= y`.\n- In every iteration of the loop, the variables `i`, `x`, and `y` do not change. Therefore, we can reuse the invariants from before the loop.\n- Inside the loop, if `i < y`, then we increment `i` by 1. Therefore, we need to ensure that `i+1 <= y`. This ensures that `i` does not exceed `y`.\n- After the loop, if `i >= y`, then `i` is greater than or equal to `y`, which means that it is also greater than or equal to `x` since `x >= y`. If `i < y`, then `i` is less than `y`, which means that it is less than `x` since `x >= y`. Therefore, we get the two conditions: `i >= x` when `i >= y` and `i < x` when `i < y`.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ loop invariant x >= y; */",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant x >= y is inductive.\nAssertion i < x: Valid"
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n\n- The variable `i` is initialized to `0`.\n- The variables `x` and `y` are non-negative and `x >= y`.\n\nLoop condition:\n- The loop executes as long as the result of the call to `unknown()` is non-zero.\n\nLoop invariants:\n\n- Before the loop execution: \n\n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - If the loop is entered, `i` is less than or equal to `y`. `(i <= y)`\n    \n- In every iteration of the loop:\n\n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - If the loop is entered, `i` is less than or equal to `y`. `(i <= y)`\n    - If `i` is less than `y`, then `i` is incremented by `1`. `(i < y) ==> (i' == i + 1)`\n    \n- After the loop termination:\n    \n    - `i` is non-negative. `(i >= 0)`\n    - `x` and `y` are non-negative and `x >= y`. `(x >= 0) && (y >= 0) && (x >= y)`\n    - Either the loop was never entered, in which case the post-condition trivially holds, or if the loop was entered, then `i` is greater than or equal to `y` and less than `x`. `(i >= y) && (i < x)`\n    - If `i` is less than `y`, then the loop was never entered and the post-condition trivially holds. If `i` is greater than or equal to `y`, then `i` is less than `x`. Therefore, `(i < y) ==> (i < x)` is always true. So the post-condition holds. `(i < y) ==> (i < x)`",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- `x` and `y` are non-negative integers.\n- `x >= y`\n- `i` is initialized to 0.\n\nLoop condition:\n- `unknown()` returns a non-zero value.\n\nPost-condition:\n- `i < x` if `i < y` at the end of the loop.\n\nLoop invariants:\n- `0 <= i`\n- `0 <= x`\n- `0 <= y`\n- `i <= y`\n- `i <= x`\n- `x >= y`\n\nExplanation:\n- `0 <= i` is true before the loop execution, and it remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `0 <= x` and `0 <= y` are true before the loop execution, and they remain true in every iteration, since there are no assignments to `x` or `y` in the loop body.\n- `i <= y` is true before the loop execution, since `i` is initialized to 0 and `y` is non-negative. It remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `i <= x` is true before the loop execution, since `i` is initialized to 0 and `x` is non-negative. It remains true in every iteration, since `i` is incremented by 1 or remains the same in each iteration.\n- `x >= y` is true before the loop execution, and it remains true in every iteration, since there are no assignments to `x` or `y` in the loop body.\n- `i < y ==> i < x` is true after the loop termination, since the assertion is guarded by `i < y` and `i <= x` holds as an invariant. Therefore, `i < y` implies `i < x`.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 20: unexpected token ')'",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint main() {\n  \n  int i;\n  int x;\n  int y;\n  \n  (i = 0);\n  assume((x >= 0));\n  assume((y >= 0));\n  assume((x >= y));\n  \n  /*@\nloop invariant i1: i >= 0 && i <= y;\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x >= y;\nloop invariant i5: (unknown() && i < y) ==> (i + 1) >= 0 && (i + 1) <= y;\nloop invariant i6: !(unknown()) ==> (i >= y);\n*/\nwhile (unknown()) {\n    if ( (i < y) )\n    {\n    (i  = (i + 1));\n    }\n\n  }\n  \nif ( (i < y) )\n{;\n//@ assert( (i < x) );\n}\n\n}",
        "combined_annotation_num_solver_calls": 3,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint main() {\n  \n  int i;\n  int x;\n  int y;\n  \n  (i = 0);\n  assume((x >= 0));\n  assume((y >= 0));\n  assume((x >= y));\n  \n  /*@\nloop invariant i1: i >= 0 && i <= y;\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x >= y;\n\n\n*/\nwhile (unknown()) {\n    if ( (i < y) )\n    {\n    (i  = (i + 1));\n    }\n\n  }\n  \nif ( (i < y) )\n{;\n//@ assert( (i < x) );\n}\n\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/code2inv/1.c",
            "../data/benchmarks/code2inv/2.c",
            "../data/benchmarks/code2inv/3.c",
            "../data/benchmarks/code2inv/4.c",
            "../data/benchmarks/code2inv/5.c",
            "../data/benchmarks/code2inv/8.c",
            "../data/benchmarks/code2inv/10.c",
            "../data/benchmarks/code2inv/12.c",
            "../data/benchmarks/code2inv/15.c",
            "../data/benchmarks/code2inv/17.c",
            "../data/benchmarks/code2inv/20.c",
            "../data/benchmarks/code2inv/22.c",
            "../data/benchmarks/code2inv/25.c",
            "../data/benchmarks/code2inv/30.c",
            "../data/benchmarks/code2inv/34.c",
            "../data/benchmarks/code2inv/35.c",
            "../data/benchmarks/code2inv/36.c",
            "../data/benchmarks/code2inv/38.c",
            "../data/benchmarks/code2inv/40.c",
            "../data/benchmarks/code2inv/42.c",
            "../data/benchmarks/code2inv/43.c",
            "../data/benchmarks/code2inv/44.c",
            "../data/benchmarks/code2inv/45.c",
            "../data/benchmarks/code2inv/46.c",
            "../data/benchmarks/code2inv/47.c",
            "../data/benchmarks/code2inv/48.c",
            "../data/benchmarks/code2inv/50.c",
            "../data/benchmarks/code2inv/51.c",
            "../data/benchmarks/code2inv/52.c",
            "../data/benchmarks/code2inv/54.c",
            "../data/benchmarks/code2inv/55.c",
            "../data/benchmarks/code2inv/56.c",
            "../data/benchmarks/code2inv/57.c",
            "../data/benchmarks/code2inv/58.c",
            "../data/benchmarks/code2inv/63.c",
            "../data/benchmarks/code2inv/64.c",
            "../data/benchmarks/code2inv/66.c",
            "../data/benchmarks/code2inv/69.c",
            "../data/benchmarks/code2inv/71.c",
            "../data/benchmarks/code2inv/74.c",
            "../data/benchmarks/code2inv/76.c",
            "../data/benchmarks/code2inv/77.c"
        ],
        "failure": [
            "../data/benchmarks/code2inv/7.c",
            "../data/benchmarks/code2inv/9.c",
            "../data/benchmarks/code2inv/11.c",
            "../data/benchmarks/code2inv/13.c",
            "../data/benchmarks/code2inv/14.c",
            "../data/benchmarks/code2inv/19.c",
            "../data/benchmarks/code2inv/21.c",
            "../data/benchmarks/code2inv/23.c",
            "../data/benchmarks/code2inv/24.c",
            "../data/benchmarks/code2inv/26.c",
            "../data/benchmarks/code2inv/27.c",
            "../data/benchmarks/code2inv/29.c",
            "../data/benchmarks/code2inv/31.c",
            "../data/benchmarks/code2inv/32.c",
            "../data/benchmarks/code2inv/33.c",
            "../data/benchmarks/code2inv/41.c",
            "../data/benchmarks/code2inv/59.c",
            "../data/benchmarks/code2inv/60.c",
            "../data/benchmarks/code2inv/61.c",
            "../data/benchmarks/code2inv/62.c",
            "../data/benchmarks/code2inv/65.c",
            "../data/benchmarks/code2inv/67.c",
            "../data/benchmarks/code2inv/68.c",
            "../data/benchmarks/code2inv/70.c",
            "../data/benchmarks/code2inv/72.c",
            "../data/benchmarks/code2inv/75.c"
        ],
        "skipped": [
            "../data/benchmarks/code2inv/6.c",
            "../data/benchmarks/code2inv/16.c",
            "../data/benchmarks/code2inv/18.c",
            "../data/benchmarks/code2inv/28.c",
            "../data/benchmarks/code2inv/37.c",
            "../data/benchmarks/code2inv/39.c",
            "../data/benchmarks/code2inv/49.c",
            "../data/benchmarks/code2inv/53.c",
            "../data/benchmarks/code2inv/73.c"
        ],
        "total": 68,
        "success_count": 42,
        "failure_count": 26,
        "success_rate": 0.6176470588235294
    }
}