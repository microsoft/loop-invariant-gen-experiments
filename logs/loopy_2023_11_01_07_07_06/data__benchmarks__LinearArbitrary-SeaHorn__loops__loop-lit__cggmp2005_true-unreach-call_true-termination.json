{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    while (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    while (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions and variable assignments:\n- The program defines a macro `assume(e)` which returns 0 if the condition `e` is false.\n- The program declares two integer variables `i` and `j`.\n- The program assigns values 1 and 10 to `i` and `j` respectively.\n- There is an assertion at the end of the program which asserts that `j` is equal to 6.\n\nLoop analysis:\n- The loop condition is `j >= i`.\n- The loop modifies the values of `i` and `j` in each iteration.\n\nLoop invariants:\n- Since `i` is initially 1 and `j` is initially 10, we can add the following loop invariant before the loop execution:\n```\n/*@ loop invariant 1 <= i <= 11;\n    loop invariant 6 <= j <= 10;\n*/\n```\n- In each iteration of the loop, `i` increases by 2 and `j` decreases by 1. Therefore, we can add the following loop invariant:\n```\n/*@ loop invariant (j - i) % 2 == 0;\n*/\n```\n- Since the loop terminates when `j` becomes less than `i`, we can add the following loop invariant after the loop termination:\n```\n/*@ loop invariant j < i ==> j == 5;\n    loop invariant j >= i ==> j == 6;\n*/\n```\n- Finally, since the assertion is not guarded by any condition, we can add the following loop invariant after the assertion:\n```\n/*@ loop invariant j == 6;\n*/\n``` \n\nPutting all the loop invariants together, we get:\n```\n/*@ loop invariant 1 <= i <= 11;\n    loop invariant 6 <= j <= 10;\n    loop invariant (j - i) % 2 == 0;\n    loop invariant j < i ==> j == 5;\n    loop invariant j >= i ==> j == 6;\n*/\n```",
            "Pre-conditions:\n- None\n\nVariable assignments:\n- i is assigned the value 1\n- j is assigned the value 10\n\nLoop condition:\n- j >= i\n\nLoop invariants:\n- i is odd\n- j is even\n- j-i is always equal to 9\n- j >= 5 ==> j-i >= 5\n- i <= 10\n- j >= 0\n\nExplanation:\n- Before the loop execution, i is odd and j is even because i is assigned 1 and j is assigned 10. \n- In every iteration of the loop, i is incremented by 2 and j is decremented by 1. Therefore, i remains odd and j remains even.\n- The difference between j and i is always 9 because i is incremented by 2 and j is decremented by 1 in each iteration.\n- j is greater than or equal to 5 implies that j-i is greater than or equal to 5 because the difference between j and i is always 9.\n- i is less than or equal to 10 because i starts from 1 and is incremented by 2 in each iteration. Therefore, i can take a maximum value of 1 + 2*(n-1) where n is the number of iterations of the loop. Since j is decremented by 1 in each iteration, the maximum number of iterations of the loop is 10.\n- j is greater than or equal to 0 because j starts from 10 and is decremented by 1 in each iteration. Therefore, j can take a minimum value of 10 - n where n is the number of iterations of the loop.\n- The assertion is not guarded by any condition. Therefore, we don't need to use an implication for the assertion.\n\nPutting everything together, the loop invariants are:\n```\n/*@ \n    loop invariant i%2 == 1;\n    loop invariant j%2 == 0;\n    loop invariant j-i == 9;\n    loop invariant j >= 5 ==> j-i >= 5;\n    loop invariant i <= 10;\n    loop invariant j >= 0;\n*/\n```",
            "Pre-conditions: None\n\nVariable assignments:\n- i = 1;\n- j = 10;\n\nLoop condition: j >= i\n\nPost-condition: j == 6\n\nSince we know that the loop will execute as long as j >= i, we can use this as the loop invariant:\n\n/*@ \n    loop invariant j >= i;\n*/\n\nNext, let's analyze the loop body. The loop body contains two assignments:\n- i = i + 2;\n- j = -1 + j;\n\nWe can use the loop invariant and the loop body to deduce more loop invariants. We can see that in every iteration of the loop, i increases by 2 and j decreases by 1. Using this information, we can add the following loop invariants:\n\n/*@ \n    loop invariant j >= i;\n    loop invariant (j + i) == 11;\n    loop invariant (j - i) == 9;\n*/\n\nThe first loop invariant is the same as before. The second loop invariant states that the sum of j and i is always 11. This is true because in each iteration, we add 2 to i and subtract 1 from j, so the difference between i and j remains constant, which is 9. The third loop invariant states that the difference between j and i is always 9.\n\nFinally, we can use the loop invariants and the loop condition to deduce a post-condition. Since the loop invariant guarantees that j >= i, and the loop condition is j >= i, we know that j < i is not possible after the loop terminates. Therefore, we can add the following loop invariant:\n\n/*@ \n    loop invariant j >= i;\n    loop invariant (j + i) == 11;\n    loop invariant (j - i) == 9;\n    loop invariant (j < i ==> j == 5);\n*/\n\nThe last loop invariant states that if j < i at any point during the loop, then j must be equal to 5 at that point. This implies that after the loop terminates, j cannot be less than i and must be equal to 6, which is the post-condition. Therefore, the loop invariants imply the post-condition.\n\nNote: Since there are no non-deterministic variables in the program, we do not need to use any implications to handle them.",
            "Pre-conditions:\n- None\n\nVariable Assignments:\n- i is assigned the value 1\n- j is assigned the value 10\n\nLoop Condition:\n- j >= i\n\nPost-condition:\n- j == 6\n\nLoop Invariants:\n- i is odd before and after each iteration of the loop\n- j is even before and after each iteration of the loop\n- j >= i\n- i <= 11\n- j >= 6 ==> i == 11 (This holds at the end of the loop, when j is 6)\n- j < 6 ==> j - i == 4 ==> i == j - 4 (This also holds at the end of the loop, when j is less than 6)\n\nNote that we use implication to handle the conditional nature of the code. \n\nPutting all the loop invariants together, we get:\n```\n/*@\n    loop invariant i%2 == 1;\n    loop invariant j%2 == 0;\n    loop invariant j >= i;\n    loop invariant i <= 11;\n    loop invariant j >= 6 ==> i == 11;\n    loop invariant j < 6 ==> j - i == 4 ==> i == j - 4;\n*/\n```",
            "Pre-conditions:\n\nNone.\n\nVariable assignments:\n\n- i is assigned the value 1.\n- j is assigned the value 10.\n\nLoop condition:\n\n- The loop continues as long as j is greater than or equal to i.\n\nLoop body:\n\n- i is incremented by 2.\n- j is decremented by 1.\n\nPost-condition:\n\n- j is equal to 6.\n\nLoop invariants:\n\n- Before the loop execution, j is greater than or equal to i. (j >= i)\n- In every iteration of the loop, the difference between j and i is even. ((j - i) % 2 == 0)\n- After the loop termination, j is equal to 6.\n\nExplanation:\n\n- The first loop invariant (j >= i) holds before the loop execution because j is initially assigned a value of 10 and i is assigned a value of 1. Therefore, j is greater than or equal to i.\n- The second loop invariant ((j - i) % 2 == 0) holds in every iteration of the loop because i is incremented by 2 and j is decremented by 1. Therefore, the difference between j and i is always odd. When an odd number is divided by 2, the remainder is always 1. Hence, the difference between j and i is even.\n- The third loop invariant (j == 6) holds after the loop termination because j is decremented by 1 in each iteration of the loop and the loop continues until j is less than i. Since i is incremented by 2 in each iteration, j will eventually become equal to 6.\n\nTherefore, the loop invariants imply the post-condition."
        ],
        "annotation_blocks": [
            "/*@ loop invariant 1 <= i <= 11;\n    loop invariant 6 <= j <= 10;\n*/",
            "/*@ \n    loop invariant i%2 == 1;\n    loop invariant j%2 == 0;\n    loop invariant j-i == 9;\n    loop invariant j >= 5 ==> j-i >= 5;\n    loop invariant i <= 10;\n    loop invariant j >= 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions: None\n\nVariable assignments:\n- i = 1;\n- j = 10;\n\nLoop condition: j >= i\n\nPost-condition: j == 6\n\nSince we know that the loop will execute as long as j >= i, we can use this as the loop invariant:\n\n/*@ \n    loop invariant j >= i;\n*/\n\nNext, let's analyze the loop body. The loop body contains two assignments:\n- i = i + 2;\n- j = -1 + j;\n\nWe can use the loop invariant and the loop body to deduce more loop invariants. We can see that in every iteration of the loop, i increases by 2 and j decreases by 1. Using this information, we can add the following loop invariants:\n\n/*@ \n    loop invariant j >= i;\n    loop invariant (j + i) == 11;\n    loop invariant (j - i) == 9;\n*/\n\nThe first loop invariant is the same as before. The second loop invariant states that the sum of j and i is always 11. This is true because in each iteration, we add 2 to i and subtract 1 from j, so the difference between i and j remains constant, which is 9. The third loop invariant states that the difference between j and i is always 9.\n\nFinally, we can use the loop invariants and the loop condition to deduce a post-condition. Since the loop invariant guarantees that j >= i, and the loop condition is j >= i, we know that j < i is not possible after the loop terminates. Therefore, we can add the following loop invariant:\n\n/*@ \n    loop invariant j >= i;\n    loop invariant (j + i) == 11;\n    loop invariant (j - i) == 9;\n    loop invariant (j < i ==> j == 5);\n*/\n\nThe last loop invariant states that if j < i at any point during the loop, then j must be equal to 5 at that point. This implies that after the loop terminates, j cannot be less than i and must be equal to 6, which is the post-condition. Therefore, the loop invariants imply the post-condition.\n\nNote: Since there are no non-deterministic variables in the program, we do not need to use any implications to handle them."
            ],
            "/*@\n    loop invariant i%2 == 1;\n    loop invariant j%2 == 0;\n    loop invariant j >= i;\n    loop invariant i <= 11;\n    loop invariant j >= 6 ==> i == 11;\n    loop invariant j < 6 ==> j - i == 4 ==> i == j - 4;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n\nNone.\n\nVariable assignments:\n\n- i is assigned the value 1.\n- j is assigned the value 10.\n\nLoop condition:\n\n- The loop continues as long as j is greater than or equal to i.\n\nLoop body:\n\n- i is incremented by 2.\n- j is decremented by 1.\n\nPost-condition:\n\n- j is equal to 6.\n\nLoop invariants:\n\n- Before the loop execution, j is greater than or equal to i. (j >= i)\n- In every iteration of the loop, the difference between j and i is even. ((j - i) % 2 == 0)\n- After the loop termination, j is equal to 6.\n\nExplanation:\n\n- The first loop invariant (j >= i) holds before the loop execution because j is initially assigned a value of 10 and i is assigned a value of 1. Therefore, j is greater than or equal to i.\n- The second loop invariant ((j - i) % 2 == 0) holds in every iteration of the loop because i is incremented by 2 and j is decremented by 1. Therefore, the difference between j and i is always odd. When an odd number is divided by 2, the remainder is always 1. Hence, the difference between j and i is even.\n- The third loop invariant (j == 6) holds after the loop termination because j is decremented by 1 in each iteration of the loop and the loop continues until j is less than i. Since i is incremented by 2 in each iteration, j will eventually become equal to 6.\n\nTherefore, the loop invariants imply the post-condition."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ loop invariant 1 <= i <= 11;\n    loop invariant 6 <= j <= 10;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 1 <= i <= 11 is established but not preserved.\nloop invariant 6 <= j <= 10 is established but not preserved.\nAssertion j == 6: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    /*@\n\n\n*/\nwhile (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@ \n    loop invariant i%2 == 1;\n    loop invariant j%2 == 0;\n    loop invariant j-i == 9;\n    loop invariant j >= 5 ==> j-i >= 5;\n    loop invariant i <= 10;\n    loop invariant j >= 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i%2 == 1 is partially proven to be inductive.\nloop invariant j%2 == 0 is established but not preserved.\nloop invariant j-i == 9 is partially proven to be inductive.\nloop invariant j >= 5 ==> j-i >= 5 is partially proven to be inductive.\nloop invariant i <= 10 is partially proven to be inductive.\nloop invariant j >= 0 is partially proven to be inductive.\nAssertion j == 6: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    /*@\nloop invariant i1: i%2 == 1;\n\n\n\n\nloop invariant i6: j >= 0;\n*/\nwhile (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions: None\n\nVariable assignments:\n- i = 1;\n- j = 10;\n\nLoop condition: j >= i\n\nPost-condition: j == 6\n\nSince we know that the loop will execute as long as j >= i, we can use this as the loop invariant:\n\n/*@ \n    loop invariant j >= i;\n*/\n\nNext, let's analyze the loop body. The loop body contains two assignments:\n- i = i + 2;\n- j = -1 + j;\n\nWe can use the loop invariant and the loop body to deduce more loop invariants. We can see that in every iteration of the loop, i increases by 2 and j decreases by 1. Using this information, we can add the following loop invariants:\n\n/*@ \n    loop invariant j >= i;\n    loop invariant (j + i) == 11;\n    loop invariant (j - i) == 9;\n*/\n\nThe first loop invariant is the same as before. The second loop invariant states that the sum of j and i is always 11. This is true because in each iteration, we add 2 to i and subtract 1 from j, so the difference between i and j remains constant, which is 9. The third loop invariant states that the difference between j and i is always 9.\n\nFinally, we can use the loop invariants and the loop condition to deduce a post-condition. Since the loop invariant guarantees that j >= i, and the loop condition is j >= i, we know that j < i is not possible after the loop terminates. Therefore, we can add the following loop invariant:\n\n/*@ \n    loop invariant j >= i;\n    loop invariant (j + i) == 11;\n    loop invariant (j - i) == 9;\n    loop invariant (j < i ==> j == 5);\n*/\n\nThe last loop invariant states that if j < i at any point during the loop, then j must be equal to 5 at that point. This implies that after the loop terminates, j cannot be less than i and must be equal to 6, which is the post-condition. Therefore, the loop invariants imply the post-condition.\n\nNote: Since there are no non-deterministic variables in the program, we do not need to use any implications to handle them.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@\n    loop invariant i%2 == 1;\n    loop invariant j%2 == 0;\n    loop invariant j >= i;\n    loop invariant i <= 11;\n    loop invariant j >= 6 ==> i == 11;\n    loop invariant j < 6 ==> j - i == 4 ==> i == j - 4;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i%2 == 1 is partially proven to be inductive.\nloop invariant j%2 == 0 is partially proven to be inductive.\nloop invariant j >= i is partially proven to be inductive.\nloop invariant i <= 11 is partially proven to be inductive.\nloop invariant j >= 6 ==> i == 11 is preserved but not established.\nloop invariant j < 6 ==> j - i == 4 ==> i == j - 4 is partially proven to be inductive.\nAssertion j == 6: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    /*@\nloop invariant i1: i%2 == 1;\n\n\n\n\nloop invariant i6: j < 6 ==> j - i == 4 ==> i == j - 4;\n*/\nwhile (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n\nNone.\n\nVariable assignments:\n\n- i is assigned the value 1.\n- j is assigned the value 10.\n\nLoop condition:\n\n- The loop continues as long as j is greater than or equal to i.\n\nLoop body:\n\n- i is incremented by 2.\n- j is decremented by 1.\n\nPost-condition:\n\n- j is equal to 6.\n\nLoop invariants:\n\n- Before the loop execution, j is greater than or equal to i. (j >= i)\n- In every iteration of the loop, the difference between j and i is even. ((j - i) % 2 == 0)\n- After the loop termination, j is equal to 6.\n\nExplanation:\n\n- The first loop invariant (j >= i) holds before the loop execution because j is initially assigned a value of 10 and i is assigned a value of 1. Therefore, j is greater than or equal to i.\n- The second loop invariant ((j - i) % 2 == 0) holds in every iteration of the loop because i is incremented by 2 and j is decremented by 1. Therefore, the difference between j and i is always odd. When an odd number is divided by 2, the remainder is always 1. Hence, the difference between j and i is even.\n- The third loop invariant (j == 6) holds after the loop termination because j is decremented by 1 in each iteration of the loop and the loop continues until j is less than i. Since i is incremented by 2 in each iteration, j will eventually become equal to 6.\n\nTherefore, the loop invariants imply the post-condition.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant 1 <= i <= 11 is partially proven to be inductive.\nloop invariant 6 <= j <= 10 is partially proven to be inductive.\nloop invariant i%2 == 1 is partially proven to be inductive.\nloop invariant j%2 == 0 is partially proven to be inductive.\nloop invariant j-i == 9 is partially proven to be inductive.\nloop invariant j >= 5 ==> j-i >= 5 is partially proven to be inductive.\nloop invariant i <= 10 is partially proven to be inductive.\nloop invariant j >= 0 is partially proven to be inductive.\nloop invariant j >= i is partially proven to be inductive.\nloop invariant i <= 11 is partially proven to be inductive.\nloop invariant j >= 6 ==> i == 11 is preserved but not established.\nloop invariant j < 6 ==> j - i == 4 ==> i == j - 4 is partially proven to be inductive.\nAssertion j == 6: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    /*@\nloop invariant i1: 1 <= i <= 11;\nloop invariant i2: 6 <= j <= 10;\nloop invariant i3: i%2 == 1;\nloop invariant i4: j%2 == 0;\nloop invariant i5: j-i == 9;\nloop invariant i6: j >= 5 ==> j-i >= 5;\nloop invariant i7: i <= 10;\nloop invariant i8: j >= 0;\nloop invariant i9: j >= i;\nloop invariant i10: i <= 11;\nloop invariant i11: j >= 6 ==> i == 11;\nloop invariant i12: j < 6 ==> j - i == 4 ==> i == j - 4;\n*/\nwhile (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}",
        "combined_annotation_num_solver_calls": 9,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\n\nint main() {\n    int i,j;\n    i = 1;\n    j = 10;\n    /*@\n\n\nloop invariant i3: i%2 == 1;\n\n\n\n\nloop invariant i8: j >= 0;\n\n\n\nloop invariant i12: j < 6 ==> j - i == 4 ==> i == j - 4;\n*/\nwhile (j >= i) {\n        i = i + 2;\n        j = -1 + j;\n    }\n    {;\n//@ assert(j == 6);\n}\n\n    return 0;\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c"
        ],
        "skipped": [],
        "total": 117,
        "success_count": 50,
        "failure_count": 67,
        "success_rate": 0.42735042735042733
    }
}