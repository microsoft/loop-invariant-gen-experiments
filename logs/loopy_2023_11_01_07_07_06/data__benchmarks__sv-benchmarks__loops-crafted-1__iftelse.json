{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loops-crafted-1/iftelse.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  while( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}\n",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  while( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "First, let's consider the pre-conditions and variable assignments in the program:\n- The macro `assume` takes a boolean expression and returns 0 if the expression is false.\n- The external function `unknown_uint` returns an unsigned integer value that is not known in advance.\n- The variable `SIZE` is assigned the value 20000001.\n- The variable `n` is assigned the value returned by `unknown_uint`.\n- The variables `i`, `j`, and `k` are initialized to 0.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is `i < n`.\n- Inside the loop, `i` is incremented by 3 and then checked for evenness using the modulo operator `%`.\n- If `i` is odd, `j` is incremented by 3. Otherwise, `k` is incremented by 3.\n- Finally, if `n` is positive, an assertion is made that `i/2 <= j`.\n\nBased on the program structure and the loop body, we can come up with the following loop invariants:\n```\n/*@ \n    loop invariant 0 <= i <= n;\n    loop invariant i % 3 == 0;\n    loop invariant j >= 3*(i/3)/2;\n    loop invariant k >= 3*(i/3)/2;\n    loop invariant j + k == 3*((i/3)/2)*(2 + (i%6 == 0));\n    loop invariant n > 0 ==> (i/2 <= j);\n*/\n```\nLet's break down each of these invariants:\n- The first invariant states that `i` is always between 0 and `n`, inclusive.\n- The second invariant states that `i` is always a multiple of 3.\n- The third invariant states that `j` is always greater than or equal to `3*(i/3)/2`. Since `i` is always a multiple of 3, `i/3` is an integer and `3*(i/3)` is the largest multiple of 3 that is less than or equal to `i`. Therefore, `(i/3)/2` is the largest multiple of 3 that is less than or equal to `i/2`, and `3*((i/3)/2)` is the largest multiple of 3 that is less than or equal to `i/2`. The factor of 2 in the denominator is because `j` is updated only when `i` is odd, which means `i/2` is half of an even number, and therefore twice the largest multiple of 3 that is less than or equal to `(i/2)/2`.\n- The fourth invariant is similar to the third invariant, but for `k` instead of `j`.\n- The fifth invariant relates `j` and `k` to `i`. When `i` is even, `j` and `k` are incremented by 3 together, so `j + k` is always a multiple of 6. When `i` is odd, only `j` is incremented by 3, so `j + k` is always a multiple of 3. Therefore, we can write `j + k` as `3*(i/3)*(2 + (i%6 == 0))`, where the factor of 2 is added when `i` is even.\n- The sixth invariant guards the assertion in the code. It states that if `n` is positive, then `i/2` is always less than or equal to `j`. Note that this invariant is trivially true when `n` is non-positive, since the assertion is not executed in that case. \n\nFinally, note that since `unknown_uint` is non-deterministic, we cannot make any assumptions about the initial value of `n`. Therefore, the loop invariants should be true even when `n` is zero or negative. This is why the fifth and sixth invariants use the `i%6` expression instead of assuming that `i` is odd or even.",
            "Pre-conditions and variable assignments:\n- The macro `assume` takes a boolean expression and if it evaluates to false, the program returns 0.\n- `SIZE` is assigned the value 20000001.\n- `n`, `i`, `j`, and `k` are all uninitialized.\n\nLoop condition:\n- The loop runs while `i < n`.\n\nLoop invariants:\n- Before the loop: `i == 0 && j == 0 && k == 0 && n <= SIZE`.\n- In every iteration:\n    - `i % 3 == 0`\n    - `(i-3)/2 <= j <= i/2`\n    - `(i-3)/2 <= k <= i/2`\n    - `i <= n <= SIZE`\n- After the loop: `(i-3)/2 <= j <= i/2`.\n\nLet's explain each of these loop invariants:\n- Before the loop: `i == 0 && j == 0 && k == 0 && n <= SIZE`. This invariant ensures that the loop starts with `i`, `j`, and `k` all equal to 0, and that `n` is less than or equal to `SIZE`.\n- In every iteration:\n    - `i % 3 == 0`: Since `i` is incremented by 3 in each iteration, this invariant ensures that `i` is always divisible by 3.\n    - `(i-3)/2 <= j <= i/2`: This invariant ensures that `j` is always between `(i-3)/2` and `i/2`, inclusive. The first half of the invariant `(i-3)/2 <= j` holds true because if `i` is odd, `i-3` is even, and `i-3` divided by 2 is less than or equal to `(i-3)/2`, which is less than or equal to `i/2`. The second half of the invariant `j <= i/2` holds true because if `i` is even, `i/2` is an integer and thus `j` cannot exceed it.\n    - `(i-3)/2 <= k <= i/2`: This invariant is similar to the one above, but for `k`.\n    - `i <= n <= SIZE`: This invariant ensures that `n` is always between `i` and `SIZE`, inclusive.\n- After the loop: `(i-3)/2 <= j <= i/2`. This invariant ensures that `j` is between `(i-3)/2` and `i/2`, inclusive, after the loop has terminated.\n\nPutting it all together, the loop invariants are:\n```\n/*@ \n    loop invariant i % 3 == 0;\n    loop invariant (i-3)/2 <= j <= i/2;\n    loop invariant (i-3)/2 <= k <= i/2;\n    loop invariant i <= n <= SIZE;\n    loop invariant (n > 0 ==> (i/2 <= j));\n    loop invariant i == 0 && j == 0 && k == 0 && n <= SIZE;\n    loop assigns i, j, k;\n    loop variant SIZE-n;\n*/\n```",
            "First, let's analyze the code and make a note of the pre-conditions or variable assignments in the program:\n- The macro `assume` takes a boolean expression and returns 0 if the expression is false.\n- The function `unknown_uint()` returns an unsigned integer whose value is unknown.\n- The variable `SIZE` is assigned the value 20000001.\n- The variable `n` is assigned the value returned by `unknown_uint()`.\n- The variables `i`, `j`, and `k` are all assigned the value 0.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is `i < n`.\n- The loop body increments `i` by 3, and then checks if `i` is odd or even. If `i` is odd, `j` is incremented by 3. If `i` is even, `k` is incremented by 3.\n- If `n` is greater than 0, the assertion `(i/2 <= j)` is checked.\n\nNow, let's output the loop invariants:\n- Before the loop execution, we have `n <= SIZE`, since this is checked in the beginning of the program.\n- In every iteration of the loop, we have:\n  - `i % 3 == 0`, since `i` is incremented by 3 in every iteration.\n  - `j <= i/2`, since `j` is incremented by 3 only when `i` is odd.\n  - `k <= i/2`, since `k` is incremented by 3 only when `i` is even.\n- After the loop termination, we have `(i >= n) && (i % 3 == 0) && (j <= i/2) && (k <= i/2)`, since `i` is incremented by 3 in every iteration until it is greater than or equal to `n`, and the other two loop invariants hold in every iteration. Also, since `i` is always a multiple of 3 in the loop and is greater than or equal to `n` at the end of the loop, `(i >= n) && (i % 3 == 0)` holds.\n\nPutting it all together, we get the following loop invariants:\n\n```\n/*@ \n    loop invariant n <= SIZE;\n    loop invariant i % 3 == 0;\n    loop invariant j <= i/2;\n    loop invariant k <= i/2;\n    loop invariant (n > 0 ==> i/2 <= j);\n    loop invariant i >= n && i % 3 == 0 && j <= i/2 && k <= i/2;\n*/\n```",
            "Pre-conditions:\n- The macro `assume(e)` returns 0 if the expression `e` evaluates to false.\n- The function `unknown_uint()` returns a non-deterministic unsigned integer.\n- The variable `SIZE` is assigned the integer value 20000001.\n- The program checks if the input `n` is less than or equal to `SIZE`.\n\nVariable Assignments:\n- The variables `i`, `j`, and `k` are assigned the integer value 0.\n\nLoop Condition:\n- The loop continues to execute while the value of `i` is less than `n`.\n\nLoop Invariants:\n- Before the loop execution, `i`, `j`, and `k` are all equal to 0.\n- In every iteration of the loop, the value of `i` is incremented by 3, and either `j` or `k` is incremented by 3 depending on whether `i` is odd or even.\n- After the loop termination, the value of `i` is greater than or equal to `n`.\n- In every iteration of the loop, the following loop invariant holds: \n```\n  (i%2 == 0 ==> i/2 <= k) && (i%2 != 0 ==> i/2 <= j)\n```\n- This loop invariant can be explained as follows:\n    - If `i` is even, then `i/2` is an integer, and since `k` is incremented only when `i` is even, we know that `k` must be at least as large as `i/2`.\n    - If `i` is odd, then `i/2` is rounded down to an integer, and since `j` is incremented only when `i` is odd, we know that `j` must be at least as large as `i/2`.\n- Since `n` is non-deterministic, we can use an implication to make the loop invariant trivially true at the end of the loop:\n```\n  (n <= SIZE) ==> (i >= n)\n``` \n- This implication says that if `n` is greater than `SIZE`, then the loop invariant is not required to hold, and if `n` is less than or equal to `SIZE`, then the loop invariant implies that `i` is greater than or equal to `n`.",
            "Pre-conditions:\n- The macro `assume(e)` is defined to check if the condition `e` holds, and if not, the program returns 0.\n- The function `unknown_uint()` returns an arbitrary unsigned integer value.\n- The constant `SIZE` is initialized to 20000001.\n- The variable `n` is assigned a value returned by `unknown_uint()`.\n- The value of `n` must be less than or equal to `SIZE`.\n\nLoop condition:\n- The loop continues as long as the value of `i` is less than `n`.\n\nLoop invariants:\n- Since `i` is incremented by 3 in each iteration, its value can be expressed as `i = 3 * m`, where `m` is the number of iterations. Thus, the maximum value of `i` is `3 * (n/3) = n - n%3`, and the minimum value of `i` is 0. Therefore, we can add the following loop invariant:\n```\n/*@ loop invariant 0 <= i <= n - n%3;*/\n```\n- Since `j` and `k` are incremented by 3 in each iteration depending on the parity of `i`, we can express their values as `j = 3 * p + r` and `k = 3 * q + s`, where `p` and `q` are the number of even iterations and odd iterations respectively, and `r` and `s` are the number of additional increments due to odd parity of `i`. Thus, `j` and `k` can be expressed in terms of `i` as follows:\n```\nj = 3 * (i/2) + (i%2)*3\nk = 3 * ((i-1)/2) + ((i-1)%2)*3\n```\n- We can see that `j` is always greater than or equal to `i/2`, while `k` is always less than or equal to `(i-1)/2`. Therefore, we can add the following loop invariant:\n```\n/*@ loop invariant i%2 == 0 ==> (i/2 <= j);\n    loop invariant i%2 == 1 ==> (k <= (i-1)/2);*/\n```\n- The assertion is guarded by the condition `n>0`, so we can add an implication to the loop invariant:\n```\n/*@ loop invariant (n>0 && i%2 == 0) ==> (i/2 <= j);\n    loop invariant (n>0 && i%2 == 1) ==> (k <= (i-1)/2);*/\n```\n- Since the value of `n` is non-deterministic, we can add an implication to make the loop invariant trivially true at the beginning and end of the loop:\n```\n/*@ loop invariant n > SIZE ==> (i == 0 && j == 0 && k == 0);\n    loop invariant i == n ==> (j == 3 * (n/2) && k == 3 * ((n-1)/2)); */\n```\nPutting it all together, the loop invariants are:\n```\n/*@ loop invariant 0 <= i <= n - n%3;\n    loop invariant i%2 == 0 ==> (i/2 <= j);\n    loop invariant i%2 == 1 ==> (k <= (i-1)/2);\n    loop invariant (n>0 && i%2 == 0) ==> (i/2 <= j);\n    loop invariant (n>0 && i%2 == 1) ==> (k <= (i-1)/2);\n    loop invariant n > SIZE ==> (i == 0 && j == 0 && k == 0);\n    loop invariant i == n ==> (j == 3 * (n/2) && k == 3 * ((n-1)/2)); */\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant 0 <= i <= n;\n    loop invariant i % 3 == 0;\n    loop invariant j >= 3*(i/3)/2;\n    loop invariant k >= 3*(i/3)/2;\n    loop invariant j + k == 3*((i/3)/2)*(2 + (i%6 == 0));\n    loop invariant n > 0 ==> (i/2 <= j);\n*/",
            "/*@ \n    loop invariant i % 3 == 0;\n    loop invariant (i-3)/2 <= j <= i/2;\n    loop invariant (i-3)/2 <= k <= i/2;\n    loop invariant i <= n <= SIZE;\n    loop invariant (n > 0 ==> (i/2 <= j));\n    loop invariant i == 0 && j == 0 && k == 0 && n <= SIZE;\n    loop assigns i, j, k;\n    loop variant SIZE-n;\n*/",
            "/*@ \n    loop invariant n <= SIZE;\n    loop invariant i % 3 == 0;\n    loop invariant j <= i/2;\n    loop invariant k <= i/2;\n    loop invariant (n > 0 ==> i/2 <= j);\n    loop invariant i >= n && i % 3 == 0 && j <= i/2 && k <= i/2;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The macro `assume(e)` returns 0 if the expression `e` evaluates to false.\n- The function `unknown_uint()` returns a non-deterministic unsigned integer.\n- The variable `SIZE` is assigned the integer value 20000001.\n- The program checks if the input `n` is less than or equal to `SIZE`.\n\nVariable Assignments:\n- The variables `i`, `j`, and `k` are assigned the integer value 0.\n\nLoop Condition:\n- The loop continues to execute while the value of `i` is less than `n`.\n\nLoop Invariants:\n- Before the loop execution, `i`, `j`, and `k` are all equal to 0.\n- In every iteration of the loop, the value of `i` is incremented by 3, and either `j` or `k` is incremented by 3 depending on whether `i` is odd or even.\n- After the loop termination, the value of `i` is greater than or equal to `n`.\n- In every iteration of the loop, the following loop invariant holds: \n```\n  (i%2 == 0 ==> i/2 <= k) && (i%2 != 0 ==> i/2 <= j)\n```\n- This loop invariant can be explained as follows:\n    - If `i` is even, then `i/2` is an integer, and since `k` is incremented only when `i` is even, we know that `k` must be at least as large as `i/2`.\n    - If `i` is odd, then `i/2` is rounded down to an integer, and since `j` is incremented only when `i` is odd, we know that `j` must be at least as large as `i/2`.\n- Since `n` is non-deterministic, we can use an implication to make the loop invariant trivially true at the end of the loop:\n```\n  (n <= SIZE) ==> (i >= n)\n``` \n- This implication says that if `n` is greater than `SIZE`, then the loop invariant is not required to hold, and if `n` is less than or equal to `SIZE`, then the loop invariant implies that `i` is greater than or equal to `n`."
            ],
            "/*@ loop invariant 0 <= i <= n - n%3;*/"
        ],
        "completions": [
            {
                "num_solver_calls": 4,
                "annotations": "/*@ \n    loop invariant 0 <= i <= n;\n    loop invariant i % 3 == 0;\n    loop invariant j >= 3*(i/3)/2;\n    loop invariant k >= 3*(i/3)/2;\n    loop invariant j + k == 3*((i/3)/2)*(2 + (i%6 == 0));\n    loop invariant n > 0 ==> (i/2 <= j);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 16: invalid operands to binary +; unexpected ℤ and 𝔹. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  /*@\n\nloop invariant i2: i % 3 == 0;\nloop invariant i3: j >= 3*(i/3)/2;\n\n\nloop invariant i6: n > 0 ==> (i/2 <= j);\n*/\nwhile( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@ \n    loop invariant i % 3 == 0;\n    loop invariant (i-3)/2 <= j <= i/2;\n    loop invariant (i-3)/2 <= k <= i/2;\n    loop invariant i <= n <= SIZE;\n    loop invariant (n > 0 ==> (i/2 <= j));\n    loop invariant i == 0 && j == 0 && k == 0 && n <= SIZE;\n    loop assigns i, j, k;\n    loop variant SIZE-n;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i % 3 == 0 is partially proven to be inductive.\nloop invariant (i-3)/2 <= j <= i/2 is established but not preserved.\nloop invariant (i-3)/2 <= k <= i/2 is partially proven to be inductive.\nloop invariant i <= n <= SIZE is partially proven to be inductive.\nloop invariant (n > 0 ==> (i/2 <= j)) is partially proven to be inductive.\nloop invariant i == 0 && j == 0 && k == 0 && n <= SIZE is partially proven to be inductive.\nAssertion i / 2 <= j: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  /*@\nloop invariant i1: i % 3 == 0;\n\n\n\nloop invariant i5: (n > 0 ==> (i/2 <= j));\n\n*/\nwhile( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@ \n    loop invariant n <= SIZE;\n    loop invariant i % 3 == 0;\n    loop invariant j <= i/2;\n    loop invariant k <= i/2;\n    loop invariant (n > 0 ==> i/2 <= j);\n    loop invariant i >= n && i % 3 == 0 && j <= i/2 && k <= i/2;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant n <= SIZE is partially proven to be inductive.\nloop invariant i % 3 == 0 is partially proven to be inductive.\nloop invariant j <= i/2 is partially proven to be inductive.\nloop invariant k <= i/2 is partially proven to be inductive.\nloop invariant (n > 0 ==> i/2 <= j) is partially proven to be inductive.\nloop invariant i >= n && i % 3 == 0 && j <= i/2 && k <= i/2 is preserved but not established.\nAssertion i / 2 <= j: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  /*@\nloop invariant i1: n <= SIZE;\nloop invariant i2: i % 3 == 0;\n\n\nloop invariant i5: (n > 0 ==> i/2 <= j);\n\n*/\nwhile( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The macro `assume(e)` returns 0 if the expression `e` evaluates to false.\n- The function `unknown_uint()` returns a non-deterministic unsigned integer.\n- The variable `SIZE` is assigned the integer value 20000001.\n- The program checks if the input `n` is less than or equal to `SIZE`.\n\nVariable Assignments:\n- The variables `i`, `j`, and `k` are assigned the integer value 0.\n\nLoop Condition:\n- The loop continues to execute while the value of `i` is less than `n`.\n\nLoop Invariants:\n- Before the loop execution, `i`, `j`, and `k` are all equal to 0.\n- In every iteration of the loop, the value of `i` is incremented by 3, and either `j` or `k` is incremented by 3 depending on whether `i` is odd or even.\n- After the loop termination, the value of `i` is greater than or equal to `n`.\n- In every iteration of the loop, the following loop invariant holds: \n```\n  (i%2 == 0 ==> i/2 <= k) && (i%2 != 0 ==> i/2 <= j)\n```\n- This loop invariant can be explained as follows:\n    - If `i` is even, then `i/2` is an integer, and since `k` is incremented only when `i` is even, we know that `k` must be at least as large as `i/2`.\n    - If `i` is odd, then `i/2` is rounded down to an integer, and since `j` is incremented only when `i` is odd, we know that `j` must be at least as large as `i/2`.\n- Since `n` is non-deterministic, we can use an implication to make the loop invariant trivially true at the end of the loop:\n```\n  (n <= SIZE) ==> (i >= n)\n``` \n- This implication says that if `n` is greater than `SIZE`, then the loop invariant is not required to hold, and if `n` is less than or equal to `SIZE`, then the loop invariant implies that `i` is greater than or equal to `n`.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ loop invariant 0 <= i <= n - n%3;*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= i <= n - n%3 is established but not preserved.\nAssertion i / 2 <= j: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  /*@\n\n*/\nwhile( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 16: invalid operands to binary +; unexpected ℤ and 𝔹. Ignoring loop annotation",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  /*@\nloop invariant i1: 0 <= i <= n;\nloop invariant i2: i % 3 == 0;\nloop invariant i3: j >= 3*(i/3)/2;\nloop invariant i4: k >= 3*(i/3)/2;\nloop invariant i5: j + k == 3*((i/3)/2)*(2 + (i%6 == 0));\nloop invariant i6: n > 0 ==> (i/2 <= j);\nloop invariant i7: (i-3)/2 <= j <= i/2;\nloop invariant i8: (i-3)/2 <= k <= i/2;\nloop invariant i9: i <= n <= SIZE;\nloop invariant i10: (n > 0 ==> (i/2 <= j));\nloop invariant i11: i == 0 && j == 0 && k == 0 && n <= SIZE;\nloop invariant i12: n <= SIZE;\nloop invariant i13: j <= i/2;\nloop invariant i14: k <= i/2;\nloop invariant i15: (n > 0 ==> i/2 <= j);\nloop invariant i16: i >= n && i % 3 == 0 && j <= i/2 && k <= i/2;\nloop invariant i17: 0 <= i <= n - n%3;\n*/\nwhile( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}\n",
        "combined_annotation_num_solver_calls": 9,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = j = k = 0;\n  /*@\n\nloop invariant i2: i % 3 == 0;\nloop invariant i3: j >= 3*(i/3)/2;\n\n\nloop invariant i6: n > 0 ==> (i/2 <= j);\n\n\n\nloop invariant i10: (n > 0 ==> (i/2 <= j));\n\nloop invariant i12: n <= SIZE;\n\n\nloop invariant i15: (n > 0 ==> i/2 <= j);\n\n\n*/\nwhile( i < n ) {\n    i = i + 3;\n    if(i%2)\n\t    j = j+3;\n    else\n\t    k = k+3;\n    if(n>0)\n\t  {;\n//@ assert( (i/2<=j) );\n}\n\n  }\n  return 0;\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/NetBSD_loop.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/afnp2014.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/css2003.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007b.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gsv2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/hhk2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_2.c",
            "../data/benchmarks/sv-benchmarks/loop-new/gauss_sum.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark01_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark02_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark04_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark05_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark06_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark08_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark10_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark11_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark13_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark14_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark15_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark16_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark17_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark18_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark20_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark21_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark22_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark23_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark25_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark26_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark27_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark29_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark30_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark31_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark32_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark33_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark34_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark35_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark36_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark37_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark38_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark39_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark40_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark41_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark42_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark43_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark45_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark48_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark49_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark50_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark51_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark52_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark53_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum04-2.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_02-2.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/trex03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/while_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/while_infinite_loop_2.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/even.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/mod4.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/odd.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/id_trans.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/bhmr2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/ddlm2013.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gcnr2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gr2006.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_k.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_nondet.c",
            "../data/benchmarks/sv-benchmarks/loop-new/half.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark03_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark07_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark09_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark12_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark19_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark24_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark28_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark44_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark46_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark47_linear.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-2.c",
            "../data/benchmarks/sv-benchmarks/loops/for_bounded_loop1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02_sum01_bug02_base.case.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum04-1.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_02-1.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/trex03-1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/iftelse.c"
        ],
        "skipped": [],
        "total": 382,
        "success_count": 198,
        "failure_count": 184,
        "success_rate": 0.518324607329843
    }
}