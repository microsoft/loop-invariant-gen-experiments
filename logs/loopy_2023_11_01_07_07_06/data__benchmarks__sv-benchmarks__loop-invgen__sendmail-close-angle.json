{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  while (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  while (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- `inlen` is the length of input, `bufferlen` is the length of buffer.\n- `bufferlen` > 1, `inlen` > 0, and `bufferlen` < `inlen`.\n\nVariable Assignments:\n- `buf` is initialized to 0.\n- `in` is initialized to 0.\n- `buflim` is initialized to `bufferlen - 2`.\n\nLoop Condition:\n- `unknown_int()` returns a non-zero integer.\n\nLoop Invariants:\n```\n/*@ \n   loop invariant 0 <= buf <= bufferlen;\n   loop invariant 0 <= in <= inlen;\n   loop invariant buf <= buflim ==> in < inlen;\n   loop invariant buf > buflim ==> in == inlen;\n   loop invariant buf >= 2;\n   loop invariant buf <= bufferlen - 1;\n*/\n```\nExplanation:\n- The first two loop invariants are true before the loop execution because `buf` and `in` are initialized to 0, and the maximum value that they can take is `bufferlen` and `inlen`, respectively.\n- The third loop invariant is true in every iteration of the loop because `buf <= buflim` implies that the buffer is not yet full and hence, `in` is less than `inlen`.\n- The fourth loop invariant is true in every iteration of the loop because `buf > buflim` implies that the buffer is full and hence, `in` is equal to `inlen`.\n- The fifth loop invariant is true before the loop execution because `buf` is initialized to 0 and hence, `buf >= 2` is true.\n- The sixth loop invariant is true in every iteration of the loop because `buf` is incremented by 1 in every iteration and hence, it cannot exceed `bufferlen - 1`.\n- The loop invariants imply the post-condition because at the end of the loop, `buf` is incremented by 1 twice, and hence it satisfies the post-condition `0 <= buf < bufferlen`.",
            "First, let's analyze the pre-conditions and variable assignments in the program:\n\n- The program defines a macro `assume(e)` that returns 0 if the expression `e` evaluates to false.\n- There is an external function `unknown_int()` that returns an unknown integer value.\n- The program declares several integer variables: `in`, `inlen`, `bufferlen`, `buf`, and `buflim`.\n- The program checks if `bufferlen` is greater than 1, `inlen` is greater than 0, and `bufferlen` is less than `inlen`. If any of these conditions is false, the program jumps to the label `END`.\n- The program initializes `buf` and `in` to 0, and `buflim` to `bufferlen - 2`.\n\nNext, let's analyze the loop body and the loop condition:\n\n- The loop condition is `unknown_int()`. This means that the loop will execute an unknown number of times.\n- If `buf` is equal to `buflim`, the loop breaks.\n- The program has two assertions inside the loop body that check the bounds of `buf`. The first assertion checks if `buf` is greater than or equal to 0, and the second assertion checks if `buf` is less than `bufferlen`.\n- The program has two assertions inside the loop body that check the bounds of `in`. The first assertion checks if `in` is greater than or equal to 0, and the second assertion checks if `in` is less than `inlen`.\n- The program increments `buf` and `in` at the end of each iteration.\n\nBased on the above analysis, we can derive the following loop invariants:\n\n```\n/*@\nloop invariant 0 <= buf <= bufferlen;\nloop invariant 0 <= in <= inlen;\nloop invariant buflim == bufferlen - 2;\nloop invariant 0 <= buflim < bufferlen;\nloop invariant buf <= buflim + 1;\nloop invariant (buf == buflim + 1) ==> (in == inlen);\nloop invariant (buf == buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf < buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf < buflim + 1) ==> (in < inlen);\nloop invariant (buf < buflim + 1) ==> (buf >= 0);\nloop invariant (buf < buflim + 1) ==> (in >= 0);\nloop invariant (buf >= buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf >= buflim + 1) ==> (in < inlen);\nloop invariant (buf >= buflim + 1) ==> (buf >= 0);\nloop invariant (buf >= buflim + 1) ==> (in >= 0);\n*/\n```\n\nLet's explain each invariant:\n\n- The first invariant states that `buf` is always greater than or equal to 0 and less than or equal to `bufferlen`. This is derived from the first assertion inside the loop body.\n- The second invariant states that `in` is always greater than or equal to 0 and less than or equal to `inlen`. This is derived from the second assertion inside the loop body.\n- The third invariant states that `buflim` is always equal to `bufferlen - 2`. This is derived from the initialization of `buflim`.\n- The fourth invariant states that `buflim` is always greater than or equal to 0 and less than `bufferlen`. This is derived from the initialization of `buflim`.\n- The fifth invariant states that if `buf` is equal to `buflim + 1`, then `in` is equal to `inlen`. This is derived from the implication in the loop condition that checks if `buf` is equal to `buflim`.\n- The sixth invariant states that if `buf` is equal to `buflim + 1`, then `buf` is less than `bufferlen`. This is derived from the implication in the loop condition that checks if `buf` is equal to `buflim`.\n- The seventh invariant states that if `buf` is less than `buflim + 1`, then `buf` is less than `bufferlen`. This is derived from the implication in the loop condition that checks if `buf` is equal to `buflim`.\n- The eighth invariant states that if `buf` is less than `buflim + 1`, then `in` is less than `inlen`. This is derived from the implication in the loop condition that checks if `buf` is equal to `buflim`.\n- The ninth invariant states that if `buf",
            "Pre-conditions:\n- `bufferlen > 1`\n- `inlen > 0`\n- `bufferlen < inlen`\n\nVariable assignments:\n- `buf = 0`\n- `in = 0`\n- `buflim = bufferlen - 2`\n\nLoop condition: `unknown_int()`\n\nLoop invariants:\n```\n/*@\nloop invariant 0 <= buf <= bufferlen;\nloop invariant 0 <= in <= inlen;\nloop invariant buf <= buflim ==> in < inlen;\nloop invariant (buf == buflim + 1) ==> (in == inlen);\nloop invariant \\forall integer i; 0 <= i < buf ==> i <= buflim;\nloop invariant \\forall integer i; buf <= i < bufferlen ==> buflim < i;\nloop invariant \\forall integer i; 0 <= i < in ==> i < buf;\nloop invariant \\forall integer i; in <= i < inlen ==> buf <= i;\n*/\n```\nExplanation:\n- Loop invariants 1 and 2 ensure that `buf` stays within the bounds of the buffer.\n- Loop invariant 3 ensures that if `buf` reaches `buflim`, then `in` must be less than `inlen`.\n- Loop invariant 4 ensures that if `buf` exceeds `buflim+1`, then `in` must have reached `inlen`.\n- Loop invariant 5 ensures that all values of `i` less than `buf` must be less than or equal to `buflim`.\n- Loop invariant 6 ensures that all values of `i` greater than or equal to `buf` and less than `bufferlen` must be greater than `buflim`.\n- Loop invariant 7 ensures that all values of `i` less than `in` must be less than `buf`.\n- Loop invariant 8 ensures that all values of `i` greater than or equal to `in` and less than `inlen` must be greater than or equal to `buf`.",
            "The pre-conditions and variable assignments in the program are:\n\n```\nint in;\nint inlen = unknown_int();\nint bufferlen = unknown_int();\nint buf;\nint buflim;\n\nif(bufferlen >1);else goto END;\nif(inlen > 0);else goto END;\nif(bufferlen < inlen);else goto END;\n\nbuf = 0;\nin = 0;\nbuflim = bufferlen - 2;\n```\n\nThe loop condition is `while (unknown_int())`.\n\nThe necessary loop invariants are:\n\n```\n/*@\nloop invariant 0<=buf<=bufferlen;\nloop invariant 0<=in<inlen;\nloop invariant buf != buflim ==> in < inlen; \nloop invariant buf == buflim ==> in == inlen-1;\nloop invariant 0<=buflim<bufferlen-1;\nloop invariant buflim == bufferlen-2 ==> buf == buflim+1;\nloop invariant \\forall integer i; 0<=i<buf ==> i<buflim ==> \\at(in,Pre) <= in;\n*/\n```\n\nExplanation of the loop invariants:\n\n- `0<=buf<=bufferlen;` - This invariant states that `buf` is always within the bounds of the buffer.\n- `0<=in<inlen;` - This invariant states that `in` is always within the bounds of the input.\n- `buf != buflim ==> in < inlen;` - This invariant states that if `buf` is not equal to `buflim`, then `in` is less than `inlen`.\n- `buf == buflim ==> in == inlen-1;` - This invariant states that if `buf` is equal to `buflim`, then `in` is exactly equal to `inlen-1`.\n- `0<=buflim<bufferlen-1;` - This invariant states that `buflim` is always within the bounds of the buffer, but not at the end.\n- `buflim == bufferlen-2 ==> buf == buflim+1;` - This invariant states that if `buflim` is at the second last position of the buffer, then `buf` is at the last position.\n- `\\forall integer i; 0<=i<buf ==> i<buflim ==> \\at(in,Pre) <= in;` - This invariant states that for all `i` between `0` and `buf`, if `i` is less than `buflim`, then the value of `in` at the beginning of the loop (`\\at(in,Pre)`) is less than or equal to the current value of `in`. This invariant is necessary because `in` only increments once in each loop iteration, but `buf` can increment multiple times in one iteration, which means that `in` may not increase monotonically.",
            "Pre-conditions:\n- `inlen` is the length of the input array `in`.\n- `bufferlen` is the length of the buffer array `buf`.\n- `buf` is initialized to 0.\n- `in` is initialized to 0.\n- `buflim` is initialized to `bufferlen - 2`.\n- The `if` conditions check that `bufferlen` is greater than 1, `inlen` is greater than 0, and `bufferlen` is less than `inlen`.\n\nLoop condition:\n- The loop condition is `unknown_int()`, which means that it is not known when the loop will terminate.\n\nLoop invariants:\n- `0 <= buf < bufferlen`\n- `0 <= in < inlen`\n- `buf <= buflim ==> in < inlen` (if `buf` reaches `buflim`, then all elements of `in` must have been processed)\n- `buf > buflim ==> in = inlen` (if `buf` exceeds `buflim`, then all elements of `in` must have been processed)\n- `buf <= buflim + 1` (after the loop exits, `buf` is incremented twice)\n- `0 <= in <= inlen` (trivially true at the end of the loop, since `in` is incremented in each iteration)\n- `0 <= buf <= bufferlen` (trivially true at the end of the loop, since `buf` is incremented in each iteration)\n\nPutting it all together:\n```\n/*@ \n    loop invariant 0 <= buf < bufferlen;\n    loop invariant 0 <= in < inlen;\n    loop invariant buf <= buflim ==> in < inlen;\n    loop invariant buf > buflim ==> in = inlen;\n    loop invariant buf <= buflim + 1;\n    loop invariant (buf <= buflim + 1) ==> (0 <= buf < bufferlen);\n    loop invariant (buf <= buflim + 1) ==> (0 <= in <= inlen);\n    loop invariant (buf > buflim + 1) ==> (0 <= buf <= bufferlen);\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n   loop invariant 0 <= buf <= bufferlen;\n   loop invariant 0 <= in <= inlen;\n   loop invariant buf <= buflim ==> in < inlen;\n   loop invariant buf > buflim ==> in == inlen;\n   loop invariant buf >= 2;\n   loop invariant buf <= bufferlen - 1;\n*/",
            "/*@\nloop invariant 0 <= buf <= bufferlen;\nloop invariant 0 <= in <= inlen;\nloop invariant buflim == bufferlen - 2;\nloop invariant 0 <= buflim < bufferlen;\nloop invariant buf <= buflim + 1;\nloop invariant (buf == buflim + 1) ==> (in == inlen);\nloop invariant (buf == buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf < buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf < buflim + 1) ==> (in < inlen);\nloop invariant (buf < buflim + 1) ==> (buf >= 0);\nloop invariant (buf < buflim + 1) ==> (in >= 0);\nloop invariant (buf >= buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf >= buflim + 1) ==> (in < inlen);\nloop invariant (buf >= buflim + 1) ==> (buf >= 0);\nloop invariant (buf >= buflim + 1) ==> (in >= 0);\n*/",
            "/*@\nloop invariant 0 <= buf <= bufferlen;\nloop invariant 0 <= in <= inlen;\nloop invariant buf <= buflim ==> in < inlen;\nloop invariant (buf == buflim + 1) ==> (in == inlen);\nloop invariant \\forall integer i; 0 <= i < buf ==> i <= buflim;\nloop invariant \\forall integer i; buf <= i < bufferlen ==> buflim < i;\nloop invariant \\forall integer i; 0 <= i < in ==> i < buf;\nloop invariant \\forall integer i; in <= i < inlen ==> buf <= i;\n*/",
            "/*@\nloop invariant 0<=buf<=bufferlen;\nloop invariant 0<=in<inlen;\nloop invariant buf != buflim ==> in < inlen; \nloop invariant buf == buflim ==> in == inlen-1;\nloop invariant 0<=buflim<bufferlen-1;\nloop invariant buflim == bufferlen-2 ==> buf == buflim+1;\nloop invariant \\forall integer i; 0<=i<buf ==> i<buflim ==> \\at(in,Pre) <= in;\n*/",
            "/*@ \n    loop invariant 0 <= buf < bufferlen;\n    loop invariant 0 <= in < inlen;\n    loop invariant buf <= buflim ==> in < inlen;\n    loop invariant buf > buflim ==> in = inlen;\n    loop invariant buf <= buflim + 1;\n    loop invariant (buf <= buflim + 1) ==> (0 <= buf < bufferlen);\n    loop invariant (buf <= buflim + 1) ==> (0 <= in <= inlen);\n    loop invariant (buf > buflim + 1) ==> (0 <= buf <= bufferlen);\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 4,
                "annotations": "/*@ \n   loop invariant 0 <= buf <= bufferlen;\n   loop invariant 0 <= in <= inlen;\n   loop invariant buf <= buflim ==> in < inlen;\n   loop invariant buf > buflim ==> in == inlen;\n   loop invariant buf >= 2;\n   loop invariant buf <= bufferlen - 1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= buf <= bufferlen is partially proven to be inductive.\nloop invariant 0 <= in <= inlen is partially proven to be inductive.\nloop invariant buf <= buflim ==> in < inlen is partially proven to be inductive.\nloop invariant buf > buflim ==> in == inlen is partially proven to be inductive.\nloop invariant buf >= 2 is preserved but not established.\nloop invariant buf <= bufferlen - 1 is partially proven to be inductive.\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven\nAssertion 0 <= in: Partially proven\nAssertion in < inlen: Partially proven\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\nloop invariant i1: 0 <= buf <= bufferlen;\nloop invariant i2: 0 <= in <= inlen;\nloop invariant i3: buf <= buflim ==> in < inlen;\nloop invariant i4: buf > buflim ==> in == inlen;\n\n\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@\nloop invariant 0 <= buf <= bufferlen;\nloop invariant 0 <= in <= inlen;\nloop invariant buflim == bufferlen - 2;\nloop invariant 0 <= buflim < bufferlen;\nloop invariant buf <= buflim + 1;\nloop invariant (buf == buflim + 1) ==> (in == inlen);\nloop invariant (buf == buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf < buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf < buflim + 1) ==> (in < inlen);\nloop invariant (buf < buflim + 1) ==> (buf >= 0);\nloop invariant (buf < buflim + 1) ==> (in >= 0);\nloop invariant (buf >= buflim + 1) ==> (buf < bufferlen);\nloop invariant (buf >= buflim + 1) ==> (in < inlen);\nloop invariant (buf >= buflim + 1) ==> (buf >= 0);\nloop invariant (buf >= buflim + 1) ==> (in >= 0);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= buf <= bufferlen is partially proven to be inductive.\nloop invariant 0 <= in <= inlen is partially proven to be inductive.\nloop invariant buflim == bufferlen - 2 is partially proven to be inductive.\nloop invariant 0 <= buflim < bufferlen is partially proven to be inductive.\nloop invariant buf <= buflim + 1 is partially proven to be inductive.\nloop invariant (buf == buflim + 1) ==> (in == inlen) is partially proven to be inductive.\nloop invariant (buf == buflim + 1) ==> (buf < bufferlen) is partially proven to be inductive.\nloop invariant (buf < buflim + 1) ==> (buf < bufferlen) is partially proven to be inductive.\nloop invariant (buf < buflim + 1) ==> (in < inlen) is partially proven to be inductive.\nloop invariant (buf < buflim + 1) ==> (buf >= 0) is partially proven to be inductive.\nloop invariant (buf < buflim + 1) ==> (in >= 0) is partially proven to be inductive.\nloop invariant (buf >= buflim + 1) ==> (buf < bufferlen) is partially proven to be inductive.\nloop invariant (buf >= buflim + 1) ==> (in < inlen) is partially proven to be inductive.\nloop invariant (buf >= buflim + 1) ==> (buf >= 0) is partially proven to be inductive.\nloop invariant (buf >= buflim + 1) ==> (in >= 0) is partially proven to be inductive.\nAssertion 0 <= buf: Valid\nAssertion buf < bufferlen: Valid\nAssertion 0 <= in: Valid\nAssertion in < inlen: Unproven\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\nloop invariant i1: 0 <= buf <= bufferlen;\nloop invariant i2: 0 <= in <= inlen;\nloop invariant i3: buflim == bufferlen - 2;\nloop invariant i4: 0 <= buflim < bufferlen;\nloop invariant i5: buf <= buflim + 1;\nloop invariant i6: (buf == buflim + 1) ==> (in == inlen);\nloop invariant i7: (buf == buflim + 1) ==> (buf < bufferlen);\nloop invariant i8: (buf < buflim + 1) ==> (buf < bufferlen);\nloop invariant i9: (buf < buflim + 1) ==> (in < inlen);\nloop invariant i10: (buf < buflim + 1) ==> (buf >= 0);\nloop invariant i11: (buf < buflim + 1) ==> (in >= 0);\nloop invariant i12: (buf >= buflim + 1) ==> (buf < bufferlen);\nloop invariant i13: (buf >= buflim + 1) ==> (in < inlen);\nloop invariant i14: (buf >= buflim + 1) ==> (buf >= 0);\nloop invariant i15: (buf >= buflim + 1) ==> (in >= 0);\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@\nloop invariant 0 <= buf <= bufferlen;\nloop invariant 0 <= in <= inlen;\nloop invariant buf <= buflim ==> in < inlen;\nloop invariant (buf == buflim + 1) ==> (in == inlen);\nloop invariant \\forall integer i; 0 <= i < buf ==> i <= buflim;\nloop invariant \\forall integer i; buf <= i < bufferlen ==> buflim < i;\nloop invariant \\forall integer i; 0 <= i < in ==> i < buf;\nloop invariant \\forall integer i; in <= i < inlen ==> buf <= i;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= buf <= bufferlen is partially proven to be inductive.\nloop invariant 0 <= in <= inlen is partially proven to be inductive.\nloop invariant buf <= buflim ==> in < inlen is partially proven to be inductive.\nloop invariant (buf == buflim + 1) ==> (in == inlen) is partially proven to be inductive.\nloop invariant \\forall integer i; 0 <= i < buf ==> i <= buflim is partially proven to be inductive.\nloop invariant \\forall integer i; buf <= i < bufferlen ==> buflim < i is preserved but not established.\nloop invariant \\forall integer i; 0 <= i < in ==> i < buf is partially proven to be inductive.\nloop invariant \\forall integer i; in <= i < inlen ==> buf <= i is partially proven to be inductive.\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven\nAssertion 0 <= in: Partially proven\nAssertion in < inlen: Partially proven\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven\nAssertion 0 <= buf: Partially proven\nAssertion buf < bufferlen: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\nloop invariant i1: 0 <= buf <= bufferlen;\nloop invariant i2: 0 <= in <= inlen;\nloop invariant i3: buf <= buflim ==> in < inlen;\nloop invariant i4: (buf == buflim + 1) ==> (in == inlen);\n\n\nloop invariant i7: \\forall integer i; 0 <= i < in ==> i < buf;\nloop invariant i8: \\forall integer i; in <= i < inlen ==> buf <= i;\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@\nloop invariant 0<=buf<=bufferlen;\nloop invariant 0<=in<inlen;\nloop invariant buf != buflim ==> in < inlen; \nloop invariant buf == buflim ==> in == inlen-1;\nloop invariant 0<=buflim<bufferlen-1;\nloop invariant buflim == bufferlen-2 ==> buf == buflim+1;\nloop invariant \\forall integer i; 0<=i<buf ==> i<buflim ==> \\at(in,Pre) <= in;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 27: unbound logic variable in. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\nloop invariant i1: 0<=buf<=bufferlen;\nloop invariant i2: 0<=in<inlen;\nloop invariant i3: buf != buflim ==> in < inlen;\n\nloop invariant i5: 0<=buflim<bufferlen-1;\n\n\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@ \n    loop invariant 0 <= buf < bufferlen;\n    loop invariant 0 <= in < inlen;\n    loop invariant buf <= buflim ==> in < inlen;\n    loop invariant buf > buflim ==> in = inlen;\n    loop invariant buf <= buflim + 1;\n    loop invariant (buf <= buflim + 1) ==> (0 <= buf < bufferlen);\n    loop invariant (buf <= buflim + 1) ==> (0 <= in <= inlen);\n    loop invariant (buf > buflim + 1) ==> (0 <= buf <= bufferlen);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 24: Assignment operators not allowed in annotations.",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\n\nloop invariant i2: 0 <= in < inlen;\nloop invariant i3: buf <= buflim ==> in < inlen;\n\n\n\nloop invariant i7: (buf <= buflim + 1) ==> (0 <= in <= inlen);\nloop invariant i8: (buf > buflim + 1) ==> (0 <= buf <= bufferlen);\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 53: Assignment operators not allowed in annotations.",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\nloop invariant i1: 0 <= buf <= bufferlen;\nloop invariant i2: 0 <= in <= inlen;\nloop invariant i3: buf <= buflim ==> in < inlen;\nloop invariant i4: buf > buflim ==> in == inlen;\nloop invariant i5: buf >= 2;\nloop invariant i6: buf <= bufferlen - 1;\nloop invariant i7: buflim == bufferlen - 2;\nloop invariant i8: 0 <= buflim < bufferlen;\nloop invariant i9: buf <= buflim + 1;\nloop invariant i10: (buf == buflim + 1) ==> (in == inlen);\nloop invariant i11: (buf == buflim + 1) ==> (buf < bufferlen);\nloop invariant i12: (buf < buflim + 1) ==> (buf < bufferlen);\nloop invariant i13: (buf < buflim + 1) ==> (in < inlen);\nloop invariant i14: (buf < buflim + 1) ==> (buf >= 0);\nloop invariant i15: (buf < buflim + 1) ==> (in >= 0);\nloop invariant i16: (buf >= buflim + 1) ==> (buf < bufferlen);\nloop invariant i17: (buf >= buflim + 1) ==> (in < inlen);\nloop invariant i18: (buf >= buflim + 1) ==> (buf >= 0);\nloop invariant i19: (buf >= buflim + 1) ==> (in >= 0);\nloop invariant i20: \\forall integer i; 0 <= i < buf ==> i <= buflim;\nloop invariant i21: \\forall integer i; buf <= i < bufferlen ==> buflim < i;\nloop invariant i22: \\forall integer i; 0 <= i < in ==> i < buf;\nloop invariant i23: \\forall integer i; in <= i < inlen ==> buf <= i;\nloop invariant i24: 0<=buf<=bufferlen;\nloop invariant i25: 0<=in<inlen;\nloop invariant i26: buf != buflim ==> in < inlen;\nloop invariant i27: buf == buflim ==> in == inlen-1;\nloop invariant i28: 0<=buflim<bufferlen-1;\nloop invariant i29: buflim == bufferlen-2 ==> buf == buflim+1;\nloop invariant i30: \\forall integer i; 0<=i<buf ==> i<buflim ==> \\at(in,Pre) <= in;\nloop invariant i31: 0 <= buf < bufferlen;\nloop invariant i32: 0 <= in < inlen;\nloop invariant i33: buf > buflim ==> in = inlen;\nloop invariant i34: (buf <= buflim + 1) ==> (0 <= buf < bufferlen);\nloop invariant i35: (buf <= buflim + 1) ==> (0 <= in <= inlen);\nloop invariant i36: (buf > buflim + 1) ==> (0 <= buf <= bufferlen);\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
        "combined_annotation_num_solver_calls": 7,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main ()\n{\n  int in;\n  int inlen = unknown_int();\n  int bufferlen = unknown_int();\n  int buf;\n  int buflim;\n\n  if(bufferlen >1);else goto END;\n  if(inlen > 0);else goto END;\n  if(bufferlen < inlen);else goto END;\n\n  buf = 0;\n  in = 0;\n  buflim = bufferlen - 2;\n\n  /*@\nloop invariant i1: 0 <= buf <= bufferlen;\nloop invariant i2: 0 <= in <= inlen;\nloop invariant i3: buf <= buflim ==> in < inlen;\nloop invariant i4: buf > buflim ==> in == inlen;\n\nloop invariant i6: buf <= bufferlen - 1;\nloop invariant i7: buflim == bufferlen - 2;\nloop invariant i8: 0 <= buflim < bufferlen;\nloop invariant i9: buf <= buflim + 1;\nloop invariant i10: (buf == buflim + 1) ==> (in == inlen);\nloop invariant i11: (buf == buflim + 1) ==> (buf < bufferlen);\nloop invariant i12: (buf < buflim + 1) ==> (buf < bufferlen);\nloop invariant i13: (buf < buflim + 1) ==> (in < inlen);\nloop invariant i14: (buf < buflim + 1) ==> (buf >= 0);\nloop invariant i15: (buf < buflim + 1) ==> (in >= 0);\nloop invariant i16: (buf >= buflim + 1) ==> (buf < bufferlen);\nloop invariant i17: (buf >= buflim + 1) ==> (in < inlen);\nloop invariant i18: (buf >= buflim + 1) ==> (buf >= 0);\nloop invariant i19: (buf >= buflim + 1) ==> (in >= 0);\nloop invariant i20: \\forall integer i; 0 <= i < buf ==> i <= buflim;\n\nloop invariant i22: \\forall integer i; 0 <= i < in ==> i < buf;\nloop invariant i23: \\forall integer i; in <= i < inlen ==> buf <= i;\nloop invariant i24: 0<=buf<=bufferlen;\nloop invariant i25: 0<=in<inlen;\nloop invariant i26: buf != buflim ==> in < inlen;\n\nloop invariant i28: 0<=buflim<bufferlen-1;\n\n\nloop invariant i31: 0 <= buf < bufferlen;\nloop invariant i32: 0 <= in < inlen;\n\nloop invariant i34: (buf <= buflim + 1) ==> (0 <= buf < bufferlen);\nloop invariant i35: (buf <= buflim + 1) ==> (0 <= in <= inlen);\nloop invariant i36: (buf > buflim + 1) ==> (0 <= buf <= bufferlen);\n*/\nwhile (unknown_int())\n  {\n    if (buf == buflim)\n      break;\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n \n    buf++;\nout:\n    in++;\n    {;\n//@ assert(0<=in);\n}\n\n    {;\n//@ assert(in<inlen);\n}\n\n  }\n\n    {;\n//@ assert(0<=buf);\n}\n\n    {;\n//@ assert(buf<bufferlen);\n}\n\n    buf++;\n\n  {;\n//@ assert(0<=buf);\n}\n\n  {;\n//@ assert(buf<bufferlen);\n}\n\n  buf++;\n\n END:  return 0;\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/NetBSD_loop.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/even.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/mod4.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/odd.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/id_trans.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c"
        ],
        "skipped": [],
        "total": 286,
        "success_count": 136,
        "failure_count": 150,
        "success_rate": 0.4755244755244755
    }
}