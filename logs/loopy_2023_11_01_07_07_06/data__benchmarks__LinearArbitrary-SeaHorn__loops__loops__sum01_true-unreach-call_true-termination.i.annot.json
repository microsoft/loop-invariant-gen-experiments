{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  for(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  for(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The macro `assume` ensures that `n` is less than 1000 and greater than or equal to -1000.\n\nLoop Condition:\n- The loop executes while `i` is less than or equal to `n`.\n\nPost-condition:\n- The value of `sn` is equal to `n*2` or `0`.\n\nLoop Invariants:\n- Before the loop: None required, as the pre-condition ensures that `n` is within a valid range.\n- In every iteration of the loop: `sn` is equal to `2*(i-1)`.\n- After the loop: `sn` is equal to `n*2` or `0`.\n\nExplanation:\n- Before the loop, we don't need any additional invariants as the pre-condition already ensures that `n` is within a valid range.\n- In every iteration of the loop, `sn` gets updated by adding `2` to it. Therefore, we can infer that `sn` is equal to `2*(i-1)` at the beginning of each iteration. This can be written as a loop invariant: `loop invariant sn == 2*(i-1);`.\n- After the loop, we know that `sn` should either be equal to `n*2` or `0`. Therefore, we can write the loop invariant as: `loop invariant sn == n*2 || sn == 0;`. \n\nPutting it all together, the loop invariants for the given program are:\n```\n/*@ \n    loop invariant sn == 2*(i-1);\n    loop invariant sn == n*2 || sn == 0;\n*/\n```",
            "Pre-conditions:\n- The variable `n` is initialized by calling the function `unknown_int()`, which returns an integer value. \n- The value of `n` is assumed to be less than 1000 and greater than or equal to -1000.\n\nVariable Assignments:\n- `i` is initialized to 1.\n- `sn` is initialized to 0.\n\nLoop Condition:\n- The loop iterates while `i` is less than or equal to `n`.\n\nLoop Invariants:\n- Before the loop execution, `sn` is equal to 0.\n```\n/*@ \n    loop invariant sn == 0;\n*/\n```\n- In every iteration of the loop, `sn` is equal to `i * 2`.\n```\n/*@ \n    loop invariant sn == (i-1) * 2;\n*/\n```\n- After the loop termination, the value of `sn` is equal to `n * 2` or `0`.\n```\n/*@ \n    loop invariant sn == (i-1) * 2 ==> sn == n * 2 || sn == 0;\n*/\n```\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0.\n- In every iteration of the loop, `sn` is incremented by 2. So, `sn` is equal to `(i-1) * 2`.\n- After the loop termination, the value of `sn` can either be `n * 2` or `0`. This is because the loop executes `n` times and increments `sn` by 2 in each iteration. So, `sn` will be equal to `n * 2` if `n` is positive and 0 if `n` is 0 or negative.\n- We use implication to take care of the conditional nature of the code. If `sn` is equal to `(i-1) * 2`, then after the loop termination, it must be equal to `n * 2` or `0`.\n- We assume that the value of `n` is less than 1000 and greater than or equal to -1000, as given in the pre-condition.",
            "Pre-conditions:\n- The macro `assume(e)` is defined such that if `e` is false, the program returns 0.\n- The function `unknown_int()` returns an integer value that is not known beforehand.\n\nVariable assignments:\n- The variable `n` is assigned the value returned by `unknown_int()`.\n- The variable `i` is assigned the value 1.\n- The variable `sn` is assigned the value 0.\n\nLoop condition:\n- The loop executes as long as `i` is less than or equal to `n`.\n\nPost-condition:\n- The value of `sn` is equal to `n*2` or 0.\n\nLoop invariants:\n- Before the loop execution: `sn == 0 && i == 1 && n < 1000 && n >= -1000`\n- In every iteration of the loop: `sn == (i-1)*2`\n- After the loop termination: `(i > n) ==> (sn == n*2 || sn == 0)`\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0, `i` is initialized to 1, and `n` is assumed to be within the range of -1000 to 999. \n- In every iteration of the loop, `sn` is incremented by 2, which is the same as adding `(i-1)*2` to the previous value of `sn`.\n- After the loop termination, `i` is greater than `n`. This means that `sn` should be equal to `n*2` if `n` is positive or 0, or it should be equal to 0 if `n` is negative. This can be expressed as an implication: if `i > n`, then `sn` is either equal to `n*2` or 0.",
            "Pre-conditions:\n- The `unknown_int()` function returns an integer value for `n` which is less than 1000 and greater than or equal to -1000.\n\nVariable Assignments:\n- `i` is initialized to 1.\n- `n` is assigned a value returned by the function `unknown_int()`.\n- `sn` is initialized to 0.\n\nLoop Condition:\n- The loop iterates while `i` is less than or equal to `n`.\n\nLoop Invariants:\n- `1 <= i <= n+1` (before loop execution): Since `i` is initialized to 1, it is greater than or equal to 1. Also, since the loop condition is `i<=n`, if `i` is less than or equal to `n`, then `i+1` is less than or equal to `n+1`. Therefore, `1 <= i <= n+1` is true before the loop execution.\n- `sn = 2*(i-1)` (in every iteration): Since `sn` is initialized to 0 and is incremented by `2` in each iteration, `sn` is always equal to `2*(i-1)` in every iteration of the loop.\n- `sn = (i-1)*(2) ==> sn + 2 = i*(2)` (in every iteration): This invariant is obtained by simplifying the previous invariant. It states that if `sn = 2*(i-1)` holds for an iteration, then `sn + 2 = i*(2)` holds in the next iteration.\n- `sn = n*(2) || sn = 0` (after loop termination): Since `sn` is incremented by `2` in each iteration and is initialized to 0, it will be equal to `n*(2)` if the loop iterates `n` times. Therefore, `sn = n*(2)` is a possible value of `sn` after loop termination. If `n` is less than 1, then the loop will not execute and `sn` will be equal to 0 after loop termination. Therefore, `sn = 0` is another possible value of `sn` after loop termination.\n- `n >= 1 ==> sn >= 2` (before loop execution): This invariant is obtained by using implication. If `n` is greater than or equal to 1, then `i` will be greater than or equal to 1 and `sn` will be incremented by `2` in each iteration. Therefore, `sn` will be greater than or equal to 2 if `n` is greater than or equal to 1. If `n` is less than 1, then the loop will not execute and the invariant is trivially true.\n- `n < 1 ==> sn = 0` (after loop termination): This invariant is obtained by using implication. If `n` is less than 1, then the loop will not execute and `sn` will be equal to 0 after loop termination. If `n` is greater than or equal to 1, then `sn` will be greater than or equal to 2 (as shown by the previous invariant) and cannot be equal to 0 after loop termination. Therefore, the invariant is true after loop termination.\n\nAll loop invariants combined:\n```\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant sn = (i-1)*(2) ==> sn + 2 = i*(2);\n    loop invariant sn == n*(2) || sn == 0;\n    loop invariant n >= 1 ==> sn >= 2;\n    loop invariant n < 1 ==> sn == 0;\n*/\n```",
            "First, let's analyze the loop body:\n```\nsn = sn +(2);\n```\nThis statement adds 2 to the value of `sn` in each iteration of the loop. \n\nNext, let's consider the loop condition:\n```\ni<=n\n```\nThis condition checks if the value of `i` is less than or equal to `n`. The loop will continue to execute as long as this condition is true.\n\nNow, let's find the loop invariants:\n- Before the loop execution:\n```\n//@ assert n < 1000 && n >= -1000;\n```\nThis assertion checks if the value of `n` is within the range of -1000 to 999. \n\n- In every iteration of the loop:\n```\n//@ assert sn == (i-1)*2;\n```\nThis assertion checks if the value of `sn` is equal to 2 times the number of iterations completed so far (starting from 0). \n\n- After the loop termination:\n```\n//@ assert sn==n*(2)|| sn == 0;\n```\nThis assertion checks if the value of `sn` is either equal to 2 times the number of iterations completed or 0. \n\nUsing implication, we can modify the loop invariants to take into account the conditional nature of the code:\n```\n//@ assert n < 1000 && n >= -1000;\n//@ assert sn == (i-1)*2 ==> sn+(2) == i*2;\n//@ assert sn == n*(2) || sn == 0;\n```\nThe first invariant states that before the loop execution, the value of `n` is within the specified range. \n\nThe second invariant states that in every iteration of the loop, the value of `sn` is equal to 2 times the number of iterations completed so far. The implication in this invariant takes into account the fact that the loop body is conditional and adds 2 to `sn` only if the loop condition is true. \n\nThe third invariant states that after the loop termination, the value of `sn` is either equal to 2 times the number of iterations completed or 0."
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant sn == 2*(i-1);\n    loop invariant sn == n*2 || sn == 0;\n*/",
            "/*@ \n    loop invariant sn == 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The macro `assume(e)` is defined such that if `e` is false, the program returns 0.\n- The function `unknown_int()` returns an integer value that is not known beforehand.\n\nVariable assignments:\n- The variable `n` is assigned the value returned by `unknown_int()`.\n- The variable `i` is assigned the value 1.\n- The variable `sn` is assigned the value 0.\n\nLoop condition:\n- The loop executes as long as `i` is less than or equal to `n`.\n\nPost-condition:\n- The value of `sn` is equal to `n*2` or 0.\n\nLoop invariants:\n- Before the loop execution: `sn == 0 && i == 1 && n < 1000 && n >= -1000`\n- In every iteration of the loop: `sn == (i-1)*2`\n- After the loop termination: `(i > n) ==> (sn == n*2 || sn == 0)`\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0, `i` is initialized to 1, and `n` is assumed to be within the range of -1000 to 999. \n- In every iteration of the loop, `sn` is incremented by 2, which is the same as adding `(i-1)*2` to the previous value of `sn`.\n- After the loop termination, `i` is greater than `n`. This means that `sn` should be equal to `n*2` if `n` is positive or 0, or it should be equal to 0 if `n` is negative. This can be expressed as an implication: if `i > n`, then `sn` is either equal to `n*2` or 0."
            ],
            "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant sn = (i-1)*(2) ==> sn + 2 = i*(2);\n    loop invariant sn == n*(2) || sn == 0;\n    loop invariant n >= 1 ==> sn >= 2;\n    loop invariant n < 1 ==> sn == 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "First, let's analyze the loop body:\n```\nsn = sn +(2);\n```\nThis statement adds 2 to the value of `sn` in each iteration of the loop. \n\nNext, let's consider the loop condition:\n```\ni<=n\n```\nThis condition checks if the value of `i` is less than or equal to `n`. The loop will continue to execute as long as this condition is true.\n\nNow, let's find the loop invariants:\n- Before the loop execution:\n```\n//@ assert n < 1000 && n >= -1000;\n```\nThis assertion checks if the value of `n` is within the range of -1000 to 999. \n\n- In every iteration of the loop:\n```\n//@ assert sn == (i-1)*2;\n```\nThis assertion checks if the value of `sn` is equal to 2 times the number of iterations completed so far (starting from 0). \n\n- After the loop termination:\n```\n//@ assert sn==n*(2)|| sn == 0;\n```\nThis assertion checks if the value of `sn` is either equal to 2 times the number of iterations completed or 0. \n\nUsing implication, we can modify the loop invariants to take into account the conditional nature of the code:\n```\n//@ assert n < 1000 && n >= -1000;\n//@ assert sn == (i-1)*2 ==> sn+(2) == i*2;\n//@ assert sn == n*(2) || sn == 0;\n```\nThe first invariant states that before the loop execution, the value of `n` is within the specified range. \n\nThe second invariant states that in every iteration of the loop, the value of `sn` is equal to 2 times the number of iterations completed so far. The implication in this invariant takes into account the fact that the loop body is conditional and adds 2 to `sn` only if the loop condition is true. \n\nThe third invariant states that after the loop termination, the value of `sn` is either equal to 2 times the number of iterations completed or 0."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant sn == 2*(i-1);\n    loop invariant sn == n*2 || sn == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant sn == n*2 || sn == 0 is established but not preserved.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\nloop invariant i1: sn == 2*(i-1);\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant sn == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn == 0 is established but not preserved.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The macro `assume(e)` is defined such that if `e` is false, the program returns 0.\n- The function `unknown_int()` returns an integer value that is not known beforehand.\n\nVariable assignments:\n- The variable `n` is assigned the value returned by `unknown_int()`.\n- The variable `i` is assigned the value 1.\n- The variable `sn` is assigned the value 0.\n\nLoop condition:\n- The loop executes as long as `i` is less than or equal to `n`.\n\nPost-condition:\n- The value of `sn` is equal to `n*2` or 0.\n\nLoop invariants:\n- Before the loop execution: `sn == 0 && i == 1 && n < 1000 && n >= -1000`\n- In every iteration of the loop: `sn == (i-1)*2`\n- After the loop termination: `(i > n) ==> (sn == n*2 || sn == 0)`\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0, `i` is initialized to 1, and `n` is assumed to be within the range of -1000 to 999. \n- In every iteration of the loop, `sn` is incremented by 2, which is the same as adding `(i-1)*2` to the previous value of `sn`.\n- After the loop termination, `i` is greater than `n`. This means that `sn` should be equal to `n*2` if `n` is positive or 0, or it should be equal to 0 if `n` is negative. This can be expressed as an implication: if `i > n`, then `sn` is either equal to `n*2` or 0.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant sn = (i-1)*(2) ==> sn + 2 = i*(2);\n    loop invariant sn == n*(2) || sn == 0;\n    loop invariant n >= 1 ==> sn >= 2;\n    loop invariant n < 1 ==> sn == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 10: Assignment operators not allowed in annotations.",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\n\n\n\nloop invariant i6: n < 1 ==> sn == 0;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "First, let's analyze the loop body:\n```\nsn = sn +(2);\n```\nThis statement adds 2 to the value of `sn` in each iteration of the loop. \n\nNext, let's consider the loop condition:\n```\ni<=n\n```\nThis condition checks if the value of `i` is less than or equal to `n`. The loop will continue to execute as long as this condition is true.\n\nNow, let's find the loop invariants:\n- Before the loop execution:\n```\n//@ assert n < 1000 && n >= -1000;\n```\nThis assertion checks if the value of `n` is within the range of -1000 to 999. \n\n- In every iteration of the loop:\n```\n//@ assert sn == (i-1)*2;\n```\nThis assertion checks if the value of `sn` is equal to 2 times the number of iterations completed so far (starting from 0). \n\n- After the loop termination:\n```\n//@ assert sn==n*(2)|| sn == 0;\n```\nThis assertion checks if the value of `sn` is either equal to 2 times the number of iterations completed or 0. \n\nUsing implication, we can modify the loop invariants to take into account the conditional nature of the code:\n```\n//@ assert n < 1000 && n >= -1000;\n//@ assert sn == (i-1)*2 ==> sn+(2) == i*2;\n//@ assert sn == n*(2) || sn == 0;\n```\nThe first invariant states that before the loop execution, the value of `n` is within the specified range. \n\nThe second invariant states that in every iteration of the loop, the value of `sn` is equal to 2 times the number of iterations completed so far. The implication in this invariant takes into account the fact that the loop body is conditional and adds 2 to `sn` only if the loop condition is true. \n\nThe third invariant states that after the loop termination, the value of `sn` is either equal to 2 times the number of iterations completed or 0.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 12: Assignment operators not allowed in annotations.",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\nloop invariant i1: sn == 2*(i-1);\nloop invariant i2: sn == n*2 || sn == 0;\nloop invariant i3: sn == 0;\nloop invariant i4: 1 <= i <= n+1;\nloop invariant i5: sn = (i-1)*(2) ==> sn + 2 = i*(2);\nloop invariant i6: sn == n*(2) || sn == 0;\nloop invariant i7: n >= 1 ==> sn >= 2;\nloop invariant i8: n < 1 ==> sn == 0;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
        "combined_annotation_num_solver_calls": 6,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\nloop invariant i1: sn == 2*(i-1);\n\n\n\n\n\n\nloop invariant i8: n < 1 ==> sn == 0;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c"
        ],
        "skipped": [],
        "total": 143,
        "success_count": 58,
        "failure_count": 85,
        "success_rate": 0.40559440559440557
    }
}