{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt3.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j,l=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l=0;\n  while( l < n ) {\n\t\n\t  if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k) == l);\n}\n\n  return 0;\n}\n",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j,l=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l=0;\n  while( l < n ) {\n\t\n\t  if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k) == l);\n}\n\n  return 0;\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions and variable assignments:\n- The macro `assume` checks if its argument is true, else it returns 0.\n- The external function `unknown_uint` returns an unknown unsigned integer value.\n- The integer variable `SIZE` is assigned the value 20000001.\n- The unsigned integers `n`, `i`, `j`, `k`, and `l` are declared and assigned the values 0.\n\nLoop condition:\n- The loop condition is `l < n`.\n\nLoop invariants:\n- `0 <= i`\n- `0 <= j`\n- `0 <= k`\n- `0 <= l`\n- `l <= n`\n- `(l%3 == 0) ==> i > 0`\n- `(l%2 == 0) ==> j > 0`\n- `(l%3 != 0) && (l%2 != 0) ==> k > 0`\n- `(i+j+k) == l`\n\nThe first four invariants are true before the loop execution. The fifth invariant is true before and after the loop execution. The remaining invariants are true before and after each iteration of the loop.\n\nThe first four invariants are straightforward as `i`, `j`, `k`, and `l` are initialized to 0 and are incremented by 1 at each iteration of the loop. Thus, they can never be negative and `l` is always less than or equal to `n`.\n\nThe fifth invariant follows from the loop condition. Since `l` is incremented by 1 at each iteration, it can never exceed `n`. Thus, the loop condition `l < n` implies `l <= n`.\n\nThe sixth invariant is true at the beginning of each iteration of the loop. If `l` is a multiple of 3, then `i` is incremented by 1, so `i` must be greater than 0. Similarly, if `l` is a multiple of 2, then `j` is incremented by 1, so `j` must be greater than 0. Finally, if `l` is not a multiple of 3 or 2, then `k` is incremented by 1, so `k` must be greater than 0.\n\nThe seventh invariant is true at the end of each iteration of the loop. The sum of `i`, `j`, and `k` gives the total number of times `i`, `j`, and `k` are incremented, which is equal to `l` since `l` is incremented at each iteration of the loop. Thus, `(i+j+k) == l`.\n\nFinally, the assertion is guarded by no condition, so we can add an implication that the assertion holds at the end of the loop:\n\n- `n <= SIZE ==> (i+j+k) == l`",
            "Pre-conditions:\n- The macro `assume(e)` is defined as `if(!(e)) return 0;`, which means that if the expression `e` evaluates to false, the program will terminate with a return value of 0. \n- The function `unknown_uint()` returns an unsigned integer value that is not known beforehand.\n- The variable `SIZE` is initialized to 20000001.\n\nVariable Assignments:\n- The variables `n`, `i`, `j`, `k` and `l` are declared as unsigned integers.\n- The value of `n` is assigned the return value of `unknown_uint()`.\n- The variables `i`, `j`, `k` and `l` are initialized to 0.\n\nLoop Condition:\n- The while loop executes as long as the value of `l` is less than the value of `n`.\n\nLoop Invariants:\n- The value of `i` is always greater than or equal to 0.\n- The value of `j` is always greater than or equal to 0.\n- The value of `k` is always greater than or equal to 0.\n- The value of `i+j+k` is always less than or equal to `l`.\n- The value of `l` is always less than or equal to `n`.\n- If `l` is divisible by 3, then `i` is incremented by 1. If `l` is not divisible by 3 but is divisible by 2, then `j` is incremented by 1. Otherwise, `k` is incremented by 1. Thus, after each iteration of the loop, the sum of `i`, `j` and `k` is incremented by 1.\n- Since `l` starts at 0 and is incremented by 1 after each iteration, the loop will execute `n` times, after which the value of `l` will be equal to `n`.\n- Therefore, the sum of `i`, `j` and `k` will be equal to `n` after the loop terminates, which implies that the post-condition `assert((i+j+k) == l)` holds.\n\nPutting everything together, the loop invariants are:\n\n```\n/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant i+j+k <= l;\n    loop invariant l <= n;\n    loop invariant (l%3 == 0 ==> i == \\old(i)+1) && (l%2 == 0 && l%3 != 0 ==> j == \\old(j)+1) && (l%2 != 0 && l%3 != 0 ==> k == \\old(k)+1);\n*/\n```",
            "Pre-conditions:\n- The macro `assume(e)` returns 0 if `!(e)` is true. \n- The function `unknown_uint()` returns an unsigned integer value.\n- The variable `SIZE` is initialized with a value of 20000001.\n\nVariable Assignments:\n- `n`, `i`, `j`, `k`, and `l` are uninitialized.\n\nLoop Condition:\n- The loop continues while `l < n`.\n\nLoop Invariants:\n- `0 <= i <= l`\n- `0 <= j <= l`\n- `0 <= k <= l`\n- `l <= n`\n- `(l-1)%2 != 0 ==> j == \\old(j)`\n- `(l-1)%3 != 0 ==> i == \\old(i)`\n- `(l-1)%2 == 0 ==> i == \\old(i)`\n- `(l-1)%3 == 0 ==> j == \\old(j)`\n- `(i+j+k) == l`\n\nExplanation:\n- `0 <= i <= l`, `0 <= j <= l`, and `0 <= k <= l` ensure that the values of `i`, `j`, and `k` remain non-negative and do not exceed `l`.\n- `l <= n` ensures that the loop will terminate when `l` reaches `n`.\n- `(l-1)%2 != 0 ==> j == \\old(j)` and `(l-1)%3 != 0 ==> i == \\old(i)` ensure that if `l` is not divisible by 2 or 3, then the values of `i` and `j` remain the same as their values before the loop iteration.\n- `(l-1)%2 == 0 ==> i == \\old(i)` and `(l-1)%3 == 0 ==> j == \\old(j)` ensure that if `l` is divisible by 2 or 3, then the values of `i` and `j` are updated according to the loop body.\n- `(i+j+k) == l` ensures that the sum of `i`, `j`, and `k` is equal to `l` at the end of each iteration of the loop. \n\nNote that since all variables are uninitialized at the beginning of the program, we do not need to add any additional constraints for them. Also, since the assertion is not guarded by any condition, we do not need to use implication in this case.",
            "Pre-conditions:\n- The macro `assume(e)` checks if the expression `e` is true. If it is not true, then the function returns 0.\n- The function `unknown_uint()` returns an unsigned integer whose value is unknown.\n- The variable `SIZE` is initialized to 20000001.\n- The variable `n` is initialized to the value returned by `unknown_uint()`.\n- The variable `i` is initialized to 0.\n- The variable `j` is initialized to 0.\n- The variable `k` is initialized to 0.\n- The variable `l` is initialized to 0.\n\nLoop condition:\n- The loop continues as long as `l` is less than `n`.\n\nPost-condition:\n- The sum of variables `i`, `j`, and `k` is equal to `l`.\n\nLoop invariants:\n```\n/*@\n\tloop invariant 0 <= i <= l;\n\tloop invariant 0 <= j <= l;\n\tloop invariant 0 <= k <= l;\n\tloop invariant l <= n;\n\tloop invariant l%3==0 ==> i==(l/3);\n\tloop invariant l%3!=0 ==> i==((l/3) + (l%3>1));\n\tloop invariant l%2==0 ==> j==(l/2);\n\tloop invariant l%2!=0 ==> j==((l/2) + (l%2>1));\n\tloop invariant (l%2==0 || l%3==0) ==> k==(l/6);\n\tloop invariant (l%2!=0 && l%3!=0) ==> k==((l/6) + 1);\n\tloop invariant (i+j+k) == l;\n*/\n```\nExplanation:\n- The first three loop invariants bound the values of variables `i`, `j`, and `k` to be non-negative and less than or equal to `l`.\n- The fourth loop invariant ensures that `l` is less than or equal to `n`.\n- The fifth loop invariant is true when `l` is a multiple of 3. In this case, `i` is equal to `l/3`. \n- The sixth loop invariant is true when `l` is not a multiple of 3 and `l` is greater than 1. In this case, `i` is equal to `l/3` rounded up to the nearest integer.\n- The seventh loop invariant is true when `l` is a multiple of 2. In this case, `j` is equal to `l/2`.\n- The eighth loop invariant is true when `l` is not a multiple of 2 and `l` is greater than 1. In this case, `j` is equal to `l/2` rounded up to the nearest integer.\n- The ninth loop invariant is true when `l` is a multiple of 2 or 3. In this case, `k` is equal to `l/6`.\n- The tenth loop invariant is true when `l` is not a multiple of 2 and 3. In this case, `k` is equal to `l/6` rounded up to the nearest integer.\n- The last loop invariant ensures that the sum of `i`, `j`, and `k` is equal to `l`.",
            "Pre-conditions and variable assignments:\n- The program defines a macro `assume(e)` which, if the argument `e` evaluates to false, immediately returns 0 from the program. \n- The program declares an external function `unknown_uint()` which returns an unknown unsigned integer value. \n- The program declares a global variable `SIZE` and initializes it to 20000001. \n- The program declares four unsigned integer variables `n`, `i`, `j`, and `k` and initializes `i`, `j`, `k`, and `l` to 0. \n- The program reads an unsigned integer value into `n` using the `unknown_uint()` function. \n- The program checks if `n` is less than or equal to `SIZE`. If not, it immediately returns 0. \n\nLoop condition:\n- The loop executes while `l < n`.\n\nLoop invariants:\n- Before the loop: \n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n- In every iteration:\n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n  - `i + j + k = l`\n- After the loop:\n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n  - `i + j + k = l`\n  - `l >= n ==> i + j + k = n`\n\nExplanation:\n- Before the loop, `i`, `j`, `k` are initialized to 0, so `0 <= i`, `0 <= j`, `0 <= k`.\n- Before the loop, `l` is initialized to 0 and `n` is read from an external function. Since `n` is non-negative, `l <= n`.\n- In every iteration of the loop, `i`, `j`, `k` are incremented by 1. Hence, `0 <= i`, `0 <= j`, `0 <= k` are maintained.\n- In every iteration of the loop, `l` is incremented by 1. Hence, `l <= n` is maintained.\n- In every iteration of the loop, `i + j + k = l` is maintained because the if-else statements in the loop body increment exactly one of `i`, `j`, `k` based on the value of `l` modulo 2 and 3.\n- After the loop, `i + j + k = l` is still maintained.\n- After the loop, if `l >= n`, it means that the loop was terminated because `l` reached `n`. In this case, we know that `l <= n` is already true, and since `i + j + k = l`, we can infer that `i + j + k = n`."
        ],
        "annotation_blocks": [
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions and variable assignments:\n- The macro `assume` checks if its argument is true, else it returns 0.\n- The external function `unknown_uint` returns an unknown unsigned integer value.\n- The integer variable `SIZE` is assigned the value 20000001.\n- The unsigned integers `n`, `i`, `j`, `k`, and `l` are declared and assigned the values 0.\n\nLoop condition:\n- The loop condition is `l < n`.\n\nLoop invariants:\n- `0 <= i`\n- `0 <= j`\n- `0 <= k`\n- `0 <= l`\n- `l <= n`\n- `(l%3 == 0) ==> i > 0`\n- `(l%2 == 0) ==> j > 0`\n- `(l%3 != 0) && (l%2 != 0) ==> k > 0`\n- `(i+j+k) == l`\n\nThe first four invariants are true before the loop execution. The fifth invariant is true before and after the loop execution. The remaining invariants are true before and after each iteration of the loop.\n\nThe first four invariants are straightforward as `i`, `j`, `k`, and `l` are initialized to 0 and are incremented by 1 at each iteration of the loop. Thus, they can never be negative and `l` is always less than or equal to `n`.\n\nThe fifth invariant follows from the loop condition. Since `l` is incremented by 1 at each iteration, it can never exceed `n`. Thus, the loop condition `l < n` implies `l <= n`.\n\nThe sixth invariant is true at the beginning of each iteration of the loop. If `l` is a multiple of 3, then `i` is incremented by 1, so `i` must be greater than 0. Similarly, if `l` is a multiple of 2, then `j` is incremented by 1, so `j` must be greater than 0. Finally, if `l` is not a multiple of 3 or 2, then `k` is incremented by 1, so `k` must be greater than 0.\n\nThe seventh invariant is true at the end of each iteration of the loop. The sum of `i`, `j`, and `k` gives the total number of times `i`, `j`, and `k` are incremented, which is equal to `l` since `l` is incremented at each iteration of the loop. Thus, `(i+j+k) == l`.\n\nFinally, the assertion is guarded by no condition, so we can add an implication that the assertion holds at the end of the loop:\n\n- `n <= SIZE ==> (i+j+k) == l`"
            ],
            "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant i+j+k <= l;\n    loop invariant l <= n;\n    loop invariant (l%3 == 0 ==> i == \\old(i)+1) && (l%2 == 0 && l%3 != 0 ==> j == \\old(j)+1) && (l%2 != 0 && l%3 != 0 ==> k == \\old(k)+1);\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The macro `assume(e)` returns 0 if `!(e)` is true. \n- The function `unknown_uint()` returns an unsigned integer value.\n- The variable `SIZE` is initialized with a value of 20000001.\n\nVariable Assignments:\n- `n`, `i`, `j`, `k`, and `l` are uninitialized.\n\nLoop Condition:\n- The loop continues while `l < n`.\n\nLoop Invariants:\n- `0 <= i <= l`\n- `0 <= j <= l`\n- `0 <= k <= l`\n- `l <= n`\n- `(l-1)%2 != 0 ==> j == \\old(j)`\n- `(l-1)%3 != 0 ==> i == \\old(i)`\n- `(l-1)%2 == 0 ==> i == \\old(i)`\n- `(l-1)%3 == 0 ==> j == \\old(j)`\n- `(i+j+k) == l`\n\nExplanation:\n- `0 <= i <= l`, `0 <= j <= l`, and `0 <= k <= l` ensure that the values of `i`, `j`, and `k` remain non-negative and do not exceed `l`.\n- `l <= n` ensures that the loop will terminate when `l` reaches `n`.\n- `(l-1)%2 != 0 ==> j == \\old(j)` and `(l-1)%3 != 0 ==> i == \\old(i)` ensure that if `l` is not divisible by 2 or 3, then the values of `i` and `j` remain the same as their values before the loop iteration.\n- `(l-1)%2 == 0 ==> i == \\old(i)` and `(l-1)%3 == 0 ==> j == \\old(j)` ensure that if `l` is divisible by 2 or 3, then the values of `i` and `j` are updated according to the loop body.\n- `(i+j+k) == l` ensures that the sum of `i`, `j`, and `k` is equal to `l` at the end of each iteration of the loop. \n\nNote that since all variables are uninitialized at the beginning of the program, we do not need to add any additional constraints for them. Also, since the assertion is not guarded by any condition, we do not need to use implication in this case."
            ],
            "/*@\n\tloop invariant 0 <= i <= l;\n\tloop invariant 0 <= j <= l;\n\tloop invariant 0 <= k <= l;\n\tloop invariant l <= n;\n\tloop invariant l%3==0 ==> i==(l/3);\n\tloop invariant l%3!=0 ==> i==((l/3) + (l%3>1));\n\tloop invariant l%2==0 ==> j==(l/2);\n\tloop invariant l%2!=0 ==> j==((l/2) + (l%2>1));\n\tloop invariant (l%2==0 || l%3==0) ==> k==(l/6);\n\tloop invariant (l%2!=0 && l%3!=0) ==> k==((l/6) + 1);\n\tloop invariant (i+j+k) == l;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions and variable assignments:\n- The program defines a macro `assume(e)` which, if the argument `e` evaluates to false, immediately returns 0 from the program. \n- The program declares an external function `unknown_uint()` which returns an unknown unsigned integer value. \n- The program declares a global variable `SIZE` and initializes it to 20000001. \n- The program declares four unsigned integer variables `n`, `i`, `j`, and `k` and initializes `i`, `j`, `k`, and `l` to 0. \n- The program reads an unsigned integer value into `n` using the `unknown_uint()` function. \n- The program checks if `n` is less than or equal to `SIZE`. If not, it immediately returns 0. \n\nLoop condition:\n- The loop executes while `l < n`.\n\nLoop invariants:\n- Before the loop: \n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n- In every iteration:\n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n  - `i + j + k = l`\n- After the loop:\n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n  - `i + j + k = l`\n  - `l >= n ==> i + j + k = n`\n\nExplanation:\n- Before the loop, `i`, `j`, `k` are initialized to 0, so `0 <= i`, `0 <= j`, `0 <= k`.\n- Before the loop, `l` is initialized to 0 and `n` is read from an external function. Since `n` is non-negative, `l <= n`.\n- In every iteration of the loop, `i`, `j`, `k` are incremented by 1. Hence, `0 <= i`, `0 <= j`, `0 <= k` are maintained.\n- In every iteration of the loop, `l` is incremented by 1. Hence, `l <= n` is maintained.\n- In every iteration of the loop, `i + j + k = l` is maintained because the if-else statements in the loop body increment exactly one of `i`, `j`, `k` based on the value of `l` modulo 2 and 3.\n- After the loop, `i + j + k = l` is still maintained.\n- After the loop, if `l >= n`, it means that the loop was terminated because `l` reached `n`. In this case, we know that `l <= n` is already true, and since `i + j + k = l`, we can infer that `i + j + k = n`."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions and variable assignments:\n- The macro `assume` checks if its argument is true, else it returns 0.\n- The external function `unknown_uint` returns an unknown unsigned integer value.\n- The integer variable `SIZE` is assigned the value 20000001.\n- The unsigned integers `n`, `i`, `j`, `k`, and `l` are declared and assigned the values 0.\n\nLoop condition:\n- The loop condition is `l < n`.\n\nLoop invariants:\n- `0 <= i`\n- `0 <= j`\n- `0 <= k`\n- `0 <= l`\n- `l <= n`\n- `(l%3 == 0) ==> i > 0`\n- `(l%2 == 0) ==> j > 0`\n- `(l%3 != 0) && (l%2 != 0) ==> k > 0`\n- `(i+j+k) == l`\n\nThe first four invariants are true before the loop execution. The fifth invariant is true before and after the loop execution. The remaining invariants are true before and after each iteration of the loop.\n\nThe first four invariants are straightforward as `i`, `j`, `k`, and `l` are initialized to 0 and are incremented by 1 at each iteration of the loop. Thus, they can never be negative and `l` is always less than or equal to `n`.\n\nThe fifth invariant follows from the loop condition. Since `l` is incremented by 1 at each iteration, it can never exceed `n`. Thus, the loop condition `l < n` implies `l <= n`.\n\nThe sixth invariant is true at the beginning of each iteration of the loop. If `l` is a multiple of 3, then `i` is incremented by 1, so `i` must be greater than 0. Similarly, if `l` is a multiple of 2, then `j` is incremented by 1, so `j` must be greater than 0. Finally, if `l` is not a multiple of 3 or 2, then `k` is incremented by 1, so `k` must be greater than 0.\n\nThe seventh invariant is true at the end of each iteration of the loop. The sum of `i`, `j`, and `k` gives the total number of times `i`, `j`, and `k` are incremented, which is equal to `l` since `l` is incremented at each iteration of the loop. Thus, `(i+j+k) == l`.\n\nFinally, the assertion is guarded by no condition, so we can add an implication that the assertion holds at the end of the loop:\n\n- `n <= SIZE ==> (i+j+k) == l`",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant i+j+k <= l;\n    loop invariant l <= n;\n    loop invariant (l%3 == 0 ==> i == \\old(i)+1) && (l%2 == 0 && l%3 != 0 ==> j == \\old(j)+1) && (l%2 != 0 && l%3 != 0 ==> k == \\old(k)+1);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 20: \\old undefined in this context. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j,l=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l=0;\n  /*@\nloop invariant i1: i >= 0;\nloop invariant i2: j >= 0;\nloop invariant i3: k >= 0;\nloop invariant i4: i+j+k <= l;\nloop invariant i5: l <= n;\n\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k) == l);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The macro `assume(e)` returns 0 if `!(e)` is true. \n- The function `unknown_uint()` returns an unsigned integer value.\n- The variable `SIZE` is initialized with a value of 20000001.\n\nVariable Assignments:\n- `n`, `i`, `j`, `k`, and `l` are uninitialized.\n\nLoop Condition:\n- The loop continues while `l < n`.\n\nLoop Invariants:\n- `0 <= i <= l`\n- `0 <= j <= l`\n- `0 <= k <= l`\n- `l <= n`\n- `(l-1)%2 != 0 ==> j == \\old(j)`\n- `(l-1)%3 != 0 ==> i == \\old(i)`\n- `(l-1)%2 == 0 ==> i == \\old(i)`\n- `(l-1)%3 == 0 ==> j == \\old(j)`\n- `(i+j+k) == l`\n\nExplanation:\n- `0 <= i <= l`, `0 <= j <= l`, and `0 <= k <= l` ensure that the values of `i`, `j`, and `k` remain non-negative and do not exceed `l`.\n- `l <= n` ensures that the loop will terminate when `l` reaches `n`.\n- `(l-1)%2 != 0 ==> j == \\old(j)` and `(l-1)%3 != 0 ==> i == \\old(i)` ensure that if `l` is not divisible by 2 or 3, then the values of `i` and `j` remain the same as their values before the loop iteration.\n- `(l-1)%2 == 0 ==> i == \\old(i)` and `(l-1)%3 == 0 ==> j == \\old(j)` ensure that if `l` is divisible by 2 or 3, then the values of `i` and `j` are updated according to the loop body.\n- `(i+j+k) == l` ensures that the sum of `i`, `j`, and `k` is equal to `l` at the end of each iteration of the loop. \n\nNote that since all variables are uninitialized at the beginning of the program, we do not need to add any additional constraints for them. Also, since the assertion is not guarded by any condition, we do not need to use implication in this case.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@\n\tloop invariant 0 <= i <= l;\n\tloop invariant 0 <= j <= l;\n\tloop invariant 0 <= k <= l;\n\tloop invariant l <= n;\n\tloop invariant l%3==0 ==> i==(l/3);\n\tloop invariant l%3!=0 ==> i==((l/3) + (l%3>1));\n\tloop invariant l%2==0 ==> j==(l/2);\n\tloop invariant l%2!=0 ==> j==((l/2) + (l%2>1));\n\tloop invariant (l%2==0 || l%3==0) ==> k==(l/6);\n\tloop invariant (l%2!=0 && l%3!=0) ==> k==((l/6) + 1);\n\tloop invariant (i+j+k) == l;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 20: invalid operands to binary +; unexpected ‚Ñ§ and ùîπ. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j,l=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l=0;\n  /*@\nloop invariant i1: 0 <= i <= l;\nloop invariant i2: 0 <= j <= l;\nloop invariant i3: 0 <= k <= l;\nloop invariant i4: l <= n;\n\n\n\n\n\n\nloop invariant i11: (i+j+k) == l;\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k) == l);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions and variable assignments:\n- The program defines a macro `assume(e)` which, if the argument `e` evaluates to false, immediately returns 0 from the program. \n- The program declares an external function `unknown_uint()` which returns an unknown unsigned integer value. \n- The program declares a global variable `SIZE` and initializes it to 20000001. \n- The program declares four unsigned integer variables `n`, `i`, `j`, and `k` and initializes `i`, `j`, `k`, and `l` to 0. \n- The program reads an unsigned integer value into `n` using the `unknown_uint()` function. \n- The program checks if `n` is less than or equal to `SIZE`. If not, it immediately returns 0. \n\nLoop condition:\n- The loop executes while `l < n`.\n\nLoop invariants:\n- Before the loop: \n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n- In every iteration:\n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n  - `i + j + k = l`\n- After the loop:\n  - `0 <= i`\n  - `0 <= j`\n  - `0 <= k`\n  - `l <= n`\n  - `i + j + k = l`\n  - `l >= n ==> i + j + k = n`\n\nExplanation:\n- Before the loop, `i`, `j`, `k` are initialized to 0, so `0 <= i`, `0 <= j`, `0 <= k`.\n- Before the loop, `l` is initialized to 0 and `n` is read from an external function. Since `n` is non-negative, `l <= n`.\n- In every iteration of the loop, `i`, `j`, `k` are incremented by 1. Hence, `0 <= i`, `0 <= j`, `0 <= k` are maintained.\n- In every iteration of the loop, `l` is incremented by 1. Hence, `l <= n` is maintained.\n- In every iteration of the loop, `i + j + k = l` is maintained because the if-else statements in the loop body increment exactly one of `i`, `j`, `k` based on the value of `l` modulo 2 and 3.\n- After the loop, `i + j + k = l` is still maintained.\n- After the loop, if `l >= n`, it means that the loop was terminated because `l` reached `n`. In this case, we know that `l <= n` is already true, and since `i + j + k = l`, we can infer that `i + j + k = n`.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 20: \\old undefined in this context. Ignoring loop annotation",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j,l=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l=0;\n  /*@\nloop invariant i1: i >= 0;\nloop invariant i2: j >= 0;\nloop invariant i3: k >= 0;\nloop invariant i4: i+j+k <= l;\nloop invariant i5: l <= n;\nloop invariant i6: (l%3 == 0 ==> i == \\old(i)+1) && (l%2 == 0 && l%3 != 0 ==> j == \\old(j)+1) && (l%2 != 0 && l%3 != 0 ==> k == \\old(k)+1);\nloop invariant i7: 0 <= i <= l;\nloop invariant i8: 0 <= j <= l;\nloop invariant i9: 0 <= k <= l;\nloop invariant i10: l%3==0 ==> i==(l/3);\nloop invariant i11: l%3!=0 ==> i==((l/3) + (l%3>1));\nloop invariant i12: l%2==0 ==> j==(l/2);\nloop invariant i13: l%2!=0 ==> j==((l/2) + (l%2>1));\nloop invariant i14: (l%2==0 || l%3==0) ==> k==(l/6);\nloop invariant i15: (l%2!=0 && l%3!=0) ==> k==((l/6) + 1);\nloop invariant i16: (i+j+k) == l;\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k) == l);\n}\n\n  return 0;\n}\n",
        "combined_annotation_num_solver_calls": 5,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint SIZE = 20000001;\n\nint main() {\n  unsigned int n,i,k,j,l=0;\n  n = unknown_uint();\n  if (!(n <= SIZE)) return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l=0;\n  /*@\nloop invariant i1: i >= 0;\nloop invariant i2: j >= 0;\nloop invariant i3: k >= 0;\nloop invariant i4: i+j+k <= l;\nloop invariant i5: l <= n;\n\nloop invariant i7: 0 <= i <= l;\nloop invariant i8: 0 <= j <= l;\nloop invariant i9: 0 <= k <= l;\n\n\n\n\n\n\nloop invariant i16: (i+j+k) == l;\n*/\nwhile( l < n ) {\n\t\n\t  if(!(l%3))\n\t    i = i + 1;\n\t  else if(!(l%2)) \n\t\t  j = j+1;\n\t  else \n\t    k = k+1;\n    l = l+1;\n  }\n  {;\n//@ assert((i+j+k) == l);\n}\n\n  return 0;\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/NetBSD_loop.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/afnp2014.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/css2003.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007b.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gsv2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/hhk2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_2.c",
            "../data/benchmarks/sv-benchmarks/loop-new/gauss_sum.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark01_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark02_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark04_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark05_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark06_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark08_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark10_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark11_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark13_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark14_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark15_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark16_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark17_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark18_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark20_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark21_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark22_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark23_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark25_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark26_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark27_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark29_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark30_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark31_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark32_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark33_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark34_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark35_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark36_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark37_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark38_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark39_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark40_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark41_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark42_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark43_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark45_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark48_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark49_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark50_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark51_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark52_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark53_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum04-2.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_02-2.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/trex03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/while_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/while_infinite_loop_2.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/loopv1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/loopv3.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt2.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/sumt3.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/even.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/mod4.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/odd.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/id_trans.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/bhmr2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/ddlm2013.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gcnr2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gr2006.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_k.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_nondet.c",
            "../data/benchmarks/sv-benchmarks/loop-new/half.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark03_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark07_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark09_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark12_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark19_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark24_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark28_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark44_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark46_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark47_linear.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-2.c",
            "../data/benchmarks/sv-benchmarks/loops/for_bounded_loop1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02_sum01_bug02_base.case.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum04-1.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_02-1.c",
            "../data/benchmarks/sv-benchmarks/loops/terminator_03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/trex03-1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/iftelse.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_10.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_12.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_6.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_8.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_9.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono4_1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono5_1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono6_1.c"
        ],
        "skipped": [],
        "total": 394,
        "success_count": 202,
        "failure_count": 192,
        "success_rate": 0.5126903553299492
    }
}