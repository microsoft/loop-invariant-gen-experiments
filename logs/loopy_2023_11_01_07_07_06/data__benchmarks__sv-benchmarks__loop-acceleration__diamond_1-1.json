{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  while (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  while (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The program does not take any input from the user.\n- The macro `assume(e)` takes a boolean expression `e` and returns 0 if `e` evaluates to false.\n- The function `unknown_uint()` returns an unsigned integer with an unknown value.\n\nVariable assignments:\n- `x` is assigned the value 0.\n- `y` is assigned the value returned by `unknown_uint()`.\n\nLoop condition:\n- The loop continues as long as `x` is less than 99.\n\nWe can start with some loop invariants that hold before the loop execution:\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n*/\n```\n- The first invariant holds because `x` is assigned the value 0 before the loop.\n- The second invariant holds because the loop condition is `x < 99`.\n- The third invariant holds because `unknown_uint()` returns an unsigned integer, which cannot be negative.\n\nNow, we can look at the loop body and try to come up with loop invariants that hold in every iteration of the loop. We can split the loop body into two cases based on the value of `y % 2`:\n```\nif (y % 2 == 0) {\n  x += 2;\n} else {\n  x++;\n}\n```\nCase 1: `y % 2 == 0`\n- `x` increases by 2 in this case. We can add an invariant that captures this relation between `x` and `y`.\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n    loop invariant (y % 2 == 0) ==> ((x - \\at(x, Loop_Entry)) % 2 == 0);\n*/\n```\n- The last invariant holds because if `y` is even, then adding 2 to `x` preserves the parity of `x - \\at(x, Loop_Entry)`.\n\nCase 2: `y % 2 == 1`\n- `x` increases by 1 in this case. We can add an invariant that captures this relation between `x` and `y`.\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n    loop invariant (y % 2 == 1) ==> ((x - \\at(x, Loop_Entry)) % 2 == 1);\n*/\n```\n- The last invariant holds because if `y` is odd, then adding 1 to `x` changes the parity of `x - \\at(x, Loop_Entry)`.\n\nWe can combine the loop invariants that hold in every iteration of the loop:\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n    loop invariant (y % 2 == 0) ==> ((x - \\at(x, Loop_Entry)) % 2 == 0);\n    loop invariant (y % 2 == 1) ==> ((x - \\at(x, Loop_Entry)) % 2 == 1);\n*/\n```\n\nFinally, we need to come up with loop invariants that hold after the loop termination, such that they imply the post-condition. The post-condition is `((x % 2) == (y % 2))`. We can add an invariant that captures this relation between `x` and `y`:\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n    loop invariant (y % 2 == 0) ==> ((x - \\at(x, Loop_Entry)) % 2 == 0);\n    loop invariant (y % 2 == 1) ==> ((x - \\at(x, Loop_Entry)) % 2 == 1);\n    loop invariant (x >= 99) ==> ((x % 2) == (y % 2));\n*/\n```\n- The last invariant holds because if `x` is greater than or equal to 99, then the loop has terminated and `x` has the same parity as `y` (because `x` is even if `y` is even, and `x` is odd if `y` is odd). \n\nWe can combine all the loop invariants into one code block:\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n    loop invariant (y % 2 == 0) ==> ((x - \\at(x, Loop_Entry)) % 2 == 0);\n    loop invariant (y % 2 == 1) ==> ((x - \\at(x,",
            "Pre-conditions:\n- The function `unknown_uint()` returns an unsigned integer value.\n\nVariable Assignments:\n- `x` is initialized to 0.\n- `y` is assigned the return value of the function `unknown_uint()`.\n\nLoop Condition:\n- The loop continues as long as `x` is less than 99.\n\nLoop Invariants:\n- Before the loop, `x` is non-negative and less than or equal to 99. `y` is an unsigned integer and its value is not changed throughout the loop.\n```\n/*@ \n    loop invariant 0 <= x <= 99;\n    loop invariant \\forall unsigned i; i < x ==> (i % 2) == (y % 2);\n*/\n```\n- In every iteration of the loop, either `x` is incremented by 1 or 2. `y` remains the same.\n```\n/*@ \n    loop invariant (x % 2) == (y % 2);\n*/\n```\n- After the loop terminates, the loop condition is false, i.e. `x` is greater than or equal to 99. The final value of `x` is even if and only if `y` is even.\n```\n/*@ \n    loop invariant x >= 99;\n    loop invariant ((x % 2) == (y % 2)) ==> ((x % 2) == 0);\n    loop invariant ((x % 2) != (y % 2)) ==> ((x % 2) == 1);\n    loop invariant ((x % 2) == (y % 2)) || ((x % 2) != (y % 2));\n*/\n```",
            "Pre-conditions or variable assignments:\n- Variable `x` is initialized to 0.\n- Variable `y` is assigned a non-deterministic value using the function `unknown_uint()`.\n\nLoop condition:\n- The loop executes while `x` is less than 99.\n\nLoop invariants:\n- Before the loop execution: None required.\n- In every iteration of the loop:\n    1. `x` is even if and only if `y` is even. (Implication: if `y` is odd, then `x` must be odd in the next iteration because `x` is incremented by 1. If `y` is even, then `x` must be even in the next iteration because `x` is incremented by 2.)\n    2. `x` is less than or equal to 99. (Implication: if `x` is greater than or equal to 99, the loop condition will fail and the loop will terminate.)\n    3. `y` is non-negative. (Given that `y` is an unsigned integer, it is always non-negative.)\n- After the loop termination:\n    1. `x` is even if and only if `y` is even. (Implication: if `y` is odd, then `x` must be odd because the loop has terminated and `x` is incremented by 1 in the last iteration. If `y` is even, then `x` must be even because the loop has terminated and `x` is either incremented by 1 or 2 in the last iteration.)\n    2. `x` is greater than or equal to 99. (Implication: if `x` is less than 99, the loop condition will be true and the loop will continue to execute.)\n    3. `y` is non-negative. (Given that `y` is an unsigned integer, it is always non-negative.)\n\nPutting all the loop invariants together, we get:\n\n```\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x <= 99);\n    loop invariant (y >= 0);\n*/\n\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x <= 99);\n    loop invariant (y >= 0);\n    loop variant (99 - x);\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n}\n\n{;\n//@ assert ((y % 2 == 0) ==> (x % 2 == 0));\n//@ assert ((y % 2 != 0) ==> (x % 2 != 0));\n//@ assert (x <= 99);\n//@ assert (y >= 0);\n} \n\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x >= 99);\n    loop invariant (y >= 0);\n*/\n``` \n\nNote that we have added a loop variant `99 - x` to ensure that the loop will terminate.",
            "Pre-conditions:\n- None\n\nVariable assignments:\n- x is initialized to 0.\n- y is assigned the value returned by the external function unknown_uint().\n\nLoop condition:\n- x < 99\n\nLoop invariants:\n- Before loop execution:\n    - x >= 0\n    - y is non-negative\n- In every iteration:\n    - x <= 99\n    - y is non-negative\n    - If y % 2 == 0, then x is even and x <= 99.\n    - If y % 2 != 0, then x is odd and x <= 99.\n- After loop termination:\n    - x is even if y is even.\n    - x is odd if y is odd.\n    - x <= 99\n    - y is non-negative\n\nPutting all the loop invariants together, we get:\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 99;\n    loop invariant (y % 2 == 0) ==> (x % 2 == 0);\n    loop invariant (y % 2 != 0) ==> (x % 2 != 0);\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n\n    loop assigns x, y;\n*/\n```\n\nNote that we have used implication to take care of the conditional nature of the code. We have also used conjunctions to bound the maximum and minimum values that variables can take, if such bounds exist. Since there are no other variables in the program, we do not need to add any relations between variables.",
            "First, let's analyze the loop body and make a note of the loop condition:\n```\nwhile (x < 99) {\n  if (y % 2 == 0) {\n    x += 2;\n  } else {\n    x++;\n  }\n}\n```\nThe loop continues as long as x is less than 99. Inside the loop, x is either incremented by 2 or 1 depending on whether y is even or odd.\n\nNext, let's identify the pre-conditions and variable assignments in the program:\n- x is assigned the value 0.\n- y is assigned the result of an external function call.\n\nNow, let's derive the loop invariants:\n- Before the loop execution:\n    - x >= 0\n    - y is non-negative (no lower bound can be established for a non-deterministic value)\n- In every iteration of the loop:\n    - x < 99\n    - If y is even, then (x - 2n) % 2 == 0 where n is the number of times x was incremented by 2 so far in the loop iteration.\n    - If y is odd, then (x - n) % 2 == 0 where n is the number of times x was incremented by 1 so far in the loop iteration.\n- After the loop termination:\n    - If y is even, then (x - 2n) % 2 == 0 where n is the maximum number of times x was incremented by 2 in the loop.\n    - If y is odd, then (x - n) % 2 == 0 where n is the maximum number of times x was incremented by 1 in the loop.\n    - x >= 99 ==> (x % 2) == (y % 2)\n\nNote that we cannot establish an upper bound on y, so we cannot use it to derive any loop invariants. Also, since x is initialized to 0, we don't need to add a loop invariant for x >= 0 before the loop.\n\nWe can simplify the loop invariants for even and odd cases using the following observation:\n- If y is even, then x is even before and after each iteration of the loop.\n- If y is odd, then x is odd before and after each iteration of the loop.\n\nUsing this observation, we can derive the following simplified loop invariants:\n- Before the loop execution:\n    - x >= 0\n- In every iteration of the loop:\n    - x < 99\n    - If y is even, then x % 2 == 0\n    - If y is odd, then x % 2 == 1\n- After the loop termination:\n    - x >= 99 ==> (x % 2) == (y % 2)\n\nPutting it all together, we get the following loop invariants:\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x < 99;\n    loop invariant (y % 2 == 0) ==> (x % 2 == 0);\n    loop invariant (y % 2 == 1) ==> (x % 2 == 1);\n    loop invariant x >= 99 ==> (x % 2) == (y % 2);\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n*/",
            "/*@ \n    loop invariant 0 <= x <= 99;\n    loop invariant \\forall unsigned i; i < x ==> (i % 2) == (y % 2);\n*/",
            "/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x <= 99);\n    loop invariant (y >= 0);\n*/\n\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x <= 99);\n    loop invariant (y >= 0);\n    loop variant (99 - x);\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n}\n\n{;\n//@ assert ((y % 2 == 0) ==> (x % 2 == 0));\n//@ assert ((y % 2 != 0) ==> (x % 2 != 0));\n//@ assert (x <= 99);\n//@ assert (y >= 0);\n} \n\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x >= 99);\n    loop invariant (y >= 0);\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 99;\n    loop invariant (y % 2 == 0) ==> (x % 2 == 0);\n    loop invariant (y % 2 != 0) ==> (x % 2 != 0);\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n\n    loop assigns x, y;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant x < 99;\n    loop invariant (y % 2 == 0) ==> (x % 2 == 0);\n    loop invariant (y % 2 == 1) ==> (x % 2 == 1);\n    loop invariant x >= 99 ==> (x % 2) == (y % 2);\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant x >= 0 is partially proven to be inductive.\nloop invariant x <= 99 is established but not preserved.\nloop invariant y >= 0 is partially proven to be inductive.\nAssertion x % 2 == y % 2: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\nloop invariant i1: x >= 0;\n\nloop invariant i3: y >= 0;\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant 0 <= x <= 99;\n    loop invariant \\forall unsigned i; i < x ==> (i % 2) == (y % 2);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= x <= 99 is partially proven to be inductive.\nloop invariant \\forall unsigned i; i < x ==> (i % 2) == (y % 2) is established but not preserved.\nAssertion x % 2 == y % 2: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\n\n\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x <= 99);\n    loop invariant (y >= 0);\n*/\n\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x <= 99);\n    loop invariant (y >= 0);\n    loop variant (99 - x);\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n}\n\n{;\n//@ assert ((y % 2 == 0) ==> (x % 2 == 0));\n//@ assert ((y % 2 != 0) ==> (x % 2 != 0));\n//@ assert (x <= 99);\n//@ assert (y >= 0);\n} \n\n/*@ \n    loop invariant (x % 2 == y % 2);\n    loop invariant (x >= 99);\n    loop invariant (y >= 0);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant (x % 2 == y % 2) is preserved but not established.\nloop invariant (x <= 99) is partially proven to be inductive.\nloop invariant (y >= 0) is partially proven to be inductive.\nloop invariant (x >= 99) is preserved but not established.\nAssertion x % 2 == y % 2: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\n\n\nloop invariant i3: (y >= 0);\n\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 99;\n    loop invariant (y % 2 == 0) ==> (x % 2 == 0);\n    loop invariant (y % 2 != 0) ==> (x % 2 != 0);\n    loop invariant x <= 99;\n    loop invariant y >= 0;\n\n    loop assigns x, y;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant x >= 0 is partially proven to be inductive.\nloop invariant y >= 0 is partially proven to be inductive.\nloop invariant x <= 99 is established but not preserved.\nloop invariant (y % 2 == 0) ==> (x % 2 == 0) is partially proven to be inductive.\nloop invariant (y % 2 != 0) ==> (x % 2 != 0) is neither established nor preserved.\nAssertion x % 2 == y % 2: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\n\nloop invariant i4: (y % 2 == 0) ==> (x % 2 == 0);\n\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant x < 99;\n    loop invariant (y % 2 == 0) ==> (x % 2 == 0);\n    loop invariant (y % 2 == 1) ==> (x % 2 == 1);\n    loop invariant x >= 99 ==> (x % 2) == (y % 2);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant x >= 0 is partially proven to be inductive.\nloop invariant x < 99 is established but not preserved.\nloop invariant (y % 2 == 0) ==> (x % 2 == 0) is partially proven to be inductive.\nloop invariant (y % 2 == 1) ==> (x % 2 == 1) is neither established nor preserved.\nloop invariant x >= 99 ==> (x % 2) == (y % 2) is partially proven to be inductive.\nAssertion x % 2 == y % 2: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\nloop invariant i1: x >= 0;\n\nloop invariant i3: (y % 2 == 0) ==> (x % 2 == 0);\n\nloop invariant i5: x >= 99 ==> (x % 2) == (y % 2);\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
                "checker_output_after_prune": true
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant x >= 0 is partially proven to be inductive.\nloop invariant x <= 99 is partially proven to be inductive.\nloop invariant y >= 0 is partially proven to be inductive.\nloop invariant 0 <= x <= 99 is partially proven to be inductive.\nloop invariant \\forall unsigned i; i < x ==> (i % 2) == (y % 2) is partially proven to be inductive.\nloop invariant (x % 2 == y % 2) is preserved but not established.\nloop invariant (x <= 99) is partially proven to be inductive.\nloop invariant (y >= 0) is partially proven to be inductive.\nloop invariant (x >= 99) is preserved but not established.\nloop invariant (y % 2 == 0) ==> (x % 2 == 0) is partially proven to be inductive.\nloop invariant (y % 2 != 0) ==> (x % 2 != 0) is partially proven to be inductive.\nloop invariant x < 99 is partially proven to be inductive.\nloop invariant (y % 2 == 1) ==> (x % 2 == 1) is partially proven to be inductive.\nloop invariant x >= 99 ==> (x % 2) == (y % 2) is partially proven to be inductive.\nAssertion x % 2 == y % 2: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\nloop invariant i1: x >= 0;\nloop invariant i2: x <= 99;\nloop invariant i3: y >= 0;\nloop invariant i4: 0 <= x <= 99;\nloop invariant i5: \\forall unsigned i; i < x ==> (i % 2) == (y % 2);\nloop invariant i6: (x % 2 == y % 2);\nloop invariant i7: (x <= 99);\nloop invariant i8: (y >= 0);\nloop invariant i9: (x >= 99);\nloop invariant i10: (y % 2 == 0) ==> (x % 2 == 0);\nloop invariant i11: (y % 2 != 0) ==> (x % 2 != 0);\nloop invariant i12: x < 99;\nloop invariant i13: (y % 2 == 1) ==> (x % 2 == 1);\nloop invariant i14: x >= 99 ==> (x % 2) == (y % 2);\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
        "combined_annotation_num_solver_calls": 6,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int x = 0;\n  unsigned int y = unknown_uint();\n\n  /*@\nloop invariant i1: x >= 0;\n\nloop invariant i3: y >= 0;\n\n\n\n\nloop invariant i8: (y >= 0);\n\nloop invariant i10: (y % 2 == 0) ==> (x % 2 == 0);\n\n\n\nloop invariant i14: x >= 99 ==> (x % 2) == (y % 2);\n*/\nwhile (x < 99) {\n    if (y % 2 == 0) {\n      x += 2;\n    } else {\n      x++;\n    }\n  }\n\n  {;\n//@ assert((x % 2) == (y % 2));\n}\n\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c"
        ],
        "skipped": [],
        "total": 251,
        "success_count": 122,
        "failure_count": 129,
        "success_rate": 0.4860557768924303
    }
}