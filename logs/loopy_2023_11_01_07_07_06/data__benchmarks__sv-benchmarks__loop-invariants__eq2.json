{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  while (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  while (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The function main has no input parameters.\n- The function main has a return type of int.\n\nVariable assignments:\n- Variable w is assigned the value returned by the function unknown_uint.\n- Variable x is assigned the value of w.\n- Variable y is assigned the value w+1.\n- Variable z is assigned the value x+1.\n\nLoop condition:\n- The loop continues as long as the function unknown_uint returns a non-zero value.\n\nLoop invariant:\n- Before loop execution: y == z == w + 2\n- In every iteration of the loop: y == z\n- After loop termination: y == z ==> y == z+1\n\nExplanation:\n- Before loop execution, we know that y is initialized to w+1 and z is initialized to x+1, which is equal to w+1 since x is initialized to w. Therefore, y and z are both equal to w+1 before the loop starts. In the first iteration of the loop, both y and z are incremented by 1, so they become w+2. This means that before the loop execution, y and z are both equal to w+2.\n- In every iteration of the loop, y and z are both incremented by 1, so they remain equal to each other.\n- After loop termination, we know that the loop condition is false, which means that the function unknown_uint returned 0. Therefore, the loop did not execute in the last iteration. Since y == z before the loop starts and y and z are incremented by the same amount in each iteration, we know that y == z at the end of the loop. Therefore, if y == z before the loop starts, then y == z+1 after the loop termination.\n\nLoop invariant:\n/*@ \n    loop invariant y == z;\n*/\nThis loop invariant covers the second point mentioned above. \n\nLoop invariant:\n/*@ \n    loop invariant y == z == w + 2;\n*/\nThis loop invariant covers the first point mentioned above.\n\nLoop invariant:\n/*@ \n    loop invariant (y == z) ==> (y == z+1);\n*/\nThis loop invariant covers the third point mentioned above. \n\nCombining all loop invariants:\n```\n/*@ \n    loop invariant y == z == w + 2;\n    loop invariant y == z;\n    loop invariant (y == z) ==> (y == z+1);\n*/\n```",
            "Pre-conditions and Variable Assignments:\n- The program defines a macro `assume` which takes in a boolean expression and returns 0 if the expression is false.\n- There is an external function `unknown_uint` which returns an unsigned integer of unknown value.\n- The program initializes four unsigned integer variables: `w`, `x`, `y`, and `z` with `w` being assigned the value returned by `unknown_uint()` and `x`, `y`, and `z` being assigned `w+1`, `w+1`, and `w+2`, respectively.\n\nLoop Condition:\n- The while loop executes as long as the value returned by `unknown_uint()` is non-zero.\n\nLoop Invariants:\n- The value of `w` remains constant throughout the program execution.\n    ```\n    /*@\n        loop invariant \\forall unsigned int i; i >= 0 && i < \\at(w, Pre) ==> w == \\at(w, i);\n    */\n    ```\n- The value of `x` is always equal to `w+1`.\n    ```\n    /*@\n        loop invariant x == y-1;\n    */\n    ```\n- The value of `y` is always greater than or equal to `w+1` and less than or equal to `z`.\n    ```\n    /*@\n        loop invariant w+1 <= y <= z;\n    */\n    ```\n- The value of `z` is always greater than `w+1` and equal to `y+1` at the end of each iteration.\n    ```\n    /*@\n        loop invariant w+2 <= z;\n        loop invariant z == y+1;\n    */\n    ```\n- The assertion `y == z` is true at the end of the loop execution, assuming that the loop condition is false.\n    ```\n    /*@\n        loop invariant !(unknown_uint()) ==> y == z;\n    */\n    ```\nPutting all the loop invariants together:\n```\n/*@ \n    loop invariant \\forall unsigned int i; i >= 0 && i < \\at(w, Pre) ==> w == \\at(w, i);\n    loop invariant x == y-1;\n    loop invariant w+1 <= y <= z;\n    loop invariant w+2 <= z;\n    loop invariant z == y+1;\n    loop invariant !(unknown_uint()) ==> y == z;\n*/\n```",
            "Pre-conditions:\n- None\n\nVariable Assignments:\n- `w` is assigned the value returned by the function `unknown_uint()`.\n- `x` is assigned the value of `w`.\n- `y` is assigned the value of `w + 1`.\n- `z` is assigned the value of `x + 1`.\n\nLoop Condition:\n- The loop condition is `unknown_uint()`, which means the loop executes an unknown number of times until the condition evaluates to false.\n\nPost-condition:\n- `y` is equal to `z`.\n\nLoop Invariants:\n- Before the loop execution:\n    - `y == w + 1`\n    - `z == x + 1`\n    - `x == w`\n    - `w >= 0`\n    - `y >= w + 1`\n    - `z >= x + 1`\n- In every iteration of the loop:\n    - `y - w == z - x`\n- After the loop termination:\n    - `y == z`\n    - `y >= w + 1`\n    - `z >= x + 1`\n    - `w >= 0`\n\nWe can prove that these loop invariants hold by induction on the number of loop iterations. \n- Before the loop, `y` is assigned `w + 1` and `z` is assigned `x + 1`. We also know that `x` is assigned `w`. Therefore, all the before-loop invariants hold.\n- In every iteration of the loop, `y` and `z` are incremented by the same amount. Therefore, the difference between `y` and `z` remains the same in every iteration, and the invariant `y - w == z - x` holds.\n- After the loop termination, `y` is equal to `z` because of the assertion. We also know that `y >= w + 1` and `z >= x + 1` because they are incremented by at least 1 in every iteration. Therefore, all the after-loop invariants hold.\n\nNote that we did not need to use any implication to handle the non-deterministic nature of the loop condition, because we used the fact that `y` and `z` are incremented by the same amount in every iteration to derive a loop invariant that holds for all iterations.",
            "Pre-conditions: None.\n\nVariable assignments: \n- `w` is assigned the value returned by `unknown_uint()`.\n- `x` is assigned the value of `w`.\n- `y` is assigned the value of `w+1`.\n- `z` is assigned the value of `x+1`.\n\nLoop condition: `unknown_uint()`\n\nPost-condition: `y == z`\n\nLoop invariants:\n- `y == w + (z-x)`\n- `z == w + 1 + (iteration_count+1)`\n- `y >= w + (iteration_count+1)`\n- `z >= w + 1 + (iteration_count+1)`\n- `y <= w + (iteration_count+1) + 1`\n- `z <= w + 1 + (iteration_count+1) + 1`\n- `iteration_count >= 0`\n\nExplanation:\n- The first invariant is true before the loop since `z = x+1` and `y = w+1`, and in every iteration of the loop, `y` is incremented by 1 and `z` is incremented by 1, but `x` remains constant. Therefore, the difference between `z` and `x` remains constant, which is `(iteration_count+1)`. Therefore, `y` is equal to `w` plus this constant difference, which is equivalent to `y == w + (z-x)`.\n- The second and third invariants are true in every iteration of the loop since `z` is incremented by 1 and `y` is incremented by 1, and `iteration_count` is incremented by 1 due to the loop condition. Therefore, `z` is equal to `w + 1` plus the sum of the loop iteration count and 1, which is equivalent to `z == w + 1 + (iteration_count+1)`. Also, `y` is greater than or equal to `w` plus the sum of the loop iteration count and 1, which is equivalent to `y >= w + (iteration_count+1)`.\n- The fourth and fifth invariants are true in every iteration of the loop since `z` and `y` are incremented by 1 in every iteration of the loop, and `iteration_count` is incremented by 1 due to the loop condition. Therefore, `z` is less than or equal to `w + 1` plus the sum of the loop iteration count and 2, which is equivalent to `z <= w + 1 + (iteration_count+1) + 1`. Also, `y` is less than or equal to `w` plus the sum of the loop iteration count and 2, which is equivalent to `y <= w + (iteration_count+1) + 1`.\n- The sixth invariant is true at the end of the loop since `iteration_count` is always greater than or equal to 0.\n\nTherefore, the final loop invariants are:\n```\n/*@ \n    loop invariant y == w + (z-x);\n    loop invariant z == w + 1 + (iteration_count+1);\n    loop invariant y >= w + (iteration_count+1);\n    loop invariant z >= w + 1 + (iteration_count+1);\n    loop invariant y <= w + (iteration_count+1) + 1;\n    loop invariant z <= w + 1 + (iteration_count+1) + 1;\n    loop invariant iteration_count >= 0;\n*/\n```",
            "Pre-conditions:\n- None\n\nVariable assignments:\n- Assign a non-deterministic value to unsigned int variable w.\n- Assign the value of w to unsigned int variable x.\n- Assign the value of w+1 to unsigned int variable y.\n- Assign the value of x+1 to unsigned int variable z.\n\nLoop condition:\n- The loop runs as long as the value returned by the function unknown_uint() is non-zero.\n\nLoop invariants:\n- Before the loop execution:\n```\n//@ assert y == x + (unknown_uint() ? 1 : 0);\n//@ assert z == x + 1;\n```\nExplanation: Before the loop starts, y is initialized to w+1 and z is initialized to x+1. Since the loop condition is unknown_uint(), which returns a non-zero value, we can assume that the loop will execute at least once. Therefore, the value of y will be incremented by 1 in the first iteration, making it equal to x+1, plus an additional 1 if the loop executes again. Similarly, the value of z will be incremented by 1 in the first iteration, making it equal to x+2, minus 1 if the loop executes again. Therefore, the above loop invariants hold before the loop execution.\n\n- In every iteration of the loop:\n```\n//@ assert y == z;\n```\nExplanation: In each iteration of the loop, the values of y and z are incremented by 1. Therefore, the above loop invariant holds in every iteration of the loop.\n\n- After the loop termination:\n```\n//@ assert y == x + (z - x);\n```\nExplanation: After the loop terminates, the value of y will be equal to the initial value of y plus the number of times the loop executed, which is equal to the value of z-x. Therefore, the above loop invariant holds after the loop termination. \n\nNote: Since the value returned by unknown_uint() is non-deterministic, we cannot make any assumptions about the values of y and z at the end of the loop. Therefore, we use an implication to make the loop invariant trivially true at the end of the loop:\n```\n//@ assert unknown_uint() == 0 ==> y == z;\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant y == z == w + 2;\n    loop invariant y == z;\n    loop invariant (y == z) ==> (y == z+1);\n*/",
            "    /*@\n        loop invariant \\forall unsigned int i; i >= 0 && i < \\at(w, Pre) ==> w == \\at(w, i);\n    */",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None\n\nVariable Assignments:\n- `w` is assigned the value returned by the function `unknown_uint()`.\n- `x` is assigned the value of `w`.\n- `y` is assigned the value of `w + 1`.\n- `z` is assigned the value of `x + 1`.\n\nLoop Condition:\n- The loop condition is `unknown_uint()`, which means the loop executes an unknown number of times until the condition evaluates to false.\n\nPost-condition:\n- `y` is equal to `z`.\n\nLoop Invariants:\n- Before the loop execution:\n    - `y == w + 1`\n    - `z == x + 1`\n    - `x == w`\n    - `w >= 0`\n    - `y >= w + 1`\n    - `z >= x + 1`\n- In every iteration of the loop:\n    - `y - w == z - x`\n- After the loop termination:\n    - `y == z`\n    - `y >= w + 1`\n    - `z >= x + 1`\n    - `w >= 0`\n\nWe can prove that these loop invariants hold by induction on the number of loop iterations. \n- Before the loop, `y` is assigned `w + 1` and `z` is assigned `x + 1`. We also know that `x` is assigned `w`. Therefore, all the before-loop invariants hold.\n- In every iteration of the loop, `y` and `z` are incremented by the same amount. Therefore, the difference between `y` and `z` remains the same in every iteration, and the invariant `y - w == z - x` holds.\n- After the loop termination, `y` is equal to `z` because of the assertion. We also know that `y >= w + 1` and `z >= x + 1` because they are incremented by at least 1 in every iteration. Therefore, all the after-loop invariants hold.\n\nNote that we did not need to use any implication to handle the non-deterministic nature of the loop condition, because we used the fact that `y` and `z` are incremented by the same amount in every iteration to derive a loop invariant that holds for all iterations."
            ],
            "/*@ \n    loop invariant y == w + (z-x);\n    loop invariant z == w + 1 + (iteration_count+1);\n    loop invariant y >= w + (iteration_count+1);\n    loop invariant z >= w + 1 + (iteration_count+1);\n    loop invariant y <= w + (iteration_count+1) + 1;\n    loop invariant z <= w + 1 + (iteration_count+1) + 1;\n    loop invariant iteration_count >= 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None\n\nVariable assignments:\n- Assign a non-deterministic value to unsigned int variable w.\n- Assign the value of w to unsigned int variable x.\n- Assign the value of w+1 to unsigned int variable y.\n- Assign the value of x+1 to unsigned int variable z.\n\nLoop condition:\n- The loop runs as long as the value returned by the function unknown_uint() is non-zero.\n\nLoop invariants:\n- Before the loop execution:\n```\n//@ assert y == x + (unknown_uint() ? 1 : 0);\n//@ assert z == x + 1;\n```\nExplanation: Before the loop starts, y is initialized to w+1 and z is initialized to x+1. Since the loop condition is unknown_uint(), which returns a non-zero value, we can assume that the loop will execute at least once. Therefore, the value of y will be incremented by 1 in the first iteration, making it equal to x+1, plus an additional 1 if the loop executes again. Similarly, the value of z will be incremented by 1 in the first iteration, making it equal to x+2, minus 1 if the loop executes again. Therefore, the above loop invariants hold before the loop execution.\n\n- In every iteration of the loop:\n```\n//@ assert y == z;\n```\nExplanation: In each iteration of the loop, the values of y and z are incremented by 1. Therefore, the above loop invariant holds in every iteration of the loop.\n\n- After the loop termination:\n```\n//@ assert y == x + (z - x);\n```\nExplanation: After the loop terminates, the value of y will be equal to the initial value of y plus the number of times the loop executed, which is equal to the value of z-x. Therefore, the above loop invariant holds after the loop termination. \n\nNote: Since the value returned by unknown_uint() is non-deterministic, we cannot make any assumptions about the values of y and z at the end of the loop. Therefore, we use an implication to make the loop invariant trivially true at the end of the loop:\n```\n//@ assert unknown_uint() == 0 ==> y == z;\n```"
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant y == z == w + 2;\n    loop invariant y == z;\n    loop invariant (y == z) ==> (y == z+1);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant y == z == w + 2 is preserved but not established.\nloop invariant y == z is partially proven to be inductive.\nloop invariant (y == z) ==> (y == z+1) is preserved but not established.\nAssertion y == z: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  /*@\n\nloop invariant i2: y == z;\n\n*/\nwhile (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "    /*@\n        loop invariant \\forall unsigned int i; i >= 0 && i < \\at(w, Pre) ==> w == \\at(w, i);\n    */",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 10: logic label `i' not found. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  /*@\n\n*/\nwhile (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None\n\nVariable Assignments:\n- `w` is assigned the value returned by the function `unknown_uint()`.\n- `x` is assigned the value of `w`.\n- `y` is assigned the value of `w + 1`.\n- `z` is assigned the value of `x + 1`.\n\nLoop Condition:\n- The loop condition is `unknown_uint()`, which means the loop executes an unknown number of times until the condition evaluates to false.\n\nPost-condition:\n- `y` is equal to `z`.\n\nLoop Invariants:\n- Before the loop execution:\n    - `y == w + 1`\n    - `z == x + 1`\n    - `x == w`\n    - `w >= 0`\n    - `y >= w + 1`\n    - `z >= x + 1`\n- In every iteration of the loop:\n    - `y - w == z - x`\n- After the loop termination:\n    - `y == z`\n    - `y >= w + 1`\n    - `z >= x + 1`\n    - `w >= 0`\n\nWe can prove that these loop invariants hold by induction on the number of loop iterations. \n- Before the loop, `y` is assigned `w + 1` and `z` is assigned `x + 1`. We also know that `x` is assigned `w`. Therefore, all the before-loop invariants hold.\n- In every iteration of the loop, `y` and `z` are incremented by the same amount. Therefore, the difference between `y` and `z` remains the same in every iteration, and the invariant `y - w == z - x` holds.\n- After the loop termination, `y` is equal to `z` because of the assertion. We also know that `y >= w + 1` and `z >= x + 1` because they are incremented by at least 1 in every iteration. Therefore, all the after-loop invariants hold.\n\nNote that we did not need to use any implication to handle the non-deterministic nature of the loop condition, because we used the fact that `y` and `z` are incremented by the same amount in every iteration to derive a loop invariant that holds for all iterations.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 8,
                "annotations": "/*@ \n    loop invariant y == w + (z-x);\n    loop invariant z == w + 1 + (iteration_count+1);\n    loop invariant y >= w + (iteration_count+1);\n    loop invariant z >= w + 1 + (iteration_count+1);\n    loop invariant y <= w + (iteration_count+1) + 1;\n    loop invariant z <= w + 1 + (iteration_count+1) + 1;\n    loop invariant iteration_count >= 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 11: unbound logic variable iteration_count. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  /*@\n\n\n\n\n\n\n\n*/\nwhile (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None\n\nVariable assignments:\n- Assign a non-deterministic value to unsigned int variable w.\n- Assign the value of w to unsigned int variable x.\n- Assign the value of w+1 to unsigned int variable y.\n- Assign the value of x+1 to unsigned int variable z.\n\nLoop condition:\n- The loop runs as long as the value returned by the function unknown_uint() is non-zero.\n\nLoop invariants:\n- Before the loop execution:\n```\n//@ assert y == x + (unknown_uint() ? 1 : 0);\n//@ assert z == x + 1;\n```\nExplanation: Before the loop starts, y is initialized to w+1 and z is initialized to x+1. Since the loop condition is unknown_uint(), which returns a non-zero value, we can assume that the loop will execute at least once. Therefore, the value of y will be incremented by 1 in the first iteration, making it equal to x+1, plus an additional 1 if the loop executes again. Similarly, the value of z will be incremented by 1 in the first iteration, making it equal to x+2, minus 1 if the loop executes again. Therefore, the above loop invariants hold before the loop execution.\n\n- In every iteration of the loop:\n```\n//@ assert y == z;\n```\nExplanation: In each iteration of the loop, the values of y and z are incremented by 1. Therefore, the above loop invariant holds in every iteration of the loop.\n\n- After the loop termination:\n```\n//@ assert y == x + (z - x);\n```\nExplanation: After the loop terminates, the value of y will be equal to the initial value of y plus the number of times the loop executed, which is equal to the value of z-x. Therefore, the above loop invariant holds after the loop termination. \n\nNote: Since the value returned by unknown_uint() is non-deterministic, we cannot make any assumptions about the values of y and z at the end of the loop. Therefore, we use an implication to make the loop invariant trivially true at the end of the loop:\n```\n//@ assert unknown_uint() == 0 ==> y == z;\n```",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 13: logic label `i' not found. Ignoring loop annotation",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  /*@\nloop invariant i1: y == z == w + 2;\nloop invariant i2: y == z;\nloop invariant i3: (y == z) ==> (y == z+1);\nloop invariant i4: \\forall unsigned int i; i >= 0 && i < \\at(w, Pre) ==> w == \\at(w, i);\nloop invariant i5: y == w + (z-x);\nloop invariant i6: z == w + 1 + (iteration_count+1);\nloop invariant i7: y >= w + (iteration_count+1);\nloop invariant i8: z >= w + 1 + (iteration_count+1);\nloop invariant i9: y <= w + (iteration_count+1) + 1;\nloop invariant i10: z <= w + 1 + (iteration_count+1) + 1;\nloop invariant i11: iteration_count >= 0;\n*/\nwhile (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}",
        "combined_annotation_num_solver_calls": 9,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\nint main(void) {\n  unsigned int w = unknown_uint();\n  unsigned int x = w;\n  unsigned int y = w + 1;\n  unsigned int z = x + 1;\n  /*@\n\nloop invariant i2: y == z;\n\n\nloop invariant i5: y == w + (z-x);\n\n\n\n\n\n\n*/\nwhile (unknown_uint()) {\n    y++;\n    z++;\n  }\n  {;\n//@ assert(y == z);\n}\n\n  return 0;\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c"
        ],
        "skipped": [],
        "total": 279,
        "success_count": 134,
        "failure_count": 145,
        "success_rate": 0.48028673835125446
    }
}