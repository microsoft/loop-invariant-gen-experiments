{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark24_conjunctive.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  while (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  while (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- The values of `i`, `k`, and `n` are non-deterministic integers.\n- The values of `i`, `k`, and `n` satisfy the condition `i==0 && k==n && n>=0`.\n\nLoop condition:\n- The loop executes while `i<n`.\n\nPost-condition:\n- The value of `2*k` is greater than or equal to `n-1`.\n\nLoop invariants:\n```\n/*@\n    loop invariant 0 <= i <= n;\n    loop invariant 0 <= k <= n;\n    loop invariant i%2 == 0;\n    loop invariant k+n == 2*(i+n);\n    loop invariant i/2 <= k;\n    loop invariant ((i<n) ==> (2*k >= n-1));\n*/\n```\n\nExplanation:\n- The loop invariant `0 <= i <= n;` ensures that `i` is always within the range `[0,n]`.\n- The loop invariant `0 <= k <= n;` ensures that `k` is always within the range `[0,n]`.\n- The loop invariant `i%2 == 0;` ensures that `i` is always an even number.\n- The loop invariant `k+n == 2*(i+n);` ensures that the sum of `k` and `n` is always twice the sum of `i` and `n`. This implies that `k` and `i` are moving in opposite directions with respect to `n`.\n- The loop invariant `i/2 <= k;` ensures that `k` is always greater than or equal to `i/2`.\n- The loop invariant `((i<n) ==> (2*k >= n-1));` ensures that the post-condition is satisfied whenever the loop exits. This invariant is only applicable when `i<n`, which is the loop condition. When `i>=n`, the loop exits and the post-condition is automatically satisfied.",
            "Pre-conditions:\n- Variables `i`, `k`, and `n` are initialized with non-deterministic values.\n\nVariable bounds:\n- `n` is greater than or equal to 0.\n\nLoop condition:\n- `i` is less than `n`.\n\nLoop invariants:\n- Before the loop: `i == 0 && k == n && n >= 0`\n- In every iteration: `(i % 2 == 0) && (i <= n) && (k >= (n - i) / 2)`\n- After the loop: `2 * k >= n - 1`\n\nExplanation:\n- Before the loop: This invariant ensures that the initial values of `i`, `k`, and `n` are such that `i` is 0, `k` is equal to `n`, and `n` is greater than or equal to 0.\n- In every iteration: \n    - `(i % 2 == 0)` ensures that `i` is always even in every iteration.\n    - `(i <= n)` ensures that the loop terminates when `i` becomes equal to `n`.\n    - `(k >= (n - i) / 2)` ensures that `k` is always greater than or equal to `(n - i) / 2` in every iteration.\n- After the loop: This invariant ensures that the final value of `k` satisfies the required condition that `2 * k` is greater than or equal to `n - 1`.\n\nUsing these loop invariants, we can verify that the assertion `2 * k >= n - 1` holds after the loop termination.",
            "First, let's consider the pre-conditions or variable assignments in the program:\n- `i` is assigned the value of a non-deterministic function call\n- `k` is assigned the value of a non-deterministic function call\n- `n` is assigned the value of a non-deterministic function call\n- The program checks if `i` is 0, `k` is `n`, and `n` is non-negative. If this condition is false, the program returns 0.\n\nFrom this, we can derive the following loop invariant before the loop execution:\n- `i` is non-negative\n\nNow, let's analyze the loop body and make a note of the loop condition:\n- The loop runs while `i` is less than `n`\n\nFrom this, we can derive the following loop invariant in every iteration of the loop:\n- `i` is less than or equal to `n`\n\nNow, let's consider the post-condition:\n- `2*k` is greater than or equal to `n-1`\n\nFrom this, we can derive the following loop invariant after the loop termination:\n- `2*k` is greater than or equal to `n-1`\n\nCombining all of these, we have the following loop invariants:\n```\n/*@ \n    loop invariant i >= 0;\n    loop invariant i <= n;\n    loop invariant 2*k >= n-1;\n*/\n```\nNote that we do not need to add any implications or conjunctions because all variables are assigned values at the beginning and the loop condition and post-condition do not have any additional conditions to consider.",
            "Let's start by analyzing the program and the loop.\n\n**Pre-conditions and variable assignments:**\n\n- `i`, `k`, and `n` are initialized with the result of `unknown_int()` function calls.\n- `n` is non-negative.\n- `i` is zero.\n- `k` is equal to `n`.\n\n**Loop condition:**\n\n- `i < n`\n\n**Post-condition:**\n\n- `2*k >= n-1`\n\n**Loop invariants:**\n\n- Before the loop execution:\n    - `i == 0`\n    - `k == n`\n    - `n >= 0`\n- In every iteration of the loop:\n    - `i < n`\n    - `k <= n`\n    - `k >= 0`\n- After the loop termination:\n    - `2*k >= n-1`\n\nLet's explain each of the loop invariants in more detail:\n\n- Before the loop execution:\n    - `i == 0` ensures that the loop starts with the correct initial value for `i`.\n    - `k == n` ensures that the loop starts with the correct initial value for `k`.\n    - `n >= 0` is a pre-condition that we should include as a loop invariant to ensure that `n` remains non-negative throughout the loop execution.\n- In every iteration of the loop:\n    - `i < n` ensures that the loop terminates when `i` reaches `n`.\n    - `k <= n` is a bound on `k` to ensure that it does not exceed `n`.\n    - `k >= 0` is a bound on `k` to ensure that it remains non-negative throughout the loop execution.\n- After the loop termination:\n    - `2*k >= n-1` is the post-condition that we want to verify. This is the implication of the loop invariant that if the loop terminates, then the post-condition holds.\n\nNote that we do not need to add any loop invariant for the non-deterministic variables `i`, `k`, and `n`, as we are only interested in their relations and bounds.\n\nTherefore, the complete set of loop invariants for the given program is:\n\n```\n/*@ \n    loop invariant i == 0;\n    loop invariant k == n;\n    loop invariant n >= 0;\n    loop invariant i < n;\n    loop invariant k <= n;\n    loop invariant k >= 0;\n    loop invariant 2*k >= n-1;\n*/\n```",
            "First, let's analyze the program and make a note of the pre-conditions and variable assignments:\n\n- Pre-conditions:\n  - i == 0\n  - k == n\n  - n >= 0\n\n- Variable assignments:\n  - i = unknown_int()\n  - k = unknown_int()\n  - n = unknown_int()\n\nNext, let's analyze the loop body and make a note of the loop condition:\n\n- Loop condition:\n  - i < n\n\nNow, let's output the necessary loop invariants:\n\n/*@ \n  loop invariant 0 <= i <= n;\n  loop invariant k <= n;\n  loop invariant (n-i)%2 == 0;\n  loop invariant k+i == n;\n  loop invariant 2*k+i >= n-1 ==> k >= 0;\n*/\n\nExplanation:\n\n- The first loop invariant states that i always stays within the bounds of 0 and n, which is the range of values that i can take.\n- The second loop invariant states that k is always less than or equal to n, which is the upper bound on the value of k.\n- The third loop invariant states that the difference between n and i is always an even number. This is because in each iteration of the loop, i increases by 2, so the difference between n and i must also be a multiple of 2.\n- The fourth loop invariant states that the sum of i and k is always equal to n, which is a condition that is true before and after each iteration of the loop. This is because in each iteration of the loop, k decreases by 1 and i increases by 2, so the sum of i and k remains constant.\n- The fifth loop invariant states that if the assertion (2*k >= n-1) holds, then k must be greater than or equal to 0. This is because the assertion implies that 2*k+i is greater than or equal to n, which means that k must be at least (n-i)/2. Since (n-i) is even (as per the third loop invariant), (n-i)/2 is an integer, and hence k must be greater than or equal to 0. Note that if the assertion does not hold, then this loop invariant is trivially true.\n\nFinally, we can use these loop invariants to verify the post-condition:\n- Before the loop execution, all loop invariants are true because i, k and n are initialized to values that satisfy the pre-conditions.\n- In every iteration of the loop, all loop invariants except the fourth one are preserved. The fourth loop invariant is updated in each iteration because i and k change values.\n- After the loop termination, we can use the loop invariants to prove the post-condition. Specifically, we can use the fourth and fifth loop invariants to derive the post-condition. The fourth loop invariant implies that i is equal to n-k after the loop termination. Substituting this value of i in the assertion (2*k >= n-1) gives us 2*k >= 2*k, which is always true. Therefore, the assertion holds after the loop termination."
        ],
        "annotation_blocks": [
            "/*@\n    loop invariant 0 <= i <= n;\n    loop invariant 0 <= k <= n;\n    loop invariant i%2 == 0;\n    loop invariant k+n == 2*(i+n);\n    loop invariant i/2 <= k;\n    loop invariant ((i<n) ==> (2*k >= n-1));\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- Variables `i`, `k`, and `n` are initialized with non-deterministic values.\n\nVariable bounds:\n- `n` is greater than or equal to 0.\n\nLoop condition:\n- `i` is less than `n`.\n\nLoop invariants:\n- Before the loop: `i == 0 && k == n && n >= 0`\n- In every iteration: `(i % 2 == 0) && (i <= n) && (k >= (n - i) / 2)`\n- After the loop: `2 * k >= n - 1`\n\nExplanation:\n- Before the loop: This invariant ensures that the initial values of `i`, `k`, and `n` are such that `i` is 0, `k` is equal to `n`, and `n` is greater than or equal to 0.\n- In every iteration: \n    - `(i % 2 == 0)` ensures that `i` is always even in every iteration.\n    - `(i <= n)` ensures that the loop terminates when `i` becomes equal to `n`.\n    - `(k >= (n - i) / 2)` ensures that `k` is always greater than or equal to `(n - i) / 2` in every iteration.\n- After the loop: This invariant ensures that the final value of `k` satisfies the required condition that `2 * k` is greater than or equal to `n - 1`.\n\nUsing these loop invariants, we can verify that the assertion `2 * k >= n - 1` holds after the loop termination."
            ],
            "/*@ \n    loop invariant i >= 0;\n    loop invariant i <= n;\n    loop invariant 2*k >= n-1;\n*/",
            "/*@ \n    loop invariant i == 0;\n    loop invariant k == n;\n    loop invariant n >= 0;\n    loop invariant i < n;\n    loop invariant k <= n;\n    loop invariant k >= 0;\n    loop invariant 2*k >= n-1;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "First, let's analyze the program and make a note of the pre-conditions and variable assignments:\n\n- Pre-conditions:\n  - i == 0\n  - k == n\n  - n >= 0\n\n- Variable assignments:\n  - i = unknown_int()\n  - k = unknown_int()\n  - n = unknown_int()\n\nNext, let's analyze the loop body and make a note of the loop condition:\n\n- Loop condition:\n  - i < n\n\nNow, let's output the necessary loop invariants:\n\n/*@ \n  loop invariant 0 <= i <= n;\n  loop invariant k <= n;\n  loop invariant (n-i)%2 == 0;\n  loop invariant k+i == n;\n  loop invariant 2*k+i >= n-1 ==> k >= 0;\n*/\n\nExplanation:\n\n- The first loop invariant states that i always stays within the bounds of 0 and n, which is the range of values that i can take.\n- The second loop invariant states that k is always less than or equal to n, which is the upper bound on the value of k.\n- The third loop invariant states that the difference between n and i is always an even number. This is because in each iteration of the loop, i increases by 2, so the difference between n and i must also be a multiple of 2.\n- The fourth loop invariant states that the sum of i and k is always equal to n, which is a condition that is true before and after each iteration of the loop. This is because in each iteration of the loop, k decreases by 1 and i increases by 2, so the sum of i and k remains constant.\n- The fifth loop invariant states that if the assertion (2*k >= n-1) holds, then k must be greater than or equal to 0. This is because the assertion implies that 2*k+i is greater than or equal to n, which means that k must be at least (n-i)/2. Since (n-i) is even (as per the third loop invariant), (n-i)/2 is an integer, and hence k must be greater than or equal to 0. Note that if the assertion does not hold, then this loop invariant is trivially true.\n\nFinally, we can use these loop invariants to verify the post-condition:\n- Before the loop execution, all loop invariants are true because i, k and n are initialized to values that satisfy the pre-conditions.\n- In every iteration of the loop, all loop invariants except the fourth one are preserved. The fourth loop invariant is updated in each iteration because i and k change values.\n- After the loop termination, we can use the loop invariants to prove the post-condition. Specifically, we can use the fourth and fifth loop invariants to derive the post-condition. The fourth loop invariant implies that i is equal to n-k after the loop termination. Substituting this value of i in the assertion (2*k >= n-1) gives us 2*k >= 2*k, which is always true. Therefore, the assertion holds after the loop termination."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 4,
                "annotations": "/*@\n    loop invariant 0 <= i <= n;\n    loop invariant 0 <= k <= n;\n    loop invariant i%2 == 0;\n    loop invariant k+n == 2*(i+n);\n    loop invariant i/2 <= k;\n    loop invariant ((i<n) ==> (2*k >= n-1));\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= i <= n is established but not preserved.\nloop invariant 0 <= k <= n is partially proven to be inductive.\nloop invariant i%2 == 0 is partially proven to be inductive.\nloop invariant k+n == 2*(i+n) is established but not preserved.\nloop invariant i/2 <= k is partially proven to be inductive.\nloop invariant ((i<n) ==> (2*k >= n-1)) is partially proven to be inductive.\nAssertion 2 * k >= n - 1: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  /*@\n\n\nloop invariant i3: i%2 == 0;\n\n\n\n*/\nwhile (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- Variables `i`, `k`, and `n` are initialized with non-deterministic values.\n\nVariable bounds:\n- `n` is greater than or equal to 0.\n\nLoop condition:\n- `i` is less than `n`.\n\nLoop invariants:\n- Before the loop: `i == 0 && k == n && n >= 0`\n- In every iteration: `(i % 2 == 0) && (i <= n) && (k >= (n - i) / 2)`\n- After the loop: `2 * k >= n - 1`\n\nExplanation:\n- Before the loop: This invariant ensures that the initial values of `i`, `k`, and `n` are such that `i` is 0, `k` is equal to `n`, and `n` is greater than or equal to 0.\n- In every iteration: \n    - `(i % 2 == 0)` ensures that `i` is always even in every iteration.\n    - `(i <= n)` ensures that the loop terminates when `i` becomes equal to `n`.\n    - `(k >= (n - i) / 2)` ensures that `k` is always greater than or equal to `(n - i) / 2` in every iteration.\n- After the loop: This invariant ensures that the final value of `k` satisfies the required condition that `2 * k` is greater than or equal to `n - 1`.\n\nUsing these loop invariants, we can verify that the assertion `2 * k >= n - 1` holds after the loop termination.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant i >= 0;\n    loop invariant i <= n;\n    loop invariant 2*k >= n-1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i >= 0 is partially proven to be inductive.\nloop invariant i <= n is established but not preserved.\nloop invariant 2*k >= n-1 is established but not preserved.\nAssertion 2 * k >= n - 1: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  /*@\nloop invariant i1: i >= 0;\n\n\n*/\nwhile (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 5,
                "annotations": "/*@ \n    loop invariant i == 0;\n    loop invariant k == n;\n    loop invariant n >= 0;\n    loop invariant i < n;\n    loop invariant k <= n;\n    loop invariant k >= 0;\n    loop invariant 2*k >= n-1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant i == 0 is established but not preserved.\nloop invariant k == n is partially proven to be inductive.\nloop invariant n >= 0 is partially proven to be inductive.\nloop invariant i < n is preserved but not established.\nloop invariant k <= n is partially proven to be inductive.\nloop invariant k >= 0 is partially proven to be inductive.\nloop invariant 2*k >= n-1 is partially proven to be inductive.\nAssertion 2 * k >= n - 1: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  /*@\n\n\nloop invariant i3: n >= 0;\n\nloop invariant i5: k <= n;\n\n\n*/\nwhile (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "First, let's analyze the program and make a note of the pre-conditions and variable assignments:\n\n- Pre-conditions:\n  - i == 0\n  - k == n\n  - n >= 0\n\n- Variable assignments:\n  - i = unknown_int()\n  - k = unknown_int()\n  - n = unknown_int()\n\nNext, let's analyze the loop body and make a note of the loop condition:\n\n- Loop condition:\n  - i < n\n\nNow, let's output the necessary loop invariants:\n\n/*@ \n  loop invariant 0 <= i <= n;\n  loop invariant k <= n;\n  loop invariant (n-i)%2 == 0;\n  loop invariant k+i == n;\n  loop invariant 2*k+i >= n-1 ==> k >= 0;\n*/\n\nExplanation:\n\n- The first loop invariant states that i always stays within the bounds of 0 and n, which is the range of values that i can take.\n- The second loop invariant states that k is always less than or equal to n, which is the upper bound on the value of k.\n- The third loop invariant states that the difference between n and i is always an even number. This is because in each iteration of the loop, i increases by 2, so the difference between n and i must also be a multiple of 2.\n- The fourth loop invariant states that the sum of i and k is always equal to n, which is a condition that is true before and after each iteration of the loop. This is because in each iteration of the loop, k decreases by 1 and i increases by 2, so the sum of i and k remains constant.\n- The fifth loop invariant states that if the assertion (2*k >= n-1) holds, then k must be greater than or equal to 0. This is because the assertion implies that 2*k+i is greater than or equal to n, which means that k must be at least (n-i)/2. Since (n-i) is even (as per the third loop invariant), (n-i)/2 is an integer, and hence k must be greater than or equal to 0. Note that if the assertion does not hold, then this loop invariant is trivially true.\n\nFinally, we can use these loop invariants to verify the post-condition:\n- Before the loop execution, all loop invariants are true because i, k and n are initialized to values that satisfy the pre-conditions.\n- In every iteration of the loop, all loop invariants except the fourth one are preserved. The fourth loop invariant is updated in each iteration because i and k change values.\n- After the loop termination, we can use the loop invariants to prove the post-condition. Specifically, we can use the fourth and fifth loop invariants to derive the post-condition. The fourth loop invariant implies that i is equal to n-k after the loop termination. Substituting this value of i in the assertion (2*k >= n-1) gives us 2*k >= 2*k, which is always true. Therefore, the assertion holds after the loop termination.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant 0 <= i <= n is established but not preserved.\nloop invariant 0 <= k <= n is partially proven to be inductive.\nloop invariant i%2 == 0 is partially proven to be inductive.\nloop invariant k+n == 2*(i+n) is established but not preserved.\nloop invariant i/2 <= k is partially proven to be inductive.\nloop invariant ((i<n) ==> (2*k >= n-1)) is partially proven to be inductive.\nloop invariant i >= 0 is partially proven to be inductive.\nloop invariant i <= n is partially proven to be inductive.\nloop invariant 2*k >= n-1 is partially proven to be inductive.\nloop invariant i == 0 is partially proven to be inductive.\nloop invariant k == n is partially proven to be inductive.\nloop invariant n >= 0 is partially proven to be inductive.\nloop invariant i < n is preserved but not established.\nloop invariant k <= n is partially proven to be inductive.\nloop invariant k >= 0 is partially proven to be inductive.\nAssertion 2 * k >= n - 1: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  /*@\nloop invariant i1: 0 <= i <= n;\nloop invariant i2: 0 <= k <= n;\nloop invariant i3: i%2 == 0;\nloop invariant i4: k+n == 2*(i+n);\nloop invariant i5: i/2 <= k;\nloop invariant i6: ((i<n) ==> (2*k >= n-1));\nloop invariant i7: i >= 0;\nloop invariant i8: i <= n;\nloop invariant i9: 2*k >= n-1;\nloop invariant i10: i == 0;\nloop invariant i11: k == n;\nloop invariant i12: n >= 0;\nloop invariant i13: i < n;\nloop invariant i14: k <= n;\nloop invariant i15: k >= 0;\n*/\nwhile (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}",
        "combined_annotation_num_solver_calls": 7,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\n#include <assert.h>\n\nint main() {\n  int i = unknown_int();\n  int k = unknown_int();\n  int n = unknown_int();\n  \n  if (!(i==0 && k==n && n>=0)) return 0;\n  /*@\n\n\nloop invariant i3: i%2 == 0;\n\n\n\nloop invariant i7: i >= 0;\n\n\n\n\nloop invariant i12: n >= 0;\n\nloop invariant i14: k <= n;\n\n*/\nwhile (i<n) {\n    k--;\n    i+=2;\n  }\n  {;\n//@ assert(2*k>=n-1);\n}\n\n  return 0;\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/NetBSD_loop.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/afnp2014.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/css2003.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007b.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gsv2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/hhk2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_2.c",
            "../data/benchmarks/sv-benchmarks/loop-new/gauss_sum.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark01_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark02_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark04_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark05_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark06_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark08_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark10_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark11_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark13_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark14_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark15_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark16_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark17_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark18_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark20_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark21_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark22_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark23_conjunctive.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/even.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/mod4.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/odd.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/id_trans.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/bhmr2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/ddlm2013.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gcnr2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gr2006.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_k.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_nondet.c",
            "../data/benchmarks/sv-benchmarks/loop-new/half.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark03_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark07_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark09_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark12_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark19_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark24_conjunctive.c"
        ],
        "skipped": [],
        "total": 331,
        "success_count": 164,
        "failure_count": 167,
        "success_rate": 0.4954682779456193
    }
}