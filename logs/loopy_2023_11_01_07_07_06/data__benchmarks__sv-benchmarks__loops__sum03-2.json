{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loops/sum03-2.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#define a (2)\n\nint main() { \n  unsigned int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  while(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#define a (2)\n\nint main() { \n  unsigned int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  while(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "Pre-conditions:\n- None\n\nVariable assignments:\n- `sn` is assigned 0\n- `loop1` is assigned a non-deterministic value\n- `n1` is assigned a non-deterministic value\n- `x` is assigned 0\n\nLoop condition:\n- The loop condition is always true (`while(1)`)\n\nLoop invariants:\n- Before the loop execution:\n    - `sn == 0`\n    - `x == 0`\n- In every iteration of the loop:\n    - `sn == \\at(sn, Pre) + a`\n    - `x == \\at(x, Pre) + 1`\n    - `sn == x * a || sn == 0`\n- After the loop termination:\n    - `sn == x * a`\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0 and `x` is initialized to 0.\n- In every iteration of the loop, `sn` is incremented by `a`, and `x` is incremented by 1.\n- The condition `sn == x * a || sn == 0` holds true in every iteration of the loop. This is because `sn` starts at 0 and is incremented by `a` in each iteration. Therefore, `sn` will always be a multiple of `a`. And since `x` is incremented by 1 in each iteration, `x` will always be equal to or greater than `sn/a`. Therefore, `sn` will always be either equal to `x * a` or `0`.\n- After the loop termination, `sn` is equal to `x * a`, since `sn` is incremented by `a` in every iteration of the loop and `x` is incremented by 1 in every iteration of the loop.",
            "Pre-conditions:\n- None\n\nVariable assignments:\n- `sn`: assigned 0\n- `loop1`: assigned a non-deterministic value\n- `n1`: assigned a non-deterministic value\n- `x`: assigned 0\n\nLoop condition:\n- while(1)\n\nLoop invariants:\n- `sn <= x * a`\n- `sn == 0 ==> x == 0`\n- `x <= loop1 + 1`\n\nExplanation:\n- The first loop invariant `sn <= x * a` implies that the sum `sn` is always less than or equal to the product of `x` and `a`. This is true before the loop execution, and in every iteration of the loop because `sn` is incremented by `a` and `x` is incremented by 1 in each iteration. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually.\n- The second loop invariant `sn == 0 ==> x == 0` implies that if `sn` is ever zero during the loop execution, then `x` must also be zero. This is true before the loop execution because `sn` is initialized to 0. In every iteration of the loop, this invariant holds because `sn` is incremented by `a` and `x` is incremented by 1, so `sn` can never be 0 unless `x` is also greater than 0. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually.\n- The third loop invariant `x <= loop1 + 1` implies that `x` must always be less than or equal to `loop1 + 1`. This is true before the loop execution because `x` is initialized to 0 and `loop1` is assigned a non-deterministic value. In every iteration of the loop, this invariant holds because `x` is incremented by 1 in each iteration. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually. Note that since `loop1` is non-deterministic, we cannot make any assumptions about its value, but we can use implication to make the invariant true regardless of its value. Specifically, we can add the implication `(loop1 + 1 < x) ==> true` to make the invariant trivially true when `loop1 + 1` is less than `x`.",
            "Pre-conditions/Variable Assignments:\n- The macro `assume(e)` is defined as `if(!(e)) return 0;`\n- The function `unknown_uint()` returns an unsigned integer with an unknown value.\n- The constant `a` is defined as 2.\n- The variables `sn`, `loop1`, `n1`, and `x` are declared as unsigned integers and initialized to 0 or with values returned by `unknown_uint()`.\n\nLoop Condition:\n- The loop is an infinite loop that runs as long as the condition `1` is true.\n\nLoop Invariants:\n- `sn == x * a || sn == 0` - This invariant ensures that `sn` is always equal to `x * a` or `0`. It holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `sn == x * a || sn == 0`.\n\n- `x >= 0` - This invariant ensures that `x` is always non-negative. It holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `x >= 0`.\n\n- `loop1 >= 0` - This invariant ensures that `loop1` is always non-negative. Since `loop1` is not used in the loop body, it holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `loop1 >= 0`.\n\n- `n1 >= 0` - This invariant ensures that `n1` is always non-negative. Since `n1` is not used in the loop body, it holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `n1 >= 0`.\n\n- `sn >= 0` - This invariant ensures that `sn` is always non-negative. It holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `sn >= 0`.\n\n- `a == 2` - This invariant ensures that `a` is always equal to 2. Since `a` is a constant, it holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `a == 2`.\n\n- `sn <= x * a || sn == 0` - This invariant ensures that `sn` is always less than or equal to `x * a` or equal to `0`. It holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `sn <= x * a || sn == 0`.\n\n- `x <= sn/a+1` - This invariant ensures that `x` is always less than or equal to `sn/a + 1`. It holds true before the loop execution and in every iteration of the loop. After the loop terminates, this invariant implies the post-condition `x <= sn/a + 1`.\n\nPutting all the loop invariants together:\n\n```\n/*@ \nloop invariant sn == x * a || sn == 0;\nloop invariant x >= 0;\nloop invariant loop1 >= 0;\nloop invariant n1 >= 0;\nloop invariant sn >= 0;\nloop invariant a == 2;\nloop invariant sn <= x * a || sn == 0;\nloop invariant x <= sn/a+1;\n*/\n```",
            "First, let's analyze the loop body. The loop body contains only one statement, which increments the value of x and adds the constant value a to sn. \n\nNext, let's analyze the post-condition. The post-condition is `sn == x*a || sn == 0`. This post-condition can be split into two parts:\n- `sn == x*a`\n- `sn == 0`\n\nNow, let's find the necessary loop invariants:\n- Before the loop execution, sn and x are both equal to 0, so the loop invariant `sn == 0 && x == 0` holds.\n- In every iteration of the loop, the value of x is incremented by 1 and the value of sn is incremented by a. Therefore, the loop invariant `sn == x*a` holds.\n- After the loop termination, the loop invariant `sn == x*a || sn == 0` holds.\n\nCombining all the loop invariants, we get:\n```\n/*@ \n    loop invariant sn == 0 && x == 0;\n    loop invariant sn == x*a;\n    loop invariant sn == x*a || sn == 0;\n*/\n```\nNote that we don't need to consider any bounds on the variables or their relations because there are no such constraints present in the program. Also, since the variables are not non-deterministic, we don't need to use any implications to make the invariants trivially true.",
            "Pre-conditions:\n- The macro `assume` takes a Boolean expression as its argument and returns 0 if the expression is false.\n- The function `unknown_uint` returns an unsigned integer value that is unknown at the time of the analysis.\n- The constant `a` is defined as 2.\n- The variables `sn`, `loop1`, `n1`, and `x` are unsigned integers.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the result of `unknown_uint()`.\n- `n1` is assigned the result of `unknown_uint()`.\n- `x` is initialized to 0.\n\nLoop condition: \n- The loop is an infinite loop and will never terminate.\n\nPost-condition:\n- `sn` is always equal to `x*a` or `0`.\n\nLoop invariants:\n- Before loop execution: none\n- In every iteration:\n    - `sn == \\old(sn) + a`\n    - `x == \\old(x) + 1`\n    - `sn == x*a || sn == 0`\n- After loop termination: `sn == x*a || sn == 0`\n\nExplanation:\n- Before the loop execution, there are no loop invariants as we do not have any information about the variables.\n- In every iteration of the loop, the value of `sn` is incremented by `a` and the value of `x` is incremented by 1. The third loop invariant ensures that `sn` is always equal to `x*a` or `0`.\n- After the loop termination, `sn` must satisfy the post-condition. Therefore, the loop invariant `sn == x*a || sn == 0` holds true."
        ],
        "annotation_blocks": [
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None\n\nVariable assignments:\n- `sn` is assigned 0\n- `loop1` is assigned a non-deterministic value\n- `n1` is assigned a non-deterministic value\n- `x` is assigned 0\n\nLoop condition:\n- The loop condition is always true (`while(1)`)\n\nLoop invariants:\n- Before the loop execution:\n    - `sn == 0`\n    - `x == 0`\n- In every iteration of the loop:\n    - `sn == \\at(sn, Pre) + a`\n    - `x == \\at(x, Pre) + 1`\n    - `sn == x * a || sn == 0`\n- After the loop termination:\n    - `sn == x * a`\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0 and `x` is initialized to 0.\n- In every iteration of the loop, `sn` is incremented by `a`, and `x` is incremented by 1.\n- The condition `sn == x * a || sn == 0` holds true in every iteration of the loop. This is because `sn` starts at 0 and is incremented by `a` in each iteration. Therefore, `sn` will always be a multiple of `a`. And since `x` is incremented by 1 in each iteration, `x` will always be equal to or greater than `sn/a`. Therefore, `sn` will always be either equal to `x * a` or `0`.\n- After the loop termination, `sn` is equal to `x * a`, since `sn` is incremented by `a` in every iteration of the loop and `x` is incremented by 1 in every iteration of the loop."
            ],
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None\n\nVariable assignments:\n- `sn`: assigned 0\n- `loop1`: assigned a non-deterministic value\n- `n1`: assigned a non-deterministic value\n- `x`: assigned 0\n\nLoop condition:\n- while(1)\n\nLoop invariants:\n- `sn <= x * a`\n- `sn == 0 ==> x == 0`\n- `x <= loop1 + 1`\n\nExplanation:\n- The first loop invariant `sn <= x * a` implies that the sum `sn` is always less than or equal to the product of `x` and `a`. This is true before the loop execution, and in every iteration of the loop because `sn` is incremented by `a` and `x` is incremented by 1 in each iteration. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually.\n- The second loop invariant `sn == 0 ==> x == 0` implies that if `sn` is ever zero during the loop execution, then `x` must also be zero. This is true before the loop execution because `sn` is initialized to 0. In every iteration of the loop, this invariant holds because `sn` is incremented by `a` and `x` is incremented by 1, so `sn` can never be 0 unless `x` is also greater than 0. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually.\n- The third loop invariant `x <= loop1 + 1` implies that `x` must always be less than or equal to `loop1 + 1`. This is true before the loop execution because `x` is initialized to 0 and `loop1` is assigned a non-deterministic value. In every iteration of the loop, this invariant holds because `x` is incremented by 1 in each iteration. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually. Note that since `loop1` is non-deterministic, we cannot make any assumptions about its value, but we can use implication to make the invariant true regardless of its value. Specifically, we can add the implication `(loop1 + 1 < x) ==> true` to make the invariant trivially true when `loop1 + 1` is less than `x`."
            ],
            "/*@ \nloop invariant sn == x * a || sn == 0;\nloop invariant x >= 0;\nloop invariant loop1 >= 0;\nloop invariant n1 >= 0;\nloop invariant sn >= 0;\nloop invariant a == 2;\nloop invariant sn <= x * a || sn == 0;\nloop invariant x <= sn/a+1;\n*/",
            "/*@ \n    loop invariant sn == 0 && x == 0;\n    loop invariant sn == x*a;\n    loop invariant sn == x*a || sn == 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The macro `assume` takes a Boolean expression as its argument and returns 0 if the expression is false.\n- The function `unknown_uint` returns an unsigned integer value that is unknown at the time of the analysis.\n- The constant `a` is defined as 2.\n- The variables `sn`, `loop1`, `n1`, and `x` are unsigned integers.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the result of `unknown_uint()`.\n- `n1` is assigned the result of `unknown_uint()`.\n- `x` is initialized to 0.\n\nLoop condition: \n- The loop is an infinite loop and will never terminate.\n\nPost-condition:\n- `sn` is always equal to `x*a` or `0`.\n\nLoop invariants:\n- Before loop execution: none\n- In every iteration:\n    - `sn == \\old(sn) + a`\n    - `x == \\old(x) + 1`\n    - `sn == x*a || sn == 0`\n- After loop termination: `sn == x*a || sn == 0`\n\nExplanation:\n- Before the loop execution, there are no loop invariants as we do not have any information about the variables.\n- In every iteration of the loop, the value of `sn` is incremented by `a` and the value of `x` is incremented by 1. The third loop invariant ensures that `sn` is always equal to `x*a` or `0`.\n- After the loop termination, `sn` must satisfy the post-condition. Therefore, the loop invariant `sn == x*a || sn == 0` holds true."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None\n\nVariable assignments:\n- `sn` is assigned 0\n- `loop1` is assigned a non-deterministic value\n- `n1` is assigned a non-deterministic value\n- `x` is assigned 0\n\nLoop condition:\n- The loop condition is always true (`while(1)`)\n\nLoop invariants:\n- Before the loop execution:\n    - `sn == 0`\n    - `x == 0`\n- In every iteration of the loop:\n    - `sn == \\at(sn, Pre) + a`\n    - `x == \\at(x, Pre) + 1`\n    - `sn == x * a || sn == 0`\n- After the loop termination:\n    - `sn == x * a`\n\nExplanation:\n- Before the loop execution, `sn` is initialized to 0 and `x` is initialized to 0.\n- In every iteration of the loop, `sn` is incremented by `a`, and `x` is incremented by 1.\n- The condition `sn == x * a || sn == 0` holds true in every iteration of the loop. This is because `sn` starts at 0 and is incremented by `a` in each iteration. Therefore, `sn` will always be a multiple of `a`. And since `x` is incremented by 1 in each iteration, `x` will always be equal to or greater than `sn/a`. Therefore, `sn` will always be either equal to `x * a` or `0`.\n- After the loop termination, `sn` is equal to `x * a`, since `sn` is incremented by `a` in every iteration of the loop and `x` is incremented by 1 in every iteration of the loop.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None\n\nVariable assignments:\n- `sn`: assigned 0\n- `loop1`: assigned a non-deterministic value\n- `n1`: assigned a non-deterministic value\n- `x`: assigned 0\n\nLoop condition:\n- while(1)\n\nLoop invariants:\n- `sn <= x * a`\n- `sn == 0 ==> x == 0`\n- `x <= loop1 + 1`\n\nExplanation:\n- The first loop invariant `sn <= x * a` implies that the sum `sn` is always less than or equal to the product of `x` and `a`. This is true before the loop execution, and in every iteration of the loop because `sn` is incremented by `a` and `x` is incremented by 1 in each iteration. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually.\n- The second loop invariant `sn == 0 ==> x == 0` implies that if `sn` is ever zero during the loop execution, then `x` must also be zero. This is true before the loop execution because `sn` is initialized to 0. In every iteration of the loop, this invariant holds because `sn` is incremented by `a` and `x` is incremented by 1, so `sn` can never be 0 unless `x` is also greater than 0. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually.\n- The third loop invariant `x <= loop1 + 1` implies that `x` must always be less than or equal to `loop1 + 1`. This is true before the loop execution because `x` is initialized to 0 and `loop1` is assigned a non-deterministic value. In every iteration of the loop, this invariant holds because `x` is incremented by 1 in each iteration. After the loop termination, this invariant holds because the loop condition is always true, so the loop keeps running until the program is terminated manually. Note that since `loop1` is non-deterministic, we cannot make any assumptions about its value, but we can use implication to make the invariant true regardless of its value. Specifically, we can add the implication `(loop1 + 1 < x) ==> true` to make the invariant trivially true when `loop1 + 1` is less than `x`.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \nloop invariant sn == x * a || sn == 0;\nloop invariant x >= 0;\nloop invariant loop1 >= 0;\nloop invariant n1 >= 0;\nloop invariant sn >= 0;\nloop invariant a == 2;\nloop invariant sn <= x * a || sn == 0;\nloop invariant x <= sn/a+1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn == x * a || sn == 0 is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant loop1 >= 0 is partially proven to be inductive.\nloop invariant n1 >= 0 is partially proven to be inductive.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant a == 2 is partially proven to be inductive.\nloop invariant sn <= x * a || sn == 0 is partially proven to be inductive.\nloop invariant x <= sn/a+1 is established but not preserved.\nAssertion sn == x * 2 || sn == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#define a (2)\n\nint main() { \n  unsigned int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x * a || sn == 0;\nloop invariant i2: x >= 0;\nloop invariant i3: loop1 >= 0;\nloop invariant i4: n1 >= 0;\nloop invariant i5: sn >= 0;\nloop invariant i6: a == 2;\nloop invariant i7: sn <= x * a || sn == 0;\n\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@ \n    loop invariant sn == 0 && x == 0;\n    loop invariant sn == x*a;\n    loop invariant sn == x*a || sn == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant sn == 0 && x == 0 is established but not preserved.\nloop invariant sn == x*a is partially proven to be inductive.\nloop invariant sn == x*a || sn == 0 is partially proven to be inductive.\nAssertion sn == x * 2 || sn == 0: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#define a (2)\n\nint main() { \n  unsigned int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\n\n\nloop invariant i3: sn == x*a || sn == 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The macro `assume` takes a Boolean expression as its argument and returns 0 if the expression is false.\n- The function `unknown_uint` returns an unsigned integer value that is unknown at the time of the analysis.\n- The constant `a` is defined as 2.\n- The variables `sn`, `loop1`, `n1`, and `x` are unsigned integers.\n\nVariable assignments:\n- `sn` is initialized to 0.\n- `loop1` is assigned the result of `unknown_uint()`.\n- `n1` is assigned the result of `unknown_uint()`.\n- `x` is initialized to 0.\n\nLoop condition: \n- The loop is an infinite loop and will never terminate.\n\nPost-condition:\n- `sn` is always equal to `x*a` or `0`.\n\nLoop invariants:\n- Before loop execution: none\n- In every iteration:\n    - `sn == \\old(sn) + a`\n    - `x == \\old(x) + 1`\n    - `sn == x*a || sn == 0`\n- After loop termination: `sn == x*a || sn == 0`\n\nExplanation:\n- Before the loop execution, there are no loop invariants as we do not have any information about the variables.\n- In every iteration of the loop, the value of `sn` is incremented by `a` and the value of `x` is incremented by 1. The third loop invariant ensures that `sn` is always equal to `x*a` or `0`.\n- After the loop termination, `sn` must satisfy the post-condition. Therefore, the loop invariant `sn == x*a || sn == 0` holds true.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant sn == x * a || sn == 0 is partially proven to be inductive.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant loop1 >= 0 is partially proven to be inductive.\nloop invariant n1 >= 0 is partially proven to be inductive.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant a == 2 is partially proven to be inductive.\nloop invariant sn <= x * a || sn == 0 is partially proven to be inductive.\nloop invariant x <= sn/a+1 is partially proven to be inductive.\nloop invariant sn == 0 && x == 0 is established but not preserved.\nloop invariant sn == x*a is partially proven to be inductive.\nloop invariant sn == x*a || sn == 0 is partially proven to be inductive.\nAssertion sn == x * 2 || sn == 0: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#define a (2)\n\nint main() { \n  unsigned int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x * a || sn == 0;\nloop invariant i2: x >= 0;\nloop invariant i3: loop1 >= 0;\nloop invariant i4: n1 >= 0;\nloop invariant i5: sn >= 0;\nloop invariant i6: a == 2;\nloop invariant i7: sn <= x * a || sn == 0;\nloop invariant i8: x <= sn/a+1;\nloop invariant i9: sn == 0 && x == 0;\nloop invariant i10: sn == x*a;\nloop invariant i11: sn == x*a || sn == 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}\n",
        "combined_annotation_num_solver_calls": 5,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#define a (2)\n\nint main() { \n  unsigned int sn=0;\n  unsigned int loop1=unknown_uint(), n1=unknown_uint();\n  unsigned int x=0;\n\n  /*@\nloop invariant i1: sn == x * a || sn == 0;\nloop invariant i2: x >= 0;\nloop invariant i3: loop1 >= 0;\nloop invariant i4: n1 >= 0;\nloop invariant i5: sn >= 0;\nloop invariant i6: a == 2;\nloop invariant i7: sn <= x * a || sn == 0;\n\n\n\nloop invariant i11: sn == x*a || sn == 0;\n*/\nwhile(1){\n    sn = sn + a;\n    x++;\n    {;\n//@ assert(sn==x*a || sn == 0);\n}\n\n  }\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop2_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop4_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop6_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop7_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/const.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq1.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/eq2.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/NetBSD_loop.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/afnp2014.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/css2003.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007b.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gsv2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/hhk2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_1_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_2.c",
            "../data/benchmarks/sv-benchmarks/loop-new/gauss_sum.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark01_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark02_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark04_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark05_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark06_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark08_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark10_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark11_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark13_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark14_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark15_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark16_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark17_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark18_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark20_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark21_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark22_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark23_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark25_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark26_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark27_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark29_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark30_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark31_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark32_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark33_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark34_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark35_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark36_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark37_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark38_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark39_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark40_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark41_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark42_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark43_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark45_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark48_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark49_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark50_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark51_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark52_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark53_polynomial.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_1.c",
            "../data/benchmarks/sv-benchmarks/loops/for_infinite_loop_2.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop29_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop3-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop9_VeriMAP_true.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/const_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/diamond_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/multivar_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/overflow_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/phases_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_3-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/simple_4-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-acceleration/underapprox_2-1.c",
            "../data/benchmarks/sv-benchmarks/loop-crafted/simple_vardep_1.c",
            "../data/benchmarks/sv-benchmarks/loop-industry-pattern/mod3.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/bin-suffix-5.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/even.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/mod4.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/odd.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/id_trans.c",
            "../data/benchmarks/sv-benchmarks/loop-invgen/sendmail-close-angle.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/bhmr2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/cggmp2005_variant.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/ddlm2013.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gcnr2008.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gj2007.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/gr2006.c",
            "../data/benchmarks/sv-benchmarks/loop-lit/jm2006.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_k.c",
            "../data/benchmarks/sv-benchmarks/loop-new/count_by_nondet.c",
            "../data/benchmarks/sv-benchmarks/loop-new/half.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark03_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark07_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark09_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark12_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark19_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark24_conjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark28_linear.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark44_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark46_disjunctive.c",
            "../data/benchmarks/sv-benchmarks/loop-zilu/benchmark47_linear.c",
            "../data/benchmarks/sv-benchmarks/loops/count_up_down-2.c",
            "../data/benchmarks/sv-benchmarks/loops/for_bounded_loop1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01-2.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02.c",
            "../data/benchmarks/sv-benchmarks/loops/sum01_bug02_sum01_bug02_base.case.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-1.c",
            "../data/benchmarks/sv-benchmarks/loops/sum03-2.c"
        ],
        "skipped": [],
        "total": 371,
        "success_count": 192,
        "failure_count": 179,
        "success_rate": 0.5175202156334232
    }
}