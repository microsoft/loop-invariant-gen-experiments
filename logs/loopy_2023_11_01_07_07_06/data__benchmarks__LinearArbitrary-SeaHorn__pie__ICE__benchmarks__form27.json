{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  while(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}\n",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  while(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}\n\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "**Step 1: Pre-conditions and variable assignments**\n\nThe program initializes `x1`, `x2`, `x3`, `x4`, and `x5` to `0`. Then it reads an integer value `input` from an external function `unknown_int()`.\n\n**Step 2: Loop condition**\n\nThe loop executes while `input` is non-zero.\n\n**Step 3: Loop invariants**\n\n(i) Before the loop execution:\n\n```\n/*@ \n   loop invariant 0 <= x1 <= x4 + 1;\n   loop invariant x2 == x3;\n   loop invariant x2 <= -1 ==> x4 <= x2 + 2;\n   loop invariant x2 > -1 ==> x4 >= x2 - 2;\n   loop invariant x5 == 0;\n*/\n```\nExplanation:\n- `0 <= x1 <= x4 + 1` bounds the values of `x1` to be between `0` and `x4 + 1`, inclusive.\n- `x2 == x3` ensures that `x2` and `x3` are always equal.\n- `x2 <= -1 ==> x4 <= x2 + 2` implies that if `x2` is less than or equal to `-1`, then `x4` is less than or equal to `x2 + 2`.\n- `x2 > -1 ==> x4 >= x2 - 2` implies that if `x2` is greater than `-1`, then `x4` is greater than or equal to `x2 - 2`.\n- `x5 == 0` ensures that `x5` is always equal to `0`.\n\n(ii) In every iteration of the loop:\n\n```\n/*@ \n   loop invariant 0 <= x1 <= x4 + 1;\n   loop invariant x2 == x3;\n   loop invariant x2 <= -1 ==> x4 <= x2 + 2;\n   loop invariant x2 > -1 ==> x4 >= x2 - 2;\n   loop invariant x5 == 0;\n   loop invariant (input != 0) ==> (0 <= x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0);\n*/\n```\nExplanation:\n- All the invariants from (i) are repeated.\n- `(input != 0) ==> (0 <= x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)` implies that if `input` is non-zero, then the values of `x1p`, `x2p`, `x3p`, `x4p`, and `x5p` satisfy the conditions in the loop body.\n\n(iii) After the loop termination:\n\n```\n/*@ \n   loop invariant 0 <= x1 <= x4 + 1;\n   loop invariant x2 == x3;\n   loop invariant x2 <= -1 ==> x4 <= x2 + 2;\n   loop invariant x2 > -1 ==> x4 >= x2 - 2;\n   loop invariant x5 == 0;\n   loop invariant input == 0 ==> (0 <= x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n*/\n```\nExplanation:\n- All the invariants from (i) are repeated.\n- `input == 0 ==> (0 <= x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0)` implies that if `input` is zero, then the final values of `x1`, `x2`, `x3`, `x4`, and `x5` satisfy the post-condition.",
            "Pre-conditions:\n- None.\n\nVariable assignments:\n- `x1`, `x2`, `x3`, `x4`, `x5` are initialized to 0.\n\nLoop condition:\n- `input` is non-zero.\n\nLoop invariants:\n- `0 <= x1 && x1 <= x4 + 1`\n- `x2 == x3`\n- `(x2 <= -1 || x4 <= x2 + 2)`\n- `x5 == 0`\n- Implication: `input == 0 ==> (0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0)`\n\nExplanation:\n- The loop invariants hold before the loop execution because all variables are initialized to 0, and the loop condition is checked only after the first iteration.\n- Inside the loop, `x1`, `x2`, `x3`, `x4`, `x5` are updated only if the given condition is satisfied. Therefore, the loop invariants hold in every iteration of the loop.\n- After the loop termination, the loop invariant holds because the loop terminates when `input` becomes 0. The implication makes sure that the assertion holds only if the loop has executed at least once and the loop invariants hold at the end of the loop.",
            "**Step 1: Pre-conditions or variable assignments in the program**\n\nThe program initializes all variables x1, x2, x3, x4, and x5 to 0. The program then reads an input value and enters a while loop. Inside the loop, it reads five integer values from an unknown source and checks if they satisfy a certain condition. If the condition is satisfied, it assigns these values to the variables x1, x2, x3, x4, and x5. Finally, it reads another input value and repeats the loop if the input value is non-zero. The goal is to find loop invariants that imply the post-condition.\n\n**Step 2: Loop condition**\n\nThe loop condition is `input`, which means the loop will continue as long as the value of `input` is non-zero.\n\n**Step 3: Loop invariants**\n\nBefore the loop, all variables have garbage values, so we cannot specify any meaningful invariants.\n\nDuring the loop, the program reads five integer values from an unknown source and checks if they satisfy the condition:\n\n```\n0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0\n```\n\nIf this condition is satisfied, it assigns the values of `x1p`, `x2p`, `x3p`, `x4p`, and `x5p` to the variables `x1`, `x2`, `x3`, `x4`, and `x5`, respectively. Therefore, we can use this condition as a loop invariant:\n\n```\n/*@ loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0; */\n```\n\nAfter the loop, the program verifies the assertion:\n\n```\n0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0\n```\n\nIf the loop invariant is true, then the assertion must also be true, so we can use the loop invariant to imply the assertion:\n\n```\n/*@ loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0;\n    loop variant input; */\n```\n\nNote that we also added a loop variant `input`, which decreases by at least one in every iteration, and thus ensures that the loop terminates.",
            "Pre-conditions:\n- All variables `x1`, `x2`, `x3`, `x4`, `x5` are initialized to 0.\n\nLoop condition:\n- The loop runs as long as `input` is non-zero.\n\nLoop invariants:\n- Before the loop execution:\n    - `0 <= x1 <= x4 + 1`\n    - `x2 == x3`\n    - `x5 == 0`\n    - `input != 0` ==> `x1p, x2p, x3p, x4p, x5p` are non-deterministic and can take any value.\n\n- In every iteration of the loop:\n    - `0 <= x1 <= x4 + 1`\n    - `x2 == x3`\n    - `x5 == 0`\n    - `0 <= x1p <= x4p + 1`\n    - `x2p == x3p`\n    - `(x2p <= -1 || x4p <= x2p + 2)`\n    - `x5p == 0`\n\n- After the loop termination:\n    - `0 <= x1 <= x4 + 1`\n    - `x2 == x3`\n    - `x5 == 0`\n    - `input == 0` ==> `0 <= x1p <= x4p + 1`, `x2p == x3p`, `(x2p <= -1 || x4p <= x2p + 2)`, `x5p == 0`\n\nPutting it all together:\n```\n/*@ \n  loop invariant 0 <= x1 <= x4 + 1;\n  loop invariant x2 == x3;\n  loop invariant x5 == 0;\n  loop invariant input != 0 ==> (0 <= x1p <= x4p + 1) && (x2p == x3p) && ((x2p <= -1) || (x4p <= x2p + 2)) && (x5p == 0);\n  loop invariant (input == 0) ==> (0 <= x1p <= x4p + 1) ==> (x2p == x3p) ==> ((x2p <= -1) || (x4p <= x2p + 2)) ==> (x5p == 0);\n*/\n```\n\nNote: The loop invariants are not sufficient to prove the post-condition, as there are no bounds on `x2` and `x4` individually. However, the given program is not amenable to such bounds, as they would require non-linear arithmetic.",
            "Pre-conditions:\n- The program assumes the existence of an external function `unknown_int()` that returns an integer value.\n- The program defines a macro `assume(e)` that returns 0 if the expression `e` is false.\n\nVariable Assignments:\n- The program declares and initializes the variables `x1`, `x2`, `x3`, `x4`, and `x5` to 0.\n- The program declares the variables `x1p`, `x2p`, `x3p`, `x4p`, and `x5p`.\n\nLoop Condition:\n- The loop runs while the value returned by `unknown_int()` is non-zero.\n\nLoop Invariants:\n- Since `unknown_int()` is non-deterministic, we cannot make any assumptions about the values of `x1p`, `x2p`, `x3p`, `x4p`, and `x5p` at the beginning of each iteration. Therefore, we need to add an implication that makes the loop invariant trivially true at the beginning of the loop:\n```\n/*@ loop invariant \\forall integer i; 0 <= i < \\at(input, Pre) ==> (x1 == 0 && x2 == 0 && x3 == 0 && x4 == 0 && x5 == 0); */\n```\n\n- The loop invariant must hold for every iteration. Let's analyze the code inside the loop to deduce the loop invariants that need to be added.\n```\nif (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n{\n  x1 = x1p;\n  x2 = x2p;\n  x3 = x3p;\n  x4 = x4p;\n  x5 = x5p;\n}\n```\n- From the assignment statements, we can deduce that the values of `x1`, `x2`, `x3`, `x4`, and `x5` are updated to the values of `x1p`, `x2p`, `x3p`, `x4p`, and `x5p`, respectively, if the condition inside the if-statement is true. Therefore, we need to add an implication that makes sure that the condition inside the if-statement implies the loop invariant:\n```\n/*@ loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0 ==> (0 <= \\at(input, Pre) && 0 <= input); */\n```\n- The loop invariant must also hold after the loop has terminated. Since the loop terminates when the value returned by `unknown_int()` is zero, we need to add an implication that makes sure that the loop invariant implies the post-condition of the program:\n```\n/*@ loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0 ==> (input == 0 ==> (0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0)); */\n```\n\nPutting it all together, the loop invariants for the program are:\n```\n/*@ \n  loop invariant \\forall integer i; 0 <= i < \\at(input, Pre) ==> (x1 == 0 && x2 == 0 && x3 == 0 && x4 == 0 && x5 == 0);\n  loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0 ==> (0 <= \\at(input, Pre) && 0 <= input);\n  loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0 ==> (input == 0 ==> (0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0));\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n   loop invariant 0 <= x1 <= x4 + 1;\n   loop invariant x2 == x3;\n   loop invariant x2 <= -1 ==> x4 <= x2 + 2;\n   loop invariant x2 > -1 ==> x4 >= x2 - 2;\n   loop invariant x5 == 0;\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- None.\n\nVariable assignments:\n- `x1`, `x2`, `x3`, `x4`, `x5` are initialized to 0.\n\nLoop condition:\n- `input` is non-zero.\n\nLoop invariants:\n- `0 <= x1 && x1 <= x4 + 1`\n- `x2 == x3`\n- `(x2 <= -1 || x4 <= x2 + 2)`\n- `x5 == 0`\n- Implication: `input == 0 ==> (0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0)`\n\nExplanation:\n- The loop invariants hold before the loop execution because all variables are initialized to 0, and the loop condition is checked only after the first iteration.\n- Inside the loop, `x1`, `x2`, `x3`, `x4`, `x5` are updated only if the given condition is satisfied. Therefore, the loop invariants hold in every iteration of the loop.\n- After the loop termination, the loop invariant holds because the loop terminates when `input` becomes 0. The implication makes sure that the assertion holds only if the loop has executed at least once and the loop invariants hold at the end of the loop."
            ],
            "/*@ loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0; */",
            "/*@ \n  loop invariant 0 <= x1 <= x4 + 1;\n  loop invariant x2 == x3;\n  loop invariant x5 == 0;\n  loop invariant input != 0 ==> (0 <= x1p <= x4p + 1) && (x2p == x3p) && ((x2p <= -1) || (x4p <= x2p + 2)) && (x5p == 0);\n  loop invariant (input == 0) ==> (0 <= x1p <= x4p + 1) ==> (x2p == x3p) ==> ((x2p <= -1) || (x4p <= x2p + 2)) ==> (x5p == 0);\n*/",
            "/*@ loop invariant \\forall integer i; 0 <= i < \\at(input, Pre) ==> (x1 == 0 && x2 == 0 && x3 == 0 && x4 == 0 && x5 == 0); */"
        ],
        "completions": [
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n   loop invariant 0 <= x1 <= x4 + 1;\n   loop invariant x2 == x3;\n   loop invariant x2 <= -1 ==> x4 <= x2 + 2;\n   loop invariant x2 > -1 ==> x4 >= x2 - 2;\n   loop invariant x5 == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= x1 <= x4 + 1 is partially proven to be inductive.\nloop invariant x2 == x3 is partially proven to be inductive.\nloop invariant x2 <= -1 ==> x4 <= x2 + 2 is established but not preserved.\nloop invariant x2 > -1 ==> x4 >= x2 - 2 is established but not preserved.\nloop invariant x5 == 0 is partially proven to be inductive.\nAssertion 0 <= x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  /*@\nloop invariant i1: 0 <= x1 <= x4 + 1;\nloop invariant i2: x2 == x3;\n\n\nloop invariant i5: x5 == 0;\n*/\nwhile(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- None.\n\nVariable assignments:\n- `x1`, `x2`, `x3`, `x4`, `x5` are initialized to 0.\n\nLoop condition:\n- `input` is non-zero.\n\nLoop invariants:\n- `0 <= x1 && x1 <= x4 + 1`\n- `x2 == x3`\n- `(x2 <= -1 || x4 <= x2 + 2)`\n- `x5 == 0`\n- Implication: `input == 0 ==> (0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0)`\n\nExplanation:\n- The loop invariants hold before the loop execution because all variables are initialized to 0, and the loop condition is checked only after the first iteration.\n- Inside the loop, `x1`, `x2`, `x3`, `x4`, `x5` are updated only if the given condition is satisfied. Therefore, the loop invariants hold in every iteration of the loop.\n- After the loop termination, the loop invariant holds because the loop terminates when `input` becomes 0. The implication makes sure that the assertion holds only if the loop has executed at least once and the loop invariants hold at the end of the loop.",
                "error": "Output does not contain at least 1 code block"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0; */",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0 is inductive.\nAssertion 0 <= x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0: Valid"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n  loop invariant 0 <= x1 <= x4 + 1;\n  loop invariant x2 == x3;\n  loop invariant x5 == 0;\n  loop invariant input != 0 ==> (0 <= x1p <= x4p + 1) && (x2p == x3p) && ((x2p <= -1) || (x4p <= x2p + 2)) && (x5p == 0);\n  loop invariant (input == 0) ==> (0 <= x1p <= x4p + 1) ==> (x2p == x3p) ==> ((x2p <= -1) || (x4p <= x2p + 2)) ==> (x5p == 0);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= x1 <= x4 + 1 is partially proven to be inductive.\nloop invariant x2 == x3 is partially proven to be inductive.\nloop invariant x5 == 0 is partially proven to be inductive.\nloop invariant input != 0 ==> (0 <= x1p <= x4p + 1) && (x2p == x3p) && ((x2p <= -1) || (x4p <= x2p + 2)) && (x5p == 0) is neither established nor preserved.\nloop invariant (input == 0) ==> (0 <= x1p <= x4p + 1) ==> (x2p == x3p) ==> ((x2p <= -1) || (x4p <= x2p + 2)) ==> (x5p == 0) is neither established nor preserved.\nAssertion 0 <= x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  /*@\nloop invariant i1: 0 <= x1 <= x4 + 1;\nloop invariant i2: x2 == x3;\nloop invariant i3: x5 == 0;\n\n\n*/\nwhile(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ loop invariant \\forall integer i; 0 <= i < \\at(input, Pre) ==> (x1 == 0 && x2 == 0 && x3 == 0 && x4 == 0 && x5 == 0); */",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 12: unbound logic variable input. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  /*@\n\n*/\nwhile(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 20: unbound logic variable input. Ignoring loop annotation",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  /*@\nloop invariant i1: 0 <= x1 <= x4 + 1;\nloop invariant i2: x2 == x3;\nloop invariant i3: x2 <= -1 ==> x4 <= x2 + 2;\nloop invariant i4: x2 > -1 ==> x4 >= x2 - 2;\nloop invariant i5: x5 == 0;\nloop invariant i6: 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0;\nloop invariant i7: input != 0 ==> (0 <= x1p <= x4p + 1) && (x2p == x3p) && ((x2p <= -1) || (x4p <= x2p + 2)) && (x5p == 0);\nloop invariant i8: (input == 0) ==> (0 <= x1p <= x4p + 1) ==> (x2p == x3p) ==> ((x2p <= -1) || (x4p <= x2p + 2)) ==> (x5p == 0);\nloop invariant i9: \\forall integer i; 0 <= i < \\at(input, Pre) ==> (x1 == 0 && x2 == 0 && x3 == 0 && x4 == 0 && x5 == 0);\n*/\nwhile(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}\n",
        "combined_annotation_num_solver_calls": 3,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main()\n{\n  int x1,x2,x3,x4,x5;\n  int x1p,x2p,x3p,x4p,x5p, input;\n\n  x1 = x2 = x3 = x4 = x5 = 0;\n  input = unknown_int();\n  /*@\nloop invariant i1: 0 <= x1 <= x4 + 1;\nloop invariant i2: x2 == x3;\n\n\nloop invariant i5: x5 == 0;\nloop invariant i6: 0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0;\n\n\n\n*/\nwhile(input)\n  {\n    x1p = unknown_int();\n    x2p = unknown_int();\n    x3p = unknown_int();\n    x4p = unknown_int();\n    x5p = unknown_int();\n\n    if (0 <= x1p && x1p <= x4p + 1 && x2p == x3p && (x2p <= -1 || x4p <= x2p + 2) && x5p == 0)\n    {\n\tx1 = x1p;\n\tx2 = x2p;\n\tx3 = x3p;\n\tx4 = x4p;\n\tx5 = x5p;\n    }\n    input = unknown_int();\n  }\n  {;\n//@ assert(0 <= x1 && x1 <= x4 + 1 && x2 == x3 && (x2 <= -1 || x4 <= x2 + 2) && x5 == 0);\n}\n\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c"
        ],
        "skipped": [],
        "total": 201,
        "success_count": 91,
        "failure_count": 110,
        "success_rate": 0.4527363184079602
    }
}