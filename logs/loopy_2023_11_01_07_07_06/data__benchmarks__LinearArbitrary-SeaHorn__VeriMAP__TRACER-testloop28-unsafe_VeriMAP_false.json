{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  while (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  while (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
            },
            "We start with analyzing the program and making notes of preconditions and variable assignments.\n\nPreconditions: None\n\nVariable assignments:\n- `x` is initialized to 0\n- `i` is initialized to 0\n\nNext, we analyze the loop body and make notes of the loop condition.\n\nLoop condition: `i<n`\n\nNow, we need to find loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply the post-condition.\n\nBefore the loop execution, we can add the following loop invariants:\n- `x >= 0`\n- `i >= 0`\n\nIn every iteration of the loop, we can add the following loop invariants:\n- `i <= n`\n- `(i < n) ==> (x <= 1)` (Implication is used here to take care of the conditional nature of the code)\n- `(i < n) ==> (x >= 0)` (Implication is used here to take care of the conditional nature of the code)\n\nAfter the loop termination, we can add the following loop invariants:\n- `i >= n`\n- `(i >= n) ==> (x <= 1)` (Implication is used here to take care of the conditional nature of the code)\n- `(i >= n) ==> (x >= 0)` (Implication is used here to take care of the conditional nature of the code)\n- `!(x > 0)` (This is the post-condition we need to verify)\n\nCombining all the loop invariants, we get the following code block:\n```\n/*@\n  loop invariant x >= 0;\n  loop invariant i >= 0;\n  loop invariant i <= n;\n  loop invariant (i < n) ==> (x <= 1);\n  loop invariant (i < n) ==> (x >= 0);\n  loop invariant i >= n;\n  loop invariant (i >= n) ==> (x <= 1);\n  loop invariant (i >= n) ==> (x >= 0);\n  loop invariant !(x > 0);\n*/\n```\n\nNote: Since the program uses a non-deterministic function call, we cannot make any assumptions about the values of `x` and `i` at the end of the loop. Therefore, we need to use implications to make the loop invariants true at the end of the loop.",
            "Pre-conditions:\n- The program does not have any explicit pre-conditions.\n- The macro `assume(e)` is used to check if a given expression `e` is true. If `e` is false, the program returns 0.\n\nVariable Assignments:\n- The function `unknown()` returns an integer value that is assigned to the variable `x`.\n- The variable `i` is initialized to 0.\n- The variable `x` is initialized to 0.\n\nLoop Condition:\n- The loop will iterate while the value of `i` is less than `n`. However, the value of `n` is undefined and can have any value.\n\nLoop Invariants:\n- Since the loop condition depends on `n`, we need to add a precondition that bounds the value of `n` to ensure that the loop is well-defined. Let's assume that `n` is positive.\n```\n/*@ \n  requires n > 0;\n*/\n```\n- The variable `i` is incremented in each iteration of the loop. Therefore, we can add an invariant that bounds the value of `i` between 0 and `n`.\n```\n/*@ \n  loop invariant 0 <= i <= n;\n*/\n```\n- The variable `x` is initialized to 0 and is only assigned a value of 1 inside the loop. Therefore, we can add an invariant that bounds the value of `x` between 0 and 1.\n```\n/*@ \n  loop invariant 0 <= x <= 1;\n*/\n```\n- The assertion inside the loop is guarded by the condition `unknown() > 0`. Therefore, we can use an implication to handle this condition.\n```\n/*@ \n  loop invariant 0 <= i <= n ==> (unknown() > 0 ==> !(x > 0));\n  loop invariant 0 <= i <= n ==> (unknown() <= 0 ==> (x <= 0));\n*/\n```\n- The function `unknown()` returns a non-deterministic value. Therefore, we need to use an implication to ensure that the loop invariants are trivially true at the beginning and end of the loop.\n```\n/*@ \n  loop invariant i == 0 ==> x == 0;\n  loop invariant 0 <= i <= n ==> (unknown() > 0 ==> !(x > 0));\n  loop invariant 0 <= i <= n ==> (unknown() <= 0 ==> (x <= 0));\n  loop invariant i >= n ==> \\true;\n*/\n```\n- The last invariant is trivially true and is added to indicate that the loop terminates.\n\nPutting everything together, we get the following loop invariants:\n```\n/*@ \n  requires n > 0;\n\n  loop invariant i == 0 ==> x == 0;\n  loop invariant 0 <= i <= n ==> (unknown() > 0 ==> !(x > 0));\n  loop invariant 0 <= i <= n ==> (unknown() <= 0 ==> (x <= 0));\n  loop invariant i >= n ==> \\true;\n\n  loop invariant 0 <= i <= n;\n  loop invariant 0 <= x <= 1;\n*/\n```",
            "Pre-conditions:\n- The macro `assume(e)` is used to ensure that the given condition `e` is true. If `e` is false, then the program returns 0.\n- The function `unknown()` is an external function whose definition is unknown. \n\nVariable Assignments:\n- `x` is initialized to 0.\n- `i` is initialized to 0.\n\nLoop Body:\n- If `unknown()` returns a value greater than 0, then the assertion `!(x > 0)` is checked.\n- Otherwise, `x` is assigned the value 1.\n- `i` is incremented by 1 in every iteration.\n\nLoop Condition:\n- The loop continues as long as `i` is less than `n`.\n\nPost-condition:\n- The assertion `!(x > 0)` should hold at the end of the loop.\n\nLoop Invariants:\n- Since `i` is initialized to 0 and incremented by 1 in every iteration of the loop, we can add the following loop invariant:\n```\n/*@ loop invariant 0 <= i; */\n/*@ loop invariant i <= n; */\n```\n- Since `x` is initialized to 0 before the loop, we can add the following loop invariant:\n```\n/*@ loop invariant x <= 1; */\n```\n- Since `x` is assigned the value 1 whenever `unknown()` returns a value less than or equal to 0, we can add the following loop invariant:\n```\n/*@ loop invariant (unknown() <= 0) ==> (x == 1); */\n```\n- Since the loop continues as long as `i` is less than `n`, we can add the following loop invariant:\n```\n/*@ loop invariant (i < n) || (i >= n); */\n```\n- Since the post-condition is `!(x > 0)` and `x` is initialized to 0 before the loop, we can add the following loop invariant:\n```\n/*@ loop invariant (i >= n) ==> !(x > 0); */\n```\n- Since the `unknown()` function is non-deterministic and its value is used in the loop, we can add the following loop invariant to ensure that the assertion is always true:\n```\n/*@ loop invariant (unknown() > 0) ==> \\false; */\n```\nPutting everything together, we get the following loop invariants:\n```\n/*@ loop invariant 0 <= i;\n    loop invariant i <= n;\n    loop invariant x <= 1;\n    loop invariant (unknown() <= 0) ==> (x == 1);\n    loop invariant (i < n) || (i >= n);\n    loop invariant (i >= n) ==> !(x > 0);\n    loop invariant (unknown() > 0) ==> \\false;\n*/\n```",
            "Let's start by analyzing the program and making note of the pre-conditions or variable assignments in the program:\n\n- The program defines a macro `assume` which returns 0 if the input expression is false.\n- The program defines an external function `unknown` which returns an integer value. The function is not defined in the program, so we cannot make any assumptions about its behavior.\n- The `main` function initializes variables `i` and `x` to 0. The value of variable `n` is not initialized and contains garbage value.\n- The program enters a `while` loop and executes the loop body as long as `i<n`.\n\nNow let's analyze the loop body and make a note of the loop condition:\n\n- The loop body has an `if` statement with a condition that is not explicitly defined. We can assume that the `unknown` function returns a positive integer with probability p and a non-positive integer with probability 1-p. \n- If the `unknown` function returns a positive integer, then the program executes an assertion that checks if `x` is not greater than 0. If the assertion fails, the `assume` macro returns 0 and the program terminates.\n- If the `unknown` function returns a non-positive integer, then the program assigns the value 1 to variable `x`.\n\nBased on the above analysis, we can come up with the following loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= i <= n;\n    loop invariant x >= 0;\n    loop invariant x <= 1;\n    loop invariant (i==n) ==> (x==1);\n*/\n```\n\nExplanation of the loop invariants:\n- The first loop invariant states that the value of variable `i` is always between 0 and `n`, inclusive.\n- The second loop invariant states that the value of variable `x` is always non-negative.\n- The third loop invariant states that the value of variable `x` is always less than or equal to 1.\n- The fourth loop invariant states that if the loop terminates (`i==n`), then the value of `x` must be 1. This is because if the loop terminates, then the `else` branch of the `if` statement is executed, which assigns the value 1 to `x`. Since `x` is not changed in the `if` branch, it must have the value 1 when the loop terminates. \n\nNote that we did not use the guard condition of the assertion in the loop invariant because the assertion is executed in every iteration of the loop, regardless of the value of the guard condition.",
            "Pre-conditions:\n- The function `unknown()` returns a non-negative integer.\n\nVariable assignments:\n- `x` is assigned the value `0`.\n- `i` is assigned the value `0`.\n\nLoop condition:\n- The loop executes while `i<n`.\n\nLoop invariants:\n- `0 <= i <= n`\n- `x >= 0`\n- `x <= 1`\n- If `i == 0`, then `x == 0`.\n- For all `j` such that `0 <= j < i`, if `unknown()` returned a positive value at the `j`-th iteration, then `x == 0`.\n- For all `j` such that `0 <= j < i`, if `unknown()` returned a non-positive value at the `j`-th iteration, then `x == 1`.\n\nPost-condition:\n- `x <= 0`\n\nNotice that the above loop invariants satisfy the three conditions for being a loop invariant. \n\n- They are true before the loop execution because `i` is initially `0`, so all the conditions involving `i` are true, and `x` is initially assigned `0`, which satisfies the conditions `x >= 0` and `x == 0` when `i == 0`.\n- They are true in every iteration of the loop because `i` is incremented by 1 in each iteration, so all the conditions involving `i` are updated accordingly. Moreover, the two conditions involving `j` depend only on previous iterations and do not depend on the current iteration, so they are also true in every iteration.\n- They imply the post-condition because if `x <= 1` and `x <= 0`, then `x == 0`."
        ],
        "annotation_blocks": [
            "/*@\n  loop invariant x >= 0;\n  loop invariant i >= 0;\n  loop invariant i <= n;\n  loop invariant (i < n) ==> (x <= 1);\n  loop invariant (i < n) ==> (x >= 0);\n  loop invariant i >= n;\n  loop invariant (i >= n) ==> (x <= 1);\n  loop invariant (i >= n) ==> (x >= 0);\n  loop invariant !(x > 0);\n*/",
            "/*@ \n  requires n > 0;\n*/",
            "/*@ loop invariant 0 <= i; */\n/*@ loop invariant i <= n; */",
            "/*@ \n    loop invariant 0 <= i <= n;\n    loop invariant x >= 0;\n    loop invariant x <= 1;\n    loop invariant (i==n) ==> (x==1);\n*/",
            [
                "ERROR: Output does not contain at least 1 complete code block",
                "Pre-conditions:\n- The function `unknown()` returns a non-negative integer.\n\nVariable assignments:\n- `x` is assigned the value `0`.\n- `i` is assigned the value `0`.\n\nLoop condition:\n- The loop executes while `i<n`.\n\nLoop invariants:\n- `0 <= i <= n`\n- `x >= 0`\n- `x <= 1`\n- If `i == 0`, then `x == 0`.\n- For all `j` such that `0 <= j < i`, if `unknown()` returned a positive value at the `j`-th iteration, then `x == 0`.\n- For all `j` such that `0 <= j < i`, if `unknown()` returned a non-positive value at the `j`-th iteration, then `x == 1`.\n\nPost-condition:\n- `x <= 0`\n\nNotice that the above loop invariants satisfy the three conditions for being a loop invariant. \n\n- They are true before the loop execution because `i` is initially `0`, so all the conditions involving `i` are true, and `x` is initially assigned `0`, which satisfies the conditions `x >= 0` and `x == 0` when `i == 0`.\n- They are true in every iteration of the loop because `i` is incremented by 1 in each iteration, so all the conditions involving `i` are updated accordingly. Moreover, the two conditions involving `j` depend only on previous iterations and do not depend on the current iteration, so they are also true in every iteration.\n- They imply the post-condition because if `x <= 1` and `x <= 0`, then `x == 0`."
            ]
        ],
        "completions": [
            {
                "num_solver_calls": 4,
                "annotations": "/*@\n  loop invariant x >= 0;\n  loop invariant i >= 0;\n  loop invariant i <= n;\n  loop invariant (i < n) ==> (x <= 1);\n  loop invariant (i < n) ==> (x >= 0);\n  loop invariant i >= n;\n  loop invariant (i >= n) ==> (x <= 1);\n  loop invariant (i >= n) ==> (x >= 0);\n  loop invariant !(x > 0);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant x >= 0 is partially proven to be inductive.\nloop invariant i >= 0 is partially proven to be inductive.\nloop invariant i <= n is preserved but not established.\nloop invariant (i < n) ==> (x <= 1) is partially proven to be inductive.\nloop invariant (i < n) ==> (x >= 0) is partially proven to be inductive.\nloop invariant i >= n is preserved but not established.\nloop invariant (i >= n) ==> (x <= 1) is partially proven to be inductive.\nloop invariant (i >= n) ==> (x >= 0) is partially proven to be inductive.\nloop invariant !(x > 0) is partially proven to be inductive.\nAssertion !(x > 0): Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  /*@\nloop invariant i1: x >= 0;\nloop invariant i2: i >= 0;\n\nloop invariant i4: (i < n) ==> (x <= 1);\nloop invariant i5: (i < n) ==> (x >= 0);\n\nloop invariant i7: (i >= n) ==> (x <= 1);\nloop invariant i8: (i >= n) ==> (x >= 0);\n\n*/\nwhile (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ \n  requires n > 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 11: unexpected token ''",
                "houdini_error": "No annotations found"
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ loop invariant 0 <= i; */\n/*@ loop invariant i <= n; */",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= i is partially proven to be inductive.\nloop invariant i <= n is preserved but not established.\nAssertion !(x > 0): Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  /*@\nloop invariant i1: 0 <= i;\n\n*/\nwhile (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant 0 <= i <= n;\n    loop invariant x >= 0;\n    loop invariant x <= 1;\n    loop invariant (i==n) ==> (x==1);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant 0 <= i <= n is preserved but not established.\nloop invariant x >= 0 is partially proven to be inductive.\nloop invariant x <= 1 is partially proven to be inductive.\nloop invariant (i==n) ==> (x==1) is neither established nor preserved.\nAssertion !(x > 0): Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  /*@\n\nloop invariant i2: x >= 0;\nloop invariant i3: x <= 1;\n\n*/\nwhile (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 0,
                "success": false,
                "llm_output": "Pre-conditions:\n- The function `unknown()` returns a non-negative integer.\n\nVariable assignments:\n- `x` is assigned the value `0`.\n- `i` is assigned the value `0`.\n\nLoop condition:\n- The loop executes while `i<n`.\n\nLoop invariants:\n- `0 <= i <= n`\n- `x >= 0`\n- `x <= 1`\n- If `i == 0`, then `x == 0`.\n- For all `j` such that `0 <= j < i`, if `unknown()` returned a positive value at the `j`-th iteration, then `x == 0`.\n- For all `j` such that `0 <= j < i`, if `unknown()` returned a non-positive value at the `j`-th iteration, then `x == 1`.\n\nPost-condition:\n- `x <= 0`\n\nNotice that the above loop invariants satisfy the three conditions for being a loop invariant. \n\n- They are true before the loop execution because `i` is initially `0`, so all the conditions involving `i` are true, and `x` is initially assigned `0`, which satisfies the conditions `x >= 0` and `x == 0` when `i == 0`.\n- They are true in every iteration of the loop because `i` is incremented by 1 in each iteration, so all the conditions involving `i` are updated accordingly. Moreover, the two conditions involving `j` depend only on previous iterations and do not depend on the current iteration, so they are also true in every iteration.\n- They imply the post-condition because if `x <= 1` and `x <= 0`, then `x == 0`.",
                "error": "Output does not contain at least 1 code block"
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant x >= 0 is partially proven to be inductive.\nloop invariant i >= 0 is partially proven to be inductive.\nloop invariant i <= n is preserved but not established.\nloop invariant (i < n) ==> (x <= 1) is partially proven to be inductive.\nloop invariant (i < n) ==> (x >= 0) is partially proven to be inductive.\nloop invariant i >= n is preserved but not established.\nloop invariant (i >= n) ==> (x <= 1) is partially proven to be inductive.\nloop invariant (i >= n) ==> (x >= 0) is partially proven to be inductive.\nloop invariant !(x > 0) is partially proven to be inductive.\nloop invariant 0 <= i is partially proven to be inductive.\nloop invariant 0 <= i <= n is partially proven to be inductive.\nloop invariant x <= 1 is partially proven to be inductive.\nloop invariant (i==n) ==> (x==1) is preserved but not established.\nAssertion !(x > 0): Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  /*@\nloop invariant i1: x >= 0;\nloop invariant i2: i >= 0;\nloop invariant i3: i <= n;\nloop invariant i4: (i < n) ==> (x <= 1);\nloop invariant i5: (i < n) ==> (x >= 0);\nloop invariant i6: i >= n;\nloop invariant i7: (i >= n) ==> (x <= 1);\nloop invariant i8: (i >= n) ==> (x >= 0);\nloop invariant i9: !(x > 0);\nloop invariant i10: 0 <= i;\nloop invariant i11: 0 <= i <= n;\nloop invariant i12: x <= 1;\nloop invariant i13: (i==n) ==> (x==1);\n*/\nwhile (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}",
        "combined_annotation_num_solver_calls": 4,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\n\nint unknown() {int x; return x;}\nint main(){\n  int i,n,x, NONDET;\n\n  x=0;\n  i=0;\n  /*@\nloop invariant i1: x >= 0;\nloop invariant i2: i >= 0;\n\nloop invariant i4: (i < n) ==> (x <= 1);\nloop invariant i5: (i < n) ==> (x >= 0);\n\nloop invariant i7: (i >= n) ==> (x <= 1);\nloop invariant i8: (i >= n) ==> (x >= 0);\n\nloop invariant i10: 0 <= i;\n\nloop invariant i12: x <= 1;\n\n*/\nwhile (i<n) {\n    if (unknown() >0){\n      {;\n//@ assert(!( x>0 ));\n}\n\n    }\n    else{\n      x = 1;\n    }\n    i++;\n  }\n}",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/accelerating_invariant_generation/cav/07.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/19.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/20.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/39.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv_simp.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_safe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbrprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/cars.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/ex1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifo.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/seesaw.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/bind_expands_vars2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/ken-imp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/rajamani_1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/simple_if.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/up-nested.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_infinite_loop_2_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_1_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/while_infinite_loop_2_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/bind_expands_vars2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_fig1a.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_loop_int.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime7to8_arr_three_chars_no_test_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/simple_if.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/up-nested.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/loop4_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/NetBSD_loop_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/afnp2014_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/css2003_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_1_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_2_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_true-unreach-call.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_1_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/while_infinite_loop_2_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/07.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/11.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/16.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/18.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/19.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/23.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/30.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/35.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/37.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/38.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/43.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/44.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/afnp2014_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/dec.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/decn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/ex14n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig1.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig3.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/fig9.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form25.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form27.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/inc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/incn.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/popl.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs12_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs7_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs8_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop10_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop11_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop13_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop14_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop16_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop1_VeriMAP_true.c"
        ],
        "failure": [
            "../data/benchmarks/accelerating_invariant_generation/cav/05.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/35.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/37.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/f2.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/gulv.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/pldi082_unbounded.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/substring1.c",
            "../data/benchmarks/accelerating_invariant_generation/cav/xy10.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/const_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_safe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/diamond_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/multivar_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/overflow_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/phases_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe3.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/simple_unsafe4.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_safe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe1.c",
            "../data/benchmarks/accelerating_invariant_generation/crafted/underapprox_unsafe2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/barbr.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bk-nat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/bkley.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/efm.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/fig2.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnat.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/lifnatprime.c",
            "../data/benchmarks/accelerating_invariant_generation/dagger/swim.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar1.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/gulwani_cegar2.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/id_trans.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-close-angle.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/accelerating_invariant_generation/invgen/split.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/count_up_down_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/for_bounded_loop1_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_bug02_sum01_bug02_base.case_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum01_true.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum03_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/sum04_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/terminator_02_false.c",
            "../data/benchmarks/accelerating_invariant_generation/svcomp/trex03_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/gulwani_cegar2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/id_trans.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/MADWiFi-encode_ie_ok.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/NetBSD_g_Ctoc.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/rajamani_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-close-angle.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/sendmail-mime-fromqp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/split.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe2_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/barthe_merged_unsafe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/llreve/fib_merged_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/id_trans_false-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/MADWiFi-encode_ie_ok_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-invgen/sendmail-close-angle_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/bhmr2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/cggmp2005_variant_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/ddlm2013_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gcnr2008_false-unreach-call_false-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007b_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gj2007_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gr2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/gsv2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/hhk2008_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-lit/jm2006_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_k_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/count_by_nondet_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loop-new/half_true-unreach-call_true-termination.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/count_up_down_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/for_bounded_loop1_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_bug02_sum01_bug02_base.case_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum03_true-unreach-call_false-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_02_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/terminator_03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/trex03_false-unreach-call_true-termination.i.annot.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/02.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/05.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/08.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/10.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/13.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/14.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/15.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/20.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/21.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/32.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/34.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/39.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/41.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/42.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/hola/46.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cegar2.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/cggmp2005_true-unreach-call.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/form22.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum01_safe.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum03_safe.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/sum04n.v.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/trex03.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/pie/ICE/benchmarks/w2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/cav.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/sharma_splitter/ex2.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testabs15_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop17_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop27-unsafe_VeriMAP_false.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-testloop28-unsafe_VeriMAP_false.c"
        ],
        "skipped": [],
        "total": 241,
        "success_count": 116,
        "failure_count": 125,
        "success_rate": 0.48132780082987553
    }
}