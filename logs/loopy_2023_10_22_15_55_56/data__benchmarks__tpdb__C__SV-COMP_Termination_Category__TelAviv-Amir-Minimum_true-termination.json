{
    "logs": {
        "file": "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n    while (x > 0 && y > 0) {\n    \tif (unknown_int()) {\n    \t\tif (x<y) {\n    \t\t\ty = x - 1;\n    \t\t} else {\n    \t\t\ty = y - 1;\n    \t\t}\n    \t\tx = unknown_int();\n    \t} else {\n    \t\tif (x<y) {\n    \t\t\tx = x - 1;\n    \t\t} else {\n    \t\t\tx = y - 1;\n    \t\t}\n    \t\ty = unknown_int();\n    \t}\n    }\n}",
        "success": false,
        "variants": [
            [
                "x + y"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n    while (x > 0 && y > 0) {\n    \tif (unknown_int()) {\n    \t\tif (x<y) {\n    \t\t\ty = x - 1;\n    \t\t} else {\n    \t\t\ty = y - 1;\n    \t\t}\n    \t\tx = unknown_int();\n    \t} else {\n    \t\tif (x<y) {\n    \t\t\tx = x - 1;\n    \t\t} else {\n    \t\t\tx = y - 1;\n    \t\t}\n    \t\ty = unknown_int();\n    \t}\n    }\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "1. First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n   - x and y are assigned unknown_int(), which means they can be any integer value.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body:\n   - In the loop body, x and y are decreased by at least 1 in every iteration, regardless of the branch taken. Therefore, the value of x + y will decrease with every iteration.\n   - Also, x and y are both reassigned with unknown_int() within the branches, but since the loop condition requires x > 0 and y > 0, we know that x + y is always positive while the loop is executing.\n\n3. Output the ranking function in one code block, in ACSL syntax:\n\n```\n/*@\n    loop variant x + y;\n*/\n```\n\nThis ranking function is valid because it is decreasing with every iteration of the loop and evaluates to a positive value while the loop is executing.",
            "1. First, let's identify the variables that are live at the loop head. In this case, they are `x` and `y`.\n2. Analyze the loop body. There are two branches of execution depending on the value of `unknown_int()`. In both branches, either `x` or `y` is decreased by 1, and the other variable is assigned a new value from `unknown_int()`.\n\nNow, let's find the ranking function.\n\nWe can use lexicographic ranking functions in this case. Since both `x` and `y` are getting decreased, we can use the sum of their values as the first expression in the ranking function. This guarantees that the ranking function will decrease since at least one variable is decreasing.\n\nHowever, we need to make sure that the ranking function remains positive while the loop is executing. Since `x` and `y` are both positive, their sum will also be positive.\n\nThus, the ranking function for the loop is:\n```\n/*@\n    loop variant x + y;\n*/\n```\n\nThis ranking function is valid because it is decreasing with every iteration of the loop (since either `x` or `y` is being decreased), and it is positive while the loop is executing (since both `x` and `y` are positive).",
            "1. Starting values or constraints for the variables live at the loop head:\n   - x and y are both initialized with unknown_int(), so they can be any integer value.\n\n2. Analyze the loop body:\n   - The loop continues as long as x > 0 and y > 0.\n   - In each iteration, either x or y is decreased by some positive value, and the other variable is assigned an unknown integer value.\n\n3. Find a ranking function involving the variables in the loop body:\n   - Since both x and y are always decreasing in each iteration, we can use the sum of the absolute values of x and y as the ranking function. This ensures that the value of the ranking function decreases with every iteration and is positive while the loop is executing.\n\nThe ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x + y;\n*/\n```",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head.\n\nx and y are both assigned unknown_int(), so they can be any integer value.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body.\n\nThe loop continues as long as x > 0 and y > 0. In each iteration, either x or y will be decreased, depending on the conditions inside the loop body. The minimum value of x and y is 0, and they both decrease in each iteration.\n\n3. Output the ranking function in one code block, in ACSL syntax. \n\nIn this case, the lexicographic ranking function is a single expression, as only x or y is being decreased in each iteration. Since the loop continues as long as both x and y are positive, we can use the sum of x and y as the ranking function:\n\n```c\n/*@\n    loop variant x + y;\n*/\n```\n\nThis ranking function is valid because:\n- It is positive while the loop is executing, as both x and y must be positive for the loop condition to hold.\n- It decreases with every iteration of the loop, as either x or y will be decreased in each iteration.\n- It ensures termination because when the ranking function reaches 0 (x = 0 or y = 0), the loop will exit.",
            "First, let's identify the variables that are live at the loop head and their constraints:\n- x > 0\n- y > 0\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. We can see that in each iteration, either x or y is decremented by 1, while the other variable is assigned a new unknown integer value.\n\nSince either x or y decreases in each iteration, we can use the sum of x and y as the ranking function. The ranking function should be decreasing with every iteration of the loop and evaluate to a positive value while the loop is executing.\n\nThe ranking function for the loop in the given program is:\n\n```\n/*@\n    loop variant x + y;\n*/\n```\n\nThis is a valid ranking function because the sum of x and y decreases with every iteration of the loop, as either x or y is decremented by 1, while the other variable is assigned a new unknown integer value. Additionally, since both x and y are positive while the loop is executing, their sum will also be positive."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n    while (x > 0 && y > 0) {\n    \tif (unknown_int()) {\n    \t\tif (x<y) {\n    \t\t\ty = x - 1;\n    \t\t} else {\n    \t\t\ty = y - 1;\n    \t\t}\n    \t\tx = unknown_int();\n    \t} else {\n    \t\tif (x<y) {\n    \t\t\tx = x - 1;\n    \t\t} else {\n    \t\t\tx = y - 1;\n    \t\t}\n    \t\ty = unknown_int();\n    \t}\n    }\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x + y)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's make a note of the starting values or constraints for the variables that are live at the loop head:\n- x and y are initialized with unknown_int(), which can return any integer value. Therefore, there are no known initial constraints on x and y.\n\nNow, let's analyze the loop condition and the given ranking function:\n- The loop condition is (x > 0 && y > 0).\n- The given ranking function is (x + y).\n\nNext, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant (unknown_int() ==> (x <= y && y == \\at(y, LoopEntry) - 1)) || (x == \\at(x, LoopEntry) - 1);\n    loop invariant (!unknown_int() ==> (y <= x && x == \\at(x, LoopEntry) - 1)) || (y == \\at(y, LoopEntry) - 1));\n*/\n```",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n- x and y are both initialized to unknown_int() values, so there are no constraints on their initial values.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n\n- Loop condition: x > 0 && y > 0\n- Given ranking function: (x + y)\n\nNow, we can output the loop invariants that support the loop variant (x + y) for the loop in the program:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n    loop invariant y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n*/\n```",
                    "First, let's identify the loop condition, the variables that are live at the loop head, and the ranking function:\n\n- Loop condition: `x > 0 && y > 0`\n- Live variables at loop head: `x`, `y`\n- Ranking function: `x + y`\n\nNow, let's analyze the loop body and find the loop invariants:\n\n1. Before the loop execution:\n   - Both `x` and `y` are assigned values by `unknown_int()`, so they can take any integer value.\n\n2. In every iteration of the loop:\n   - The loop condition ensures that `x` and `y` are both positive.\n   - If `unknown_int()` returns a non-zero value, either `y` is decreased by 1 or set to `x - 1`. In both cases, `y` decreases.\n   - If `unknown_int()` returns zero, either `x` is decreased by 1 or set to `y - 1`. In both cases, `x` decreases.\n   - After each iteration, either `x` or `y` is assigned a new value by `unknown_int()`.\n\n3. After the loop termination:\n   - The loop terminates when either `x` or `y` is non-positive.\n\nBased on the above analysis, we can state the loop invariants as:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant \\at(y, LoopEntry) >= 0;\n*/\n```\n\nThese loop invariants imply that the ranking function `(x + y)` decreases with every iteration, proving the termination of the loop.",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head. In this case, the variables x and y are live at the loop head, and they have unknown values.\n\nNext, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is (x > 0 && y > 0), and the given ranking function is (x + y).\n\nNow, let's output the loop invariants to support the loop variant (x + y):\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\n*/\n```\n\nThese loop invariants hold true before the loop execution, in every iteration of the loop, and after the loop termination. They imply that the ranking function (x + y) decreases with every iteration of the loop, ensuring the loop's termination.",
                    "First, we note the starting values for x and y are given by `unknown_int()` function calls, which can return any integer value. So, there are no constraints on the initial values of x and y.\n\nThe loop condition is `x > 0 && y > 0`, and the given ranking function is `(x + y)`.\n\nNow let's find the loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> x <= \\at(x, LoopEntry);\n    loop invariant \\at(y, LoopEntry) >= 0 ==> y <= \\at(y, LoopEntry);\n*/\n```\n\nThe loop invariants state the following:\n\n1. `x >= 0`: x is always non-negative during the loop execution.\n2. `y >= 0`: y is always non-negative during the loop execution.\n3. `\\at(x, LoopEntry) >= 0 ==> x <= \\at(x, LoopEntry)`: If the value of x at the beginning of the loop is non-negative, then x will be less than or equal to its initial value during the loop execution.\n4. `\\at(y, LoopEntry) >= 0 ==> y <= \\at(y, LoopEntry)`: If the value of y at the beginning of the loop is non-negative, then y will be less than or equal to its initial value during the loop execution."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant (unknown_int() ==> (x <= y && y == \\at(y, LoopEntry) - 1)) || (x == \\at(x, LoopEntry) - 1);\n    loop invariant (!unknown_int() ==> (y <= x && x == \\at(x, LoopEntry) - 1)) || (y == \\at(y, LoopEntry) - 1));\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n    loop invariant y <= \\at(x, LoopEntry) + \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant \\at(y, LoopEntry) >= 0;\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant \\at(x, LoopEntry) + \\at(y, LoopEntry) >= x + y;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> x <= \\at(x, LoopEntry);\n    loop invariant \\at(y, LoopEntry) >= 0 ==> y <= \\at(y, LoopEntry);\n*/"
                ],
                "inductive_invariants": "",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n    /*@\n\nloop variant x + y;\n*/\nwhile (x > 0 && y > 0) {\n    \tif (unknown_int()) {\n    \t\tif (x<y) {\n    \t\t\ty = x - 1;\n    \t\t} else {\n    \t\t\ty = y - 1;\n    \t\t}\n    \t\tx = unknown_int();\n    \t} else {\n    \t\tif (x<y) {\n    \t\t\tx = x - 1;\n    \t\t} else {\n    \t\t\tx = y - 1;\n    \t\t}\n    \t\ty = unknown_int();\n    \t}\n    }\n}",
                "checker_message": "\n\nLoop variant is Invalid.\n",
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c"
        ],
        "skipped": [],
        "total": 91,
        "success_count": 44,
        "failure_count": 47,
        "success_rate": 0.4835164835164835
    }
}