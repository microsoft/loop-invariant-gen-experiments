{
    "logs": {
        "file": "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
        "success": false,
        "variants": [
            [
                "an - i",
                "bn - j",
                "k - tk - 1"
            ],
            [
                "an - i",
                "bn - j"
            ],
            [
                "(an - i, bn - j, k)"
            ],
            [
                "i + j"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- i: unknown_int()\n- j: unknown_int()\n- k: unknown_int()\n- an: unknown_int()\n- bn: unknown_int()\n- tk: unknown_int()\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. We can see that the variables i, j, and k are being modified in the loop body. To find a ranking function, let's look at the loop condition:\n\nThe loop condition is:\n((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n\nWe can see that the loop condition has three branches, and in each branch, either i increases by 1, or j increases by k. The variable k is always non-decreasing as it is assigned an unknown_int() value.\n\nSo, we can use the difference between an, bn and i, j as the ranking functions as they will always be decreasing with each iteration:\n\n- an - i\n- bn - j\n- k - tk - 1\n\nHere is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - tk - 1;\n*/\n```\n\nThis is a valid ranking function because:\n1. It decreases with every iteration of the loop (i increases by 1, j increases by k, and k is non-decreasing).\n2. It evaluates to a positive value while the loop is executing (an - i >= 0, bn - j >= 0, and k - tk - 1 >= 0).",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n- i, j, k, an, bn, and tk are all assigned non-deterministic integer values using the unknown_int() function.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body:\n\n1. If (an >= i && bn >= j), i increases by 1 or j increases by k (where k is non-negative).\n2. If (an >= i && bn <= j), i increases by 1.\n3. If (an <= i && bn >= j), j increases by k (where k is non-negative).\n\nThe ranking function should decrease with every iteration, and be positive while the loop is executing. In this case, we can use a lexicographic ranking function as follows:\n\n1. Expression e1: an - i\n2. Expression e2: bn - j\n\nThe lexicographic ranking function is valid because:\n\n- Both e1 and e2 are positive while the loop is executing, as per the loop condition.\n- Either e1 decreases (when i increases), or e1 remains the same and e2 decreases (when j increases).\n\nNow, we can output the ranking function in one code block, in ACSL syntax:\n\n```\n/*@\n    loop variant an - i;\n    loop variant bn - j;\n*/\n```\n\nThis lexicographic ranking function is a valid ranking function for the given loop in the program.",
            "First, let's identify the variables that are live at the loop head. These are the variables that are involved in the loop condition and are updated inside the loop. In this case, they are `i`, `j`, `k`, `an`, `bn`, and `tk`.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. The loop condition is a combination of comparisons between `an`, `bn`, `i`, `j`, and `k` with `tk`. The loop body updates `i`, `j`, `tk`, and `k` in different branches.\n\nWe can see that `i` and `j` are incremented in different branches, and `k` is assigned a new value from `unknown_int()` after updating `tk`. We can use the following lexicographic ranking function based on the difference between `an` and `i`, `bn` and `j`, and the value of `k`:\n\n```\n/*@\n    loop variant (an - i, bn - j, k);\n*/\n```\n\nThis is a valid ranking function because:\n\n1. The values of `an - i` and `bn - j` are non-negative at the beginning of the loop, as they represent the differences between the elements of the pair `(an, bn)` and `(i, j)`. The value of `k` is also non-negative.\n\n2. The value of `an - i` decreases when `i` is incremented in the branches where `an >= i` and `bn >= j` or `an >= i` and `bn <= j`. If `an - i` remains the same, it means that `j` is incremented in the branch where `an <= i` and `bn >= j`. In this case, the value of `bn - j` decreases.\n\n3. The value of `k` is updated after every iteration where `j` is incremented, ensuring that the value of the ranking function will continue to decrease.\n\n4. The loop continues to execute as long as the ranking function remains positive.",
            "1. Starting values or constraints for the variables that are live at the loop head:\n   - i, j, k, an, bn, and tk are all integers assigned by unknown_int().\n   - The loop condition is a complex logical expression involving an, bn, i, j, k, and tk.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body:\n   - The loop body contains three conditional branches:\n     a) If an >= i and bn >= j:\n        - i increases by 1 or j increases by k, and k may be updated.\n     b) If an >= i and bn <= j:\n        - i increases by 1.\n     c) If an <= i and bn >= j:\n        - j increases by k, and k may be updated.\n   - In all branches, either i or j is increasing, and k may be updated.\n\n3. Identify a ranking function:\n   - Since either i or j is increasing in each loop iteration, we can use the sum of i and j as our ranking function.\n\nOutput the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant i + j;\n*/\n```\n\nThis ranking function is valid because the value of i + j is guaranteed to increase in each iteration of the loop. As a result, the loop is guaranteed to terminate eventually.",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- i, j, k, an, bn, and tk are all integers, but their values are unknown.\n- The loop condition is a complex boolean expression involving these variables.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body:\n\n1. If the condition (an >= i && bn >= j) holds, either i is incremented by 1, or j is incremented by k, and k is assigned an unknown value. In this case, i always increases, while j might increase or remain the same.\n\n2. If the condition (an >= i && bn <= j) holds, i is incremented by 1. In this case, i always increases.\n\n3. If the condition (an <= i && bn >= j) holds, j is incremented by k, and k is assigned an unknown value. In this case, j always increases.\n\nSo, the loop will terminate when the complex boolean condition becomes false. We can use lexicographic ranking functions to ensure the termination of this loop. In this case, we can use the differences between an and i, and between bn and j as our ranking functions.\n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant an - i;\n    loop variant bn - j;\n*/\n```\n\nThis ranking function is valid because:\n1. The values of i and j are always non-decreasing in the loop.\n2. The values of an and bn remain constant in the loop.\n3. The differences (an - i) and (bn - j) are always non-negative while the loop executes.\n4. At least one of the differences decreases in every iteration of the loop, ensuring the termination of the loop."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(an - i, bn - j, k - tk - 1)**, for the loop in the program above. Let's think step by step."
                    },
                    "Let's analyze the given code and find the loop invariants.\n\n1. Variables i, j, k, an, bn, and tk have no initial constraints except that they are integers.\n2. The loop condition is:\n   ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n3. In the loop body, variables i, j, and tk may be updated depending on the conditions.\n\nNow, let's find the loop invariants that support the loop variant (an - i, bn - j, k - tk - 1).\n\n```\n/*@ \n    loop invariant 0 <= i && i <= an;\n    loop invariant 0 <= j && j <= bn;\n    loop invariant k >= tk + 1;\n    loop invariant (an >= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(k, LoopEntry));\n    loop invariant (an >= i && bn <= j) ==> (i == \\at(i, LoopEntry) + 1);\n    loop invariant (an <= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(k, LoopEntry));\n*/\n```\n\nThese loop invariants ensure that the loop variant (an - i, bn - j, k - tk - 1) decreases with every iteration and help in proving the termination of the loop.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n\n- i, j, k, an, bn, and tk are assigned unknown_int() values, so there are no specific constraints on their initial values.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n\n- Loop condition: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n- Ranking function: (an - i, bn - j, k - tk - 1)\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant an >= i ==> \\at(j, LoopEntry) <= j;\n    loop invariant bn >= j ==> \\at(tk, LoopEntry) <= tk;\n    loop invariant an <= i ==> \\at(j, LoopEntry) <= j;\n    loop invariant an >= i ==> \\at(tk, LoopEntry) <= tk;\n    loop invariant bn <= j ==> \\at(i, LoopEntry) <= i;\n*/\n```\n\nThese loop invariants ensure that the ranking function (an - i, bn - j, k - tk - 1) decreases with every iteration of the loop, supporting the termination of the loop.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- i, j, k, an, bn, and tk are integers initialized with unknown values.\n\nNow, let's analyze the loop condition and the given ranking function:\n- Loop condition: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n- Ranking function: (an - i, bn - j, k - tk - 1)\n\nNow, let's find the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant 0 <= i <= an;\n    loop invariant 0 <= j <= bn;\n    loop invariant k >= tk + 1;\n    loop invariant (an >= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(tk, LoopEntry));\n    loop invariant (an <= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(tk, LoopEntry));\n*/\n```\n\nExplanation of loop invariants:\n\n1. `0 <= i <= an`: i always increases by 1 or remains the same in the loop, and its maximum value is an.\n2. `0 <= j <= bn`: j increases by k when the conditions (an >= i && bn >= j) or (an <= i && bn >= j) are met, and its maximum value is bn.\n3. `k >= tk + 1`: k always remains greater than or equal to tk + 1 during the loop.\n4. `(an >= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(tk, LoopEntry))`: When the condition (an >= i && bn >= j) is met, j is increased by k and tk remains the same.\n5. `(an <= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(tk, LoopEntry))`: When the condition (an <= i && bn >= j) is met, j is increased by k and tk remains the same.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n\n- i, j, k, an, bn, and tk are all integers and their initial values are given by unknown_int() function calls. We cannot make any assumptions about the values of these variables as they can be any integer.\n\nNow, let's analyze the loop condition and the given ranking function:\n\n- The loop condition is: `((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1`\n- The given ranking function is: `(an - i, bn - j, k - tk - 1)`\n\nNow, let's output the loop invariants to support the loop variant:\n\n```\n/*@ \n    loop invariant 0 <= i && i <= an;\n    loop invariant 0 <= j && j <= bn;\n    loop invariant tk <= k - 1;\n    loop invariant k >= tk + 1 ==> j == j + k ==> tk == k;\n*/\n```\n\nThese loop invariants are true:\n(i) before the loop execution,\n(ii) in every iteration of the loop and\n(iii) after the loop termination,\nsuch that the loop invariants imply that the ranking function decreases with every iteration.",
                    "We first look at the starting values or constraints for the variables that are live at the loop head:\n- i, j, k, an, bn, and tk are all integers and can take any value as they are assigned by unknown_int() function.\n\nNow, let's analyze the loop body and make a note of the loop condition:\n- Loop condition: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n\nWe can now output the loop invariants that support the loop variant (an - i, bn - j, k - tk - 1):\n\n```\n/*@ \n    loop invariant 0 <= an - i;\n    loop invariant 0 <= bn - j;\n    loop invariant 0 <= k - tk - 1;\n    loop invariant (\\forall int x; 0 <= x < i ==> an >= x);\n    loop invariant (\\forall int x; 0 <= x < j ==> bn >= x);\n*/\n```\n\nThese loop invariants imply that the ranking function (an - i, bn - j, k - tk - 1) decreases with every iteration, thus proving the termination of the loop."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant 0 <= i && i <= an;\n    loop invariant 0 <= j && j <= bn;\n    loop invariant k >= tk + 1;\n    loop invariant (an >= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(k, LoopEntry));\n    loop invariant (an >= i && bn <= j) ==> (i == \\at(i, LoopEntry) + 1);\n    loop invariant (an <= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(k, LoopEntry));\n*/",
                    "/*@ \n    loop invariant an >= i ==> \\at(j, LoopEntry) <= j;\n    loop invariant bn >= j ==> \\at(tk, LoopEntry) <= tk;\n    loop invariant an <= i ==> \\at(j, LoopEntry) <= j;\n    loop invariant an >= i ==> \\at(tk, LoopEntry) <= tk;\n    loop invariant bn <= j ==> \\at(i, LoopEntry) <= i;\n*/",
                    "/*@ \n    loop invariant 0 <= i <= an;\n    loop invariant 0 <= j <= bn;\n    loop invariant k >= tk + 1;\n    loop invariant (an >= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(tk, LoopEntry));\n    loop invariant (an <= i && bn >= j) ==> (j == \\at(j, LoopEntry) + k && tk == \\at(tk, LoopEntry));\n*/",
                    "/*@ \n    loop invariant 0 <= i && i <= an;\n    loop invariant 0 <= j && j <= bn;\n    loop invariant tk <= k - 1;\n    loop invariant k >= tk + 1 ==> j == j + k ==> tk == k;\n*/",
                    "/*@ \n    loop invariant 0 <= an - i;\n    loop invariant 0 <= bn - j;\n    loop invariant 0 <= k - tk - 1;\n    loop invariant (\\forall int x; 0 <= x < i ==> an >= x);\n    loop invariant (\\forall int x; 0 <= x < j ==> bn >= x);\n*/"
                ],
                "inductive_invariants": "loop invariant i8: bn >= j ==> \\at(tk, LoopEntry) <= tk;\nloop invariant i10: an >= i ==> \\at(tk, LoopEntry) <= tk;",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { an - i, bn - j, k - tk - 1 };\n/*@\nloop invariant i8: bn >= j ==> \\at(tk, LoopEntry) <= tk;\nloop invariant i10: an >= i ==> \\at(tk, LoopEntry) <= tk;\nloop invariant measure.a == an - i && measure.b == bn - j && measure.c == k - tk - 1;\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = an - i;\n//@ ghost measure.b = bn - j;\n//@ ghost measure.c = k - tk - 1;\n}\n\treturn 0;\n}",
                "checker_message": "loop invariant bn >= j ==> \\at(tk, LoopEntry) <= tk is inductive.\nloop invariant an >= i ==> \\at(tk, LoopEntry) <= tk is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(an - i, bn - j)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- i, j, k, an, bn, and tk are all initialized with unknown_int(), so they can be any integer value.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: `((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1`\n- Ranking function: `(an - i, bn - j)`\n\nNow, let's find the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant an >= i ==> bn >= j;\n    loop invariant an >= i ==> bn <= j;\n    loop invariant an <= i ==> bn >= j;\n    loop invariant k >= tk + 1;\n*/\n```\n\nThe loop invariants above capture the loop condition and ensure that the ranking function `(an - i, bn - j)` decreases with every iteration, proving the termination of the loop.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n\n- i, j, k, an, bn, and tk are all initially assigned an unknown integer value.\n\nNow let's analyze the loop body, condition, and the given ranking function (an - i, bn - j):\n\n- The loop condition is: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n- The ranking function is: (an - i, bn - j)\n\nLet's find the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant an >= i ==> bn >= j;\n    loop invariant an >= i ==> bn <= j;\n    loop invariant an <= i ==> bn >= j;\n    loop invariant k >= tk + 1;\n    loop invariant k >= \\at(k, LoopEntry);\n*/\n```\n\nThese loop invariants hold:\n\n1. Before the loop execution.\n2. In every iteration of the loop.\n3. After the loop termination.\n\nBy these loop invariants, we can conclude that the ranking function (an - i, bn - j) decreases with every iteration of the loop, proving the termination of the loop.",
                    "First, we can make note of the starting values or constraints for the variables that are live at the loop head:\n- i, j, k, an, bn, and tk are all integers and can take any integer value because they are assigned unknown_int() values.\n\nNext, we analyze the loop condition and the given ranking function (an - i, bn - j).\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant i <= an;\n    loop invariant j <= bn;\n    loop invariant tk <= k;\n*/\n```",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head: i, j, k, an, bn, and tk are all integers and can have any integer values since they are all initialized using `unknown_int()`.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1` and the given ranking function is (an - i, bn - j).\n\nWe'll now output loop invariants that are true (i) before the loop execution, (ii) in every iteration of the loop, and (iii) after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\nHere are the loop invariants for the given program:\n\n```\n/*@ \n    loop invariant 0 <= i && i <= an;\n    loop invariant 0 <= j && j <= bn;\n    loop invariant tk <= k;\n*/\n```\n\nThese invariants indicate that i and j are always non-negative and bounded by an and bn, respectively, and that tk is always less than or equal to k. With these invariants, we can imply that the ranking function (an - i, bn - j) decreases with every iteration, ensuring the termination of the loop.",
                    "First, let's note the starting values and constraints for the variables that are live at the loop head:\n\n- i, j, k, an, bn, and tk are all integers and their initial values are unknown.\n- The loop condition is: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n\nNow, let's output the loop invariants that support the loop variant (an - i, bn - j):\n\n```\n/*@ \n    loop invariant 0 <= i <= an;\n    loop invariant 0 <= j <= bn;\n    loop invariant tk <= k;\n    loop invariant (an >= i && bn >= j) ==> (j <= \\at(j, LoopEntry) + k);\n    loop invariant (an >= i && bn <= j) ==> (i == \\at(i, LoopEntry) + 1);\n    loop invariant (an <= i && bn >= j) ==> (j <= \\at(j, LoopEntry) + k);\n*/\n```\n\nThese loop invariants hold:\n- Before the loop execution: The initial values of i, j, and k are unknown, but since the loop condition checks for the relationships between an, bn, i, and j, the invariants hold true.\n- In every iteration of the loop: Each iteration updates i or j based on the conditions, and the invariants hold true.\n- After the loop termination: Once the loop condition is no longer satisfied, the invariants hold true, and the loop variant (an - i, bn - j) will have decreased, proving the loop termination."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant an >= i ==> bn >= j;\n    loop invariant an >= i ==> bn <= j;\n    loop invariant an <= i ==> bn >= j;\n    loop invariant k >= tk + 1;\n*/",
                    "/*@ \n    loop invariant an >= i ==> bn >= j;\n    loop invariant an >= i ==> bn <= j;\n    loop invariant an <= i ==> bn >= j;\n    loop invariant k >= tk + 1;\n    loop invariant k >= \\at(k, LoopEntry);\n*/",
                    "/*@ \n    loop invariant i <= an;\n    loop invariant j <= bn;\n    loop invariant tk <= k;\n*/",
                    "/*@ \n    loop invariant 0 <= i && i <= an;\n    loop invariant 0 <= j && j <= bn;\n    loop invariant tk <= k;\n*/",
                    "/*@ \n    loop invariant 0 <= i <= an;\n    loop invariant 0 <= j <= bn;\n    loop invariant tk <= k;\n    loop invariant (an >= i && bn >= j) ==> (j <= \\at(j, LoopEntry) + k);\n    loop invariant (an >= i && bn <= j) ==> (i == \\at(i, LoopEntry) + 1);\n    loop invariant (an <= i && bn >= j) ==> (j <= \\at(j, LoopEntry) + k);\n*/"
                ],
                "inductive_invariants": "",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { an - i, bn - j };\n/*@\n\nloop invariant measure.a == an - i && measure.b == bn - j;\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = an - i;\n//@ ghost measure.b = bn - j;\n}\n\treturn 0;\n}",
                "checker_message": "\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\n\nloop variant (an - i, bn - j, k);\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                "checker_message": "Annotation error on line 14: unexpected token ','",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(i + j)**, for the loop in the program above. Let's think step by step."
                    },
                    "Let's first make note of the starting values or constraints for the variables that are live at the loop head. All variables i, j, k, an, bn, and tk are initialized with unknown_int(), so they can have any integer value.\n\nNow let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is:\n\n```\n((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n```\n\nThe ranking function is (i + j).\n\nNow let's output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant i >= \\at(i, LoopEntry);\n    loop invariant j >= \\at(j, LoopEntry);\n    loop invariant k >= tk + 1 ==> k > \\at(k, LoopEntry);\n*/\n```",
                    "First, let's note the constraints and initial values for the variables live at the loop head:\n\n- i, j, k, an, bn, and tk are integers with unknown initial values.\n- The loop condition is: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n- The given ranking function is (i + j).\n\nNow, let's analyze the loop body and find the loop invariants that support the ranking function:\n\n1. In the case when (an >= i && bn >= j), either j increases by k or i increases by 1.\n2. In the case when (an >= i && bn <= j), i increases by 1.\n3. In the case when (an <= i && bn >= j), j increases by k.\n\nBased on the analysis, we can come up with the following loop invariants:\n\n```\n/*@ \n    loop invariant i >= \\at(i, LoopEntry);\n    loop invariant j >= \\at(j, LoopEntry);\n    loop invariant (an >= i && bn >= j) ==> i + j > \\at(i + j, LoopEntry);\n    loop invariant (an >= i && bn <= j) ==> i + j > \\at(i + j, LoopEntry);\n    loop invariant (an <= i && bn >= j) ==> i + j > \\at(i + j, LoopEntry);\n    loop invariant k >= tk + 1;\n*/\n```\n\nThese loop invariants support the given ranking function (i + j) and help prove the termination of the loop.",
                    "/*@ \n    loop invariant 0 <= i;\n    loop invariant 0 <= j;\n    loop invariant 0 <= k;\n    loop invariant 0 <= tk;\n    loop invariant 0 <= an;\n    loop invariant 0 <= bn;\n    loop invariant (an >= i && bn >= j) ==> (j <= j + k);\n    loop invariant (an >= i && bn >= j) ==> (tk <= k);\n    loop invariant (an >= i && bn <= j) ==> (i <= i + 1);\n    loop invariant (an <= i && bn >= j) ==> (j <= j + k);\n    loop invariant (an <= i && bn >= j) ==> (tk <= k);\n*/\n",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n\n- i, j, k, an, bn, and tk are all integers and can be any integer value because they are initialized by unknown_int().\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n\n- Loop condition: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n- Ranking function: (i + j)\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination:\n\n```\n/*@ \n    loop invariant \\forall int x; 0 <= x ==> i >= \\at(i, LoopEntry) + x;\n    loop invariant \\forall int y; 0 <= y ==> j >= \\at(j, LoopEntry) + y;\n    loop invariant an == \\at(an, LoopEntry);\n    loop invariant bn == \\at(bn, LoopEntry);\n    loop invariant k >= tk + 1;\n*/\n```\n\nHere's the explanation of each loop invariant:\n\n1. `i` is always non-decreasing during the loop. It increases by 1 in some iterations.\n2. `j` is always non-decreasing during the loop. It increases by `k` in some iterations.\n3. `an` remains unchanged during the loop.\n4. `bn` remains unchanged during the loop.\n5. The value of `k` is always greater than or equal to `tk + 1`.\n\nThese loop invariants imply that the ranking function (i + j) decreases with every iteration, and thus prove the termination of the loop.",
                    "Let's analyze the program and the loop:\n\n1. Variables `i`, `j`, `k`, `an`, `bn`, and `tk` are initialized with unknown values.\n2. The loop condition is `((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1`.\n3. There are three cases inside the loop:\n   - Case 1: `an >= i && bn >= j`\n     - Two sub-cases:\n       - `j = j + k; tk = k; k = unknown_int();`\n       - `i = i + 1;`\n   - Case 2: `an >= i && bn <= j`\n     - `i = i + 1;`\n   - Case 3: `an <= i && bn >= j`\n     - `j = j + k; tk = k; k = unknown_int();`\n4. The given ranking function is `(i + j)`.\n\nNow, let's find the loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= i;\n    loop invariant 0 <= j;\n    loop invariant an >= i ==> bn >= j;\n    loop invariant an >= i ==> bn <= j;\n    loop invariant an <= i ==> bn >= j;\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant i >= \\at(i, LoopEntry);\n    loop invariant j >= \\at(j, LoopEntry);\n    loop invariant k >= tk + 1 ==> k > \\at(k, LoopEntry);\n*/",
                    "/*@ \n    loop invariant i >= \\at(i, LoopEntry);\n    loop invariant j >= \\at(j, LoopEntry);\n    loop invariant (an >= i && bn >= j) ==> i + j > \\at(i + j, LoopEntry);\n    loop invariant (an >= i && bn <= j) ==> i + j > \\at(i + j, LoopEntry);\n    loop invariant (an <= i && bn >= j) ==> i + j > \\at(i + j, LoopEntry);\n    loop invariant k >= tk + 1;\n*/",
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "/*@ \n    loop invariant 0 <= i;\n    loop invariant 0 <= j;\n    loop invariant 0 <= k;\n    loop invariant 0 <= tk;\n    loop invariant 0 <= an;\n    loop invariant 0 <= bn;\n    loop invariant (an >= i && bn >= j) ==> (j <= j + k);\n    loop invariant (an >= i && bn >= j) ==> (tk <= k);\n    loop invariant (an >= i && bn <= j) ==> (i <= i + 1);\n    loop invariant (an <= i && bn >= j) ==> (j <= j + k);\n    loop invariant (an <= i && bn >= j) ==> (tk <= k);\n*/\n"
                    ],
                    "/*@ \n    loop invariant \\forall int x; 0 <= x ==> i >= \\at(i, LoopEntry) + x;\n    loop invariant \\forall int y; 0 <= y ==> j >= \\at(j, LoopEntry) + y;\n    loop invariant an == \\at(an, LoopEntry);\n    loop invariant bn == \\at(bn, LoopEntry);\n    loop invariant k >= tk + 1;\n*/",
                    "/*@ \n    loop invariant 0 <= i;\n    loop invariant 0 <= j;\n    loop invariant an >= i ==> bn >= j;\n    loop invariant an >= i ==> bn <= j;\n    loop invariant an <= i ==> bn >= j;\n*/"
                ],
                "inductive_invariants": "loop invariant i1: i >= \\at(i, LoopEntry);\nloop invariant i12: an == \\at(an, LoopEntry);\nloop invariant i13: bn == \\at(bn, LoopEntry);",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\nloop invariant i1: i >= \\at(i, LoopEntry);\nloop invariant i12: an == \\at(an, LoopEntry);\nloop invariant i13: bn == \\at(bn, LoopEntry);\nloop variant i + j;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                "checker_message": "loop invariant i >= \\at(i, LoopEntry) is inductive.\nloop invariant an == \\at(an, LoopEntry) is inductive.\nloop invariant bn == \\at(bn, LoopEntry) is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Gothenburg_v2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.08.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.03.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.02.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_AG313.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.01.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/easy2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA5.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.06.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Bangalore_v4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c"
        ],
        "skipped": [
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c"
        ],
        "total": 244,
        "success_count": 129,
        "failure_count": 115,
        "success_rate": 0.5286885245901639
    }
}