{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\twhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t}\n    return 0;\n}",
        "success": false,
        "variants": [
            [
                "x",
                "y"
            ],
            [
                "x",
                "y",
                "z"
            ],
            [
                "x + y + z"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\twhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t}\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "1. Note the starting values or constraints for the variables that are live at the loop head:\n    - x, y, and z are initialized with unknown_int() values.\n    - The loop condition is x > 0, y > 0, and z > 0.\n\n2. Analyze the loop body:\n    - If the first unknown_int() is not 0, x decreases by 1.\n    - Else, if the second unknown_int() is not 0, y decreases by 1 and z is assigned a new unknown value.\n    - Else, z decreases by 1 and x is assigned a new unknown value.\n\n3. Find a ranking function involving the variables in the loop body.\n    - The loop continues if x > 0, y > 0, and z > 0.\n    - x and y decrease independently in different branches, so we need to consider both.\n    - We can use a lexicographic ranking function (x, y) because either x or y decreases in each iteration of the loop.\n\nHere's the ranking function for the loop in the given program:\n\n```\n/*@ \n    loop variant x;\n    loop variant y;\n*/\n```\n\nThis ranking function is valid because:\n- The value of x and y is positive while the loop is executing.\n- In each iteration, either x or y decreases, ensuring that the loop will eventually terminate.",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head.\n\nAt the loop head, the variables x, y, and z are live. Their initial values are unknown, but we know that they have to be positive for the loop to execute.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body.\n\nIn the loop body, there are three cases:\n- x decreases by 1.\n- y decreases by 1, and z is assigned an unknown value.\n- z decreases by 1, and x is assigned an unknown value.\n\nWe will use lexicographic ranking functions to capture the different cases. The first expression will handle the case where x decreases, the second expression will handle the case where y decreases, and the third expression will handle the case where z decreases.\n\nHere is the ranking function:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n    loop variant z;\n*/\n``` \n\nThis ranking function is valid because:\n- x, y, and z are positive at the beginning of the loop.\n- In every iteration of the loop, at least one of x, y, or z decreases.\n- If x or y decreases, their new values are still non-negative, ensuring that the loop will eventually terminate.\n- If z decreases, its new value is still non-negative, ensuring that the loop will eventually terminate.",
            "Step 1: Make note of the starting values or constraints for the variables that are live at the loop head.\n\nThe loop condition is: x > 0, y > 0, and z > 0.\nWe don't know the initial values of x, y, and z, but we know that they are positive integers when entering the loop.\n\nStep 2: Analyze the loop body and find a ranking function involving the variables in the loop body\n\nThe loop body contains three cases:\n1. x is decreased by 1\n2. y is decreased by 1, and z is assigned an unknown value\n3. z is decreased by 1, and x is assigned an unknown value\n\nNow, let's find the ranking function.\n\nThe ranking function should be a lexicographic tuple of expressions. Here, we can have a lexicographic ranking function as (x, y, z). \n\nFor every iteration of the loop:\n- Either x decreases, or\n- x remains the same, and y decreases, or\n- x and y remain the same, and z decreases\n\nThis lexicographic ranking function is decreasing with each iteration of the loop. Also, the loop continues executing as long as x, y, and z are positive.\n\nOutput the ranking function:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n    loop variant z;\n*/\n```",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head.\n- x, y, and z are initialized with unknown_int() which means they can have any integer value.\n- The loop condition is (x > 0 && y > 0 && z > 0), so x, y, and z must be positive for the loop to execute.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body.\n- In the loop body, we can see that either x, y, or z is decreased in each iteration.\n- The value of x, y, or z can be changed to another unknown integer value in some cases, but it will always be decreased by at least 1.\n\nNow let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x + y + z;\n*/\n```\n\nThe ranking function is a valid ranking function because it involves all the variables in the loop body and their sum decreases with every successive iteration of the loop. Also, the value of the ranking function must be positive for the loop to continue executing, as x, y, and z are all positive integers.",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head:\n   x, y, and z are initialized with unknown values. The loop condition requires x > 0, y > 0, and z > 0.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body:\n   - In the first branch, x decreases by 1.\n   - In the second branch, y decreases by 1 and z is assigned an unknown value.\n   - In the third branch, z decreases by 1 and x is assigned an unknown value.\n\nNow, let's write the ranking function for this loop:\n\n```c\n/*@\n    loop variant x + y + z;\n*/\n```\n\nThis is a valid ranking function because:\n- The value of x + y + z is positive as long as x, y, and z are positive (which is required by the loop condition).\n- In every iteration of the loop, either x, y, or z decreases by 1, so the value of x + y + z decreases with every iteration.\n- As the values are integers, the loop will eventually terminate when the sum becomes non-positive."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\twhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t}\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x, y)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note the starting values and constraints for the variables live at the loop head:\n- x, y, and z are initialized with unknown_int() which can have any integer value.\n\nNext, we analyze the loop body and loop condition:\n- The loop condition is (x>0 && y>0 && z>0).\n- The ranking function is (x, y).\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant (\\at(x, LoopEntry) == x) ==> (\\at(y, LoopEntry) > y);\n*/\n```\n\nThese loop invariants hold:\n1. Before the loop execution, as x, y, and z are initialized with unknown_int() which can have any integer value, but the loop only starts if x, y, and z are all positive.\n2. In every iteration of the loop, since the loop condition ensures that x, y, and z are positive, and in each iteration, at least one of x, y, or z will decrease.\n3. After the loop termination, as the loop condition is no longer true, at least one of x, y, or z must be non-positive.\n\nThe loop invariants imply that the ranking function (x, y) decreases with every iteration, proving the loop's termination.",
                    "First, let's list the constraints and loop condition:\n\n1. The loop condition is x > 0 && y > 0 && z > 0.\n2. The ranking function is (x, y).\n\nNow, let's analyze the loop body and derive the loop invariants:\n\n1. When unknown_int() != 0, x decreases by 1.\n2. When unknown_int() == 0 and the second unknown_int() != 0, y decreases by 1 and z can take any value.\n3. When unknown_int() == 0 and the second unknown_int() == 0, z decreases by 1 and x can take any value.\n\nThe loop invariants are:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n*/\n```\n\nThese loop invariants ensure that the ranking function (x, y) decreases with every iteration, and the loop will eventually terminate.",
                    "First, let's note the starting values and constraints for the variables that are live at the loop head:\n- x, y, and z are initially assigned non-deterministic integer values.\n\nNow, let's analyze the loop condition and the given ranking function (x, y):\n- The loop condition is x > 0 && y > 0 && z > 0.\n- The given ranking function is (x, y).\n\nNext, we will output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant (\\at(x, LoopEntry) == x) ==> (\\at(y, LoopEntry) > y);\n*/\n```\n\nThese loop invariants hold:\n(i) before the loop execution, as x, y, and z are non-negative at the start.\n(ii) in every iteration of the loop, as x, y, and z are only decreased or reassigned with non-negative values.\n(iii) after the loop termination, as the loop condition ensures x, y, and z are positive during execution, and they can only decrease.\n\nThe loop invariants also imply that the ranking function (x, y) decreases with every iteration, proving the termination of the loop.",
                    "Let's first analyze the loop:\n\n- The loop condition is `x>0 && y>0 && z>0`.\n- The loop body has three branches:\n  1. If `unknown_int() != 0`, then `x = x - 1`.\n  2. If `unknown_int() != 0`, then `y = y - 1` and `z = unknown_int()`.\n  3. Otherwise, `z = z - 1` and `x = unknown_int()`.\n\nNow, let's determine the loop invariants based on the given loop variant `(x, y)`:\n\n- The value of `x` decreases in the first branch.\n- The value of `y` decreases in the second branch, while the value of `x` may change but remains non-negative.\n- The value of `z` decreases in the third branch, while the value of `x` may change but remains non-negative.\n\nBased on these observations, we can output the loop invariants:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/\n```",
                    "First, let's analyze the given program. Here are the variables that are live at the loop head:\n- x, y, and z are integers and are assigned non-deterministic values.\n\nThe loop condition is:\n- x > 0 && y > 0 && z > 0\n\nThe loop body has three possible paths:\n1. x = x - 1;\n2. y = y - 1; z = unknown_int();\n3. z = z - 1; x = unknown_int();\n\nNow, let's output the loop invariants for the given lexicographic ranking function (x, y):\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry) + 1;\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant (\\at(x, LoopEntry) == x) ==> (\\at(y, LoopEntry) > y);\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant (\\at(x, LoopEntry) == x) ==> (\\at(y, LoopEntry) > y);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry) + 1;\n*/"
                ],
                "inductive_invariants": "loop invariant i5: \\at(y, LoopEntry) >= y;\nloop invariant i11: y <= \\at(y, LoopEntry);\nloop invariant i28: y <= \\at(y, LoopEntry) + 1;",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\t//@ ghost variant_expression measure = { x, y };\n/*@\nloop invariant i5: \\at(y, LoopEntry) >= y;\nloop invariant i11: y <= \\at(y, LoopEntry);\nloop invariant i28: y <= \\at(y, LoopEntry) + 1;\nloop invariant measure.a == x && measure.b == y;\nloop variant measure for lexicographic;\n*/\nwhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t\n//@ ghost measure.a = x;\n//@ ghost measure.b = y;\n}\n    return 0;\n}",
                "checker_message": "loop invariant \\at(y, LoopEntry) >= y is inductive.\nloop invariant y <= \\at(y, LoopEntry) is inductive.\nloop invariant y <= \\at(y, LoopEntry) + 1 is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\twhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t}\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x, y, z)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- x, y, and z are initialized with unknown_int(), which can return any integer value.\n\nNow, let's analyze the loop condition and the given ranking function:\n- The loop condition is: x > 0 && y > 0 && z > 0\n- The given ranking function is (x, y, z)\n\nNow, let's find loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/\n```\n\nThe loop invariants imply the following:\n- x, y, and z are always non-negative.\n- The value of x, y, and z at the beginning of each loop iteration is always greater than or equal to their current values.\n\nThese loop invariants support the given ranking function (x, y, z) and prove the termination of the loop.",
                    "First, let's identify the constraints at the loop head and the loop condition:\n\n- Loop head constraints: x > 0, y > 0, z > 0\n- Loop condition: x > 0 && y > 0 && z > 0\n\nNow, let's analyze the loop body and the given ranking function (x, y, z):\n\nIn each iteration of the loop, at least one of the variables (x, y, or z) is decremented, while the others might remain the same or be assigned with an unknown value. Therefore, the lexicographic ranking function (x, y, z) ensures that the loop will terminate.\n\nNow, let's output the loop invariants:\n\n```\n/*@\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n    loop invariant (x > 0 && y > 0 && z > 0) ==> \\at(x, LoopEntry) > x || \\at(y, LoopEntry) > y || \\at(z, LoopEntry) > z;\n*/\n```",
                    "First, let's identify the loop condition and starting values or constraints for the variables that are live at the loop head. The loop condition is `x > 0 && y > 0 && z > 0`. The starting values of x, y, and z are non-deterministic, as they are assigned using `unknown_int()`.\n\nNow, we need to output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function (x, y, z) decreases with every iteration. \n\nHere are the loop invariants for the given program:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant x <= \\at(x, LoopEntry) || y <= \\at(y, LoopEntry) || z <= \\at(z, LoopEntry);\n*/\n```\n\nThese loop invariants imply that the values of x, y, and z are non-negative, and that at least one of x, y, or z decreases with each iteration of the loop. This supports the lexicographic ranking function (x, y, z) and proves the termination of the loop.",
                    "First, let's analyze the starting values and constraints for the variables that are live at the loop head. Since `x`, `y`, and `z` are assigned values from `unknown_int()`, we don't have any constraints on their initial values.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `x > 0 && y > 0 && z > 0`. The given ranking function is `(x, y, z)`.\n\nNext, let's find the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/\n```\n\nThese loop invariants are true before the loop execution, in every iteration of the loop, and after the loop termination. They imply that the ranking function `(x, y, z)` decreases with every iteration, proving the termination of the loop.",
                    "First, let's identify the loop head variables: x, y, and z. These variables are live at the loop head and are initialized with unknown_int().\n\nNext, let's analyze the loop condition: x > 0 && y > 0 && z > 0. The loop will only execute if all these conditions are true.\n\nThe given ranking function is a lexicographic ranking function (x, y, z). To prove the termination of the loop, we must ensure that either x decreases, or x remains the same and y decreases, or x and y remain the same and z decreases.\n\nNow, let's derive the loop invariants:\n\n1. x >= 0, y >= 0, and z >= 0: All variables must be non-negative for the loop to execute.\n2. x <= \\at(x, LoopEntry): x either decreases or remains the same in each iteration.\n3. y <= \\at(y, LoopEntry): y either decreases or remains the same in each iteration.\n4. z <= \\at(z, LoopEntry): z either decreases or remains the same in each iteration.\n\nNow, let's combine these invariants into one code block:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant z <= \\at(z, LoopEntry);\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/",
                    "/*@\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n    loop invariant (x > 0 && y > 0 && z > 0) ==> \\at(x, LoopEntry) > x || \\at(y, LoopEntry) > y || \\at(z, LoopEntry) > z;\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant x <= \\at(x, LoopEntry) || y <= \\at(y, LoopEntry) || z <= \\at(z, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant z <= \\at(z, LoopEntry);\n*/"
                ],
                "inductive_invariants": "loop invariant i5: \\at(y, LoopEntry) >= y;\nloop invariant i28: y <= \\at(y, LoopEntry);",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\t//@ ghost variant_expression measure = { x, y, z };\n/*@\nloop invariant i5: \\at(y, LoopEntry) >= y;\nloop invariant i28: y <= \\at(y, LoopEntry);\nloop invariant measure.a == x && measure.b == y && measure.c == z;\nloop variant measure for lexicographic;\n*/\nwhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t\n//@ ghost measure.a = x;\n//@ ghost measure.b = y;\n//@ ghost measure.c = z;\n}\n    return 0;\n}",
                "checker_message": "loop invariant \\at(y, LoopEntry) >= y is inductive.\nloop invariant y <= \\at(y, LoopEntry) is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\twhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t}\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x + y + z)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's make a note of the starting values or constraints for the variables that are live at the loop head:\n\n- x, y, and z are initialized to unknown_int(), which means they can be any integer value.\n\nNext, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n\n- Loop condition: x > 0 && y > 0 && z > 0\n- Ranking function: (x + y + z)\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant (unknown_int() != 0) ==> (x == \\at(x - 1, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() != 0) ==> (y == \\at(y - 1, LoopEntry) && z == \\at(z, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() == 0) ==> (z == \\at(z - 1, LoopEntry) && x == \\at(x, LoopEntry));\n*/\n```\n\nThese loop invariants ensure that the ranking function (x + y + z) decreases with every iteration of the loop, which proves the loop's termination.",
                    "First, let's analyze the given program:\n\n- Variables x, y, and z are initialized with unknown_int() values, which can be any integer.\n- The loop runs as long as x, y, and z are all greater than 0.\n- Inside the loop, there are three possible cases:\n  1. x is decreased by 1.\n  2. y is decreased by 1, and z is updated with an unknown_int() value.\n  3. z is decreased by 1, and x is updated with an unknown_int() value.\n\nNow, let's output the loop invariants that support the loop variant (x + y + z):\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant x <= \\at(x, LoopEntry) || x <= \\at(z, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant z <= \\at(z, LoopEntry) || z <= \\at(y, LoopEntry);\n*/\n```\n\nThese loop invariants satisfy the following criteria:\n- They are true before the loop execution.\n- They are true in every iteration of the loop.\n- They are true after the loop termination.\n- They imply that the ranking function (x + y + z) decreases with every iteration.",
                    "First, let's identify the starting values and constraints for the variables live at the loop head. In this case, x, y, and z are live at the loop head and are assigned non-deterministic integer values.\n\nNow, let's analyze the loop body and note the loop condition. The loop condition is (x > 0 && y > 0 && z > 0). The given ranking function is (x + y + z).\n\nFinally, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant z <= \\at(z, LoopEntry);\n    loop invariant (unknown_int() != 0) ==> (x == \\at(x, LoopEntry) - 1);\n    loop invariant (unknown_int() != 0) ==> (y == \\at(y, LoopEntry));\n    loop invariant (unknown_int() != 0) ==> (z == \\at(z, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() != 0) ==> (y == \\at(y, LoopEntry) - 1);\n    loop invariant (unknown_int() == 0 && unknown_int() != 0) ==> (x == \\at(x, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() == 0) ==> (z == \\at(z, LoopEntry) - 1);\n    loop invariant (unknown_int() == 0 && unknown_int() == 0) ==> (y == \\at(y, LoopEntry));\n*/\n```\n\nThese loop invariants imply that the ranking function (x + y + z) decreases with every iteration, and therefore the loop terminates.",
                    "First, let's make a note of the starting values and constraints for the variables that are live at the loop head. Since x, y, and z are initially assigned unknown_int(), they can have any integer value.\n\nNext, let's analyze the loop body, which consists of nested if-else statements. The loop condition is (x > 0 && y > 0 && z > 0). The given ranking function is (x + y + z).\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) == x || \\at(x, LoopEntry) == x + 1;\n    loop invariant \\at(y, LoopEntry) == y || \\at(y, LoopEntry) == y + 1;\n    loop invariant \\at(z, LoopEntry) == z || \\at(z, LoopEntry) == z + 1;\n*/\n```\n\nThe loop invariants above are true before the loop execution, in every iteration of the loop, and after the loop termination. They imply that the ranking function (x + y + z) decreases with every iteration, which proves the termination of the loop.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x, y, and z are all initialized with unknown_int(), meaning they can be any integer.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: x > 0 && y > 0 && z > 0\n- Ranking function: x + y + z\n\nNow, let's find the loop invariants that support the loop variant (x + y + z):\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/\n```\n\nThese loop invariants imply that the ranking function (x + y + z) decreases with every iteration of the loop, ensuring the termination of the loop."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant (unknown_int() != 0) ==> (x == \\at(x - 1, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() != 0) ==> (y == \\at(y - 1, LoopEntry) && z == \\at(z, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() == 0) ==> (z == \\at(z - 1, LoopEntry) && x == \\at(x, LoopEntry));\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant x <= \\at(x, LoopEntry) || x <= \\at(z, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant z <= \\at(z, LoopEntry) || z <= \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant z <= \\at(z, LoopEntry);\n    loop invariant (unknown_int() != 0) ==> (x == \\at(x, LoopEntry) - 1);\n    loop invariant (unknown_int() != 0) ==> (y == \\at(y, LoopEntry));\n    loop invariant (unknown_int() != 0) ==> (z == \\at(z, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() != 0) ==> (y == \\at(y, LoopEntry) - 1);\n    loop invariant (unknown_int() == 0 && unknown_int() != 0) ==> (x == \\at(x, LoopEntry));\n    loop invariant (unknown_int() == 0 && unknown_int() == 0) ==> (z == \\at(z, LoopEntry) - 1);\n    loop invariant (unknown_int() == 0 && unknown_int() == 0) ==> (y == \\at(y, LoopEntry));\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant z >= 0;\n    loop invariant \\at(x, LoopEntry) == x || \\at(x, LoopEntry) == x + 1;\n    loop invariant \\at(y, LoopEntry) == y || \\at(y, LoopEntry) == y + 1;\n    loop invariant \\at(z, LoopEntry) == z || \\at(z, LoopEntry) == z + 1;\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= z;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(z, LoopEntry) >= z;\n*/"
                ],
                "inductive_invariants": "loop invariant i11: y <= \\at(y, LoopEntry);\nloop invariant i36: \\at(y, LoopEntry) >= y;",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, z;\n\tx = unknown_int();\n\ty = unknown_int();\n\tz = unknown_int();\n\t/*@\nloop invariant i11: y <= \\at(y, LoopEntry);\nloop invariant i36: \\at(y, LoopEntry) >= y;\nloop variant x + y + z;\n*/\nwhile (x>0 && y>0 && z>0) {\n\t\tif (unknown_int() != 0) {\n\t\t\tx = x - 1;\n\t\t} else {if (unknown_int() != 0) {\n\t\t\ty = y - 1;\n\t\t\tz = unknown_int();\n\t\t} else {\n\t\t\tz = z - 1;\n\t\t\tx = unknown_int();\n\t\t}}\n\t}\n    return 0;\n}",
                "checker_message": "loop invariant y <= \\at(y, LoopEntry) is inductive.\nloop invariant \\at(y, LoopEntry) >= y is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Gothenburg_v2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.08.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.03.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.02.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_AG313.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.01.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/easy2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA5.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.06.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.10.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Bangalore_v4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c"
        ],
        "skipped": [
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c"
        ],
        "total": 241,
        "success_count": 127,
        "failure_count": 114,
        "success_rate": 0.5269709543568465
    }
}