{
    "logs": {
        "file": "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main()\n{\n    unsigned int val = unknown_uint();\n    int bytes = 1;\n    while( val >> bytes * 8 && bytes < 4 )\n        bytes++;\n    return 0;\n}",
        "success": true,
        "variants": [
            [
                "4 - bytes",
                "val"
            ],
            [
                "4 - bytes"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main()\n{\n    unsigned int val = unknown_uint();\n    int bytes = 1;\n    while( val >> bytes * 8 && bytes < 4 )\n        bytes++;\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head.\n\n- `val` is an unsigned integer, which means it has a non-negative value.\n- `bytes` starts with a value of 1.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body.\n\nThe loop condition checks if `(val >> bytes * 8)` is non-zero and `bytes` is less than 4. We know that `val` is an unsigned integer, so the right shift operation will decrease its value in every iteration. Also, `bytes` starts from 1 and increases by 1 in each iteration until it reaches 4.\n\nA lexicographic ranking function that decreases with every successive iteration of the loop and is positive while the loop is executing can be found as follows:\n\n- First expression: `4 - bytes`\n- Second expression: `val`\n\nNow, let's output the ranking function in ACSL syntax.\n\n```\n/*@\n    loop variant 4 - bytes;\n    loop variant val;\n*/\n```\n\nThis ranking function is valid because:\n\n1. The first expression, `4 - bytes`, decreases with every iteration since `bytes` increases by 1 in each iteration.\n2. The second expression, `val`, decreases with every iteration as the right shift operation reduces its value.\n3. Both expressions are positive while the loop is executing, as `bytes` is less than 4 and `val` is an unsigned integer.",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- `val` is an unsigned integer, initialized with an unknown value.\n- `bytes` is an integer, initialized with the value 1.\n\nNow let's analyze the loop body:\n```\nwhile (val >> bytes * 8 && bytes < 4)\n    bytes++;\n```\nIn each iteration of the loop, `bytes` is incremented by 1. The loop continues executing as long as the `val` shifted right by `bytes * 8` is non-zero, and `bytes` is less than 4.\n\nNow let's find the ranking function involving the variables in the loop body. Since `bytes` is the loop variable and its value is increasing in each iteration, we can consider the upper bound for `bytes` (which is 4) and the old value of `bytes` in every iteration as the ranking function. Thus, the ranking function is:\n\n```\n4 - bytes\n```\n\nThis ranking function is valid because it is decreasing with every iteration of the loop (since `bytes` is incremented by 1 in each iteration), and evaluates to a positive value while the loop is executing (since `bytes` is less than 4).\n\nNow let's output the ranking function in one code block, in ACSL syntax:\n\n```\n/*@\n    loop variant 4 - bytes;\n*/\n```",
            "1. Starting values or constraints for the variables live at the loop head:\n   - `val` is an unsigned integer, so its value is non-negative.\n   - `bytes` is initialized to 1.\n\n2. Analyzing the loop body:\n   - The loop condition is `val >> bytes * 8 && bytes < 4`.\n   - In each iteration, `bytes` is incremented by 1.\n\n3. Finding the ranking function:\n   - We want to find a function involving `val` and `bytes` that is positive while the loop is executing and decreases with every successive iteration of the loop.\n   - One possible ranking function is `4 - bytes`.\n\nHere is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant 4 - bytes;\n*/\n```\n\nThis ranking function is valid because:\n   - It is positive while the loop is executing, as `bytes` is always less than 4 during the loop execution (`bytes < 4` is part of the loop condition).\n   - It decreases with every iteration of the loop, as `bytes` is incremented by 1 in each iteration, making `4 - bytes` smaller.",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- `val` is an unknown unsigned integer.\n- `bytes` starts at 1.\n\nNow, let's analyze the loop body:\n- The loop condition is `val >> bytes * 8 && bytes < 4`.\n- In every iteration, `bytes` is incremented by 1.\n\nWe want to find a ranking function that decreases with every successive iteration of the loop and is positive for the loop to continue executing.\n\nFor this loop, we can use the ranking function `4 - bytes`:\n\n1. The value of `4 - bytes` is positive for the loop to continue executing because `bytes` is always less than 4 in the loop condition.\n2. The value of `4 - bytes` decreases with every successive iteration of the loop since `bytes` is incremented by 1 in each iteration.\n\nNow we can output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant 4 - bytes;\n*/\n```\n\nThis ranking function is valid because it satisfies the properties of being positive while the loop is executing and decreasing with every iteration of the loop.",
            "1. Starting values or constraints for the variables that are live at the loop head:\n    - `val` is an unsigned integer with an unknown initial value.\n    - `bytes` is an integer with an initial value of 1.\n\n2. Analyzing the loop body:\n    - The loop continues executing as long as `(val >> bytes * 8) != 0` and `bytes < 4`.\n    - With each iteration, the value of `bytes` increments by 1.\n\n3. Finding a ranking function:\n    - We need to find an expression that decreases with every iteration of the loop and is positive while the loop is executing.\n    - Let's consider the expression `4 - bytes`. This expression is positive while `bytes < 4` and decreases with each iteration, since `bytes` increments by 1.\n\nSo, the ranking function for the given loop is `4 - bytes`. In ACSL syntax:\n\n```\n/*@\n    loop variant 4 - bytes;\n*/\n```"
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main()\n{\n    unsigned int val = unknown_uint();\n    int bytes = 1;\n    while( val >> bytes * 8 && bytes < 4 )\n        bytes++;\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(4 - bytes, val)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's analyze the given program and note the constraints and starting values for the variables live at the loop head:\n\n- val is an unsigned integer and its initial value is obtained from the unknown_uint() function. Since it's an unsigned integer, it's always non-negative.\n- bytes is an integer and its initial value is 1.\n\nNext, let's analyze the loop condition and the loop body:\n\n- The loop condition is (val >> bytes * 8) && (bytes < 4).\n- Inside the loop body, bytes is incremented.\n\nNow, let's output the loop invariants to support the loop variant (4 - bytes, val):\n\n```\n/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant val == \\at(val, LoopEntry);\n    loop invariant bytes <= 4 ==> (val >> (bytes * 8)) != 0;\n    loop invariant bytes > 1 ==> (val >> ((bytes - 1) * 8)) == 0;\n*/\n```",
                    "First, let's analyze the given program and identify the loop head, loop condition, and loop body.\n\nLoop head: The start of the while loop.\nLoop condition: `val >> bytes * 8 && bytes < 4`\nLoop body: `bytes++`\n\nNow, let's find the loop invariants that support the lexicographic ranking function (4 - bytes, val).\n\n1. Before the loop execution: bytes = 1, and val is a non-negative integer (unsigned int).\n\n2. In every iteration of the loop: \n   - bytes is incremented by 1.\n   - val remains unchanged.\n\n3. After the loop termination: The loop terminates when the condition `val >> bytes * 8 && bytes < 4` is false. This means either `val >> bytes * 8` is false or `bytes >= 4`.\n\nLet's write the loop invariants:\n\n```\n/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant \\at(bytes, LoopEntry) == 1;\n    loop invariant val == \\at(val, LoopEntry);\n    loop invariant 0 <= val;\n*/\n```",
                    "First, let's note the starting values and constraints for the variables live at the loop head:\n- val is an unsigned int, initialized with an unknown value.\n- bytes is an int, initialized with the value 1.\n\nNow, let's analyze the loop condition and loop body:\n- The loop condition is \"val >> bytes * 8 && bytes < 4\".\n- The loop body increments bytes by 1.\n\nNow, let's write the loop invariants that support the validity of the ranking function (4 - bytes, val):\n\n```\n/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant 0 <= \\at(bytes, LoopEntry) <= 4;\n    loop invariant val == \\at(val, LoopEntry);\n    loop invariant val >> \\at(bytes, LoopEntry) * 8 ==> bytes < 4;\n*/\n```",
                    "First, let's note the starting values and constraints for the variables that are live at the loop head:\n- `val` is an unsigned int and is assigned a value from an unknown function. It can take any value in the range [0, UINT_MAX].\n- `bytes` is an int and is initialized to 1.\n\nNow, let's analyze the loop condition and body:\n- Loop condition: `(val >> bytes * 8) && (bytes < 4)`\n- Loop body: `bytes++`\n\nWe are given the ranking function `(4 - bytes, val)`. Let's output the loop invariants that support this ranking function:\n\n```\n/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant \\forall integer x; x >= 0 && x <= 3 ==> (val >> (x * 8)) >= (val >> (bytes * 8));\n    loop invariant val == \\at(val, LoopEntry);\n*/\n```",
                    "First, let's note the starting values and constraints for the variables that are live at the loop head:\n\n- val is an unsigned int and its value is non-deterministic, so it can take any value in the range [0, UINT_MAX].\n- bytes is initialized to 1.\n\nNow, let's analyze the loop body, loop condition, and the given ranking function:\n\n- Loop condition: val >> bytes * 8 && bytes < 4\n- Loop body: bytes is incremented by 1 in each iteration.\n- Ranking function: (4 - bytes, val)\n\nWe need to output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant 0 <= val <= UINT_MAX;\n    loop invariant \\at(val, LoopEntry) == val;\n    loop invariant val >> (bytes * 8) ==> bytes < 4;\n    loop invariant !(val >> (bytes * 8)) ==> bytes >= 4;\n*/\n```\n\nThese loop invariants ensure that:\n- bytes is always in the range [1, 4].\n- val is always in the range [0, UINT_MAX].\n- The value of val does not change during the loop execution.\n- If the loop condition is true, then bytes is less than 4, and if it is false, then bytes is greater than or equal to 4. This supports the ranking function (4 - bytes, val), which decreases with every iteration and ensures the loop's termination."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant val == \\at(val, LoopEntry);\n    loop invariant bytes <= 4 ==> (val >> (bytes * 8)) != 0;\n    loop invariant bytes > 1 ==> (val >> ((bytes - 1) * 8)) == 0;\n*/",
                    "/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant \\at(bytes, LoopEntry) == 1;\n    loop invariant val == \\at(val, LoopEntry);\n    loop invariant 0 <= val;\n*/",
                    "/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant 0 <= \\at(bytes, LoopEntry) <= 4;\n    loop invariant val == \\at(val, LoopEntry);\n    loop invariant val >> \\at(bytes, LoopEntry) * 8 ==> bytes < 4;\n*/",
                    "/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant \\forall integer x; x >= 0 && x <= 3 ==> (val >> (x * 8)) >= (val >> (bytes * 8));\n    loop invariant val == \\at(val, LoopEntry);\n*/",
                    "/*@ \n    loop invariant 1 <= bytes <= 4;\n    loop invariant 0 <= val <= UINT_MAX;\n    loop invariant \\at(val, LoopEntry) == val;\n    loop invariant val >> (bytes * 8) ==> bytes < 4;\n    loop invariant !(val >> (bytes * 8)) ==> bytes >= 4;\n*/"
                ],
                "inductive_invariants": "loop invariant i1: 1 <= bytes <= 4;\nloop invariant i2: val == \\at(val, LoopEntry);\nloop invariant i6: \\at(bytes, LoopEntry) == 1;\nloop invariant i8: 0 <= val;\nloop invariant i10: 0 <= \\at(bytes, LoopEntry) <= 4;\nloop invariant i18: \\at(val, LoopEntry) == val;",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main()\n{\n    unsigned int val = unknown_uint();\n    int bytes = 1;\n    //@ ghost variant_expression measure = { 4 - bytes, val };\n/*@\nloop invariant i1: 1 <= bytes <= 4;\nloop invariant i2: val == \\at(val, LoopEntry);\nloop invariant i6: \\at(bytes, LoopEntry) == 1;\nloop invariant i8: 0 <= val;\nloop invariant i10: 0 <= \\at(bytes, LoopEntry) <= 4;\nloop invariant i18: \\at(val, LoopEntry) == val;\nloop invariant measure.a == 4 - bytes && measure.b == val;\nloop variant measure for lexicographic;\n*/\nwhile( val >> bytes * 8 && bytes < 4 )\n        bytes++\n//@ ghost measure.a = 4 - bytes;\n//@ ghost measure.b = val;\n;\n    return 0;\n}",
                "checker_message": "No JSON report found",
                "success": false
            },
            {
                "invariant_code_blocks": [],
                "invariant_llm_output": [],
                "inductive_invariants": [
                    "Invariants not needed"
                ],
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern unsigned int unknown_uint(void);\n\nint main()\n{\n    unsigned int val = unknown_uint();\n    int bytes = 1;\n    /*@\n\nloop variant 4 - bytes;\n*/\nwhile( val >> bytes * 8 && bytes < 4 )\n        bytes++;\n    return 0;\n}",
                "success": true
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c"
        ],
        "skipped": [],
        "total": 162,
        "success_count": 86,
        "failure_count": 76,
        "success_rate": 0.5308641975308642
    }
}