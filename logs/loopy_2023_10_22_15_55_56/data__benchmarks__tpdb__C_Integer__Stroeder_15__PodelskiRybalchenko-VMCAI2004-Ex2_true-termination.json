{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x;\n    x = unknown_int();\n\twhile ( x >= 0 ) {\n\t\tx = -2*x + 10;\n\t}\n\treturn 0;\n}",
        "success": false,
        "variants": [
            [
                "x"
            ],
            [
                "2 * x + 10"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x;\n    x = unknown_int();\n\twhile ( x >= 0 ) {\n\t\tx = -2*x + 10;\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's identify the starting values and constraints for the variables that are live at the loop head. In this case, the variable `x` is live at the loop head, and its initial value is determined by the `unknown_int()` function, so we cannot determine a specific starting value for `x`. However, we know that the loop executes as long as `x >= 0`.\n\nNext, let's analyze the loop body. In each iteration of the loop, the value of `x` is updated as follows:\n\n```\nx = -2 * x + 10;\n```\n\nNow we need to find a ranking function that involves the variable `x`, decreases with every successive iteration of the loop, and remains positive while the loop is executing.\n\nWe can use the expression `x` as the ranking function. Let's see why it is a valid ranking function:\n\n1. The value of `x` is positive while the loop is executing, as the loop condition is `x >= 0`.\n2. In each iteration, the value of `x` is updated to `-2 * x + 10`. If `x` is positive, then `-2 * x` is negative, and so `-2 * x + 10` is less than `10`. Therefore, the value of `x` decreases with every successive iteration of the loop.\n\nNow we can output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "1. Starting values or constraints for the variables:\n   x is assigned an unknown integer value.\n\n2. Analyzing the loop body:\n   The loop executes while x >= 0. In the loop body, x is updated to -2 * x + 10.\n\n3. Finding the ranking function:\n   Since x is decreased by 2 * x and then increased by 10 in each iteration, we can use the following ranking function: 2 * x + 10.\n\nNow, let's output the ranking function in ACSL syntax.\n\n```\n/*@\n    loop variant 2 * x + 10;\n*/\n```",
            "1. Starting values or constraints for variables live at the loop head:\n   - x is an integer and its initial value is unknown.\n\n2. Analyzing the loop body and finding a ranking function:\n   - In each iteration of the loop, x is updated as x = -2*x + 10.\n   - The loop continues as long as x >= 0.\n\nNow, let's find the ranking function. One possible ranking function is `v = x`, because:\n\n- The value of x must be positive for the loop to continue executing (x >= 0).\n- In each iteration of the loop, x is updated as x = -2*x + 10. Since x >= 0, the new value of x will be less than or equal to the old value of x. Therefore, the value of x decreases with every iteration of the loop.\n\nWe can now write the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "First, let's note the starting values or constraints for the variables that are live at the loop head.\n\n- x is initialized with an unknown integer value.\n\nNow, let's analyze the loop body to find a ranking function involving the variables in the loop body.\n\nThe loop condition is `x >= 0`, so the loop continues executing as long as x is non-negative. In the loop body, we have `x = -2*x + 10`. This means that the value of x is updated to be twice its current negative value plus 10 in every iteration.\n\nNow, let's find a ranking function.\n\nWe know that the loop continues executing as long as x is non-negative. We can use x itself as the ranking function, as it decreases with every iteration and is positive while the loop executes.\n\nSo, the ranking function is:\n```\n/*@\n    loop variant x;\n*/\n```\n\nThis is a valid ranking function because:\n- x is decreasing with every iteration, as the value of x is updated to be twice its current negative value plus 10 in every iteration.\n- x is positive while the loop executes, as the loop condition `x >= 0` ensures that the loop continues executing as long as x is non-negative.",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head:\n- x is assigned an unknown integer value, so there is no constraint on its starting value.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body:\n- The loop condition is x >= 0.\n- In each iteration, x is updated as x = -2*x + 10.\n\nNow let's find the ranking function:\n\nSince x is initially non-negative and x is updated as x = -2*x + 10 in each iteration, we can see that x will decrease in each iteration. Let's make x the first expression in the lexicographic ranking function.\n\nThe loop terminates when x becomes negative, so while the loop is executing, x must be non-negative. Therefore, the ranking function is valid.\n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```"
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x;\n    x = unknown_int();\n\twhile ( x >= 0 ) {\n\t\tx = -2*x + 10;\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note down the starting values or constraints for the variables that are live at the loop head. In this case, we have `x` which is initialized using the `unknown_int()` function. We have no information about its initial value, so we cannot make any assumptions about it.\n\nNext, analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `x >= 0`, and the ranking function is `(x)`.\n\nNow, let's find the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant x >= -5;\n*/\n```\n\nHere, the first loop invariant states that the value of `x` at the beginning of the loop is always non-negative, which is consistent with the loop condition `x >= 0`. The second loop invariant states that `x` is always greater than or equal to -5, which is derived from the fact that in each loop iteration, `x` is updated with the expression `-2*x + 10`. Since `x` starts non-negative, it will always be greater than or equal to -5.",
                    "First, let's analyze the given program and identify the loop head and loop condition.\n\nLoop head: `while ( x >= 0 )`\nLoop condition: `x >= 0`\nRanking function: `x`\n\nNow, let's find loop invariants that support the ranking function.\n\n1. The loop executes as long as `x >= 0`.\n2. In each iteration of the loop, `x` is updated to `-2*x + 10`.\n3. The ranking function `x` is guaranteed to decrease with each iteration since `x` is updated to a smaller value.\n\nConsidering these points, we can now output the loop invariants:\n\n```c\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n*/\n```",
                    "First, let's analyze the given program:\n\n- The variable `x` is initialized with an unknown integer value.\n- The loop condition is `x >= 0`.\n- In the loop body, `x` is updated as `x = -2 * x + 10`.\n\nNow, let's find the loop invariants that support the ranking function `(x)`:\n\n1. Before the loop execution, the value of `x` is unknown, so we cannot make any assumptions about its initial value.\n\n2. In every iteration of the loop, `x` is always non-negative due to the loop condition `x >= 0`. Also, since `x` is updated as `x = -2 * x + 10`, we know that the new value of `x` will always be smaller than the previous value as long as `x` remains non-negative.\n\n3. After the loop termination, the loop condition `x >= 0` is no longer true, which means that `x` must be negative.\n\nBased on the above analysis, we can write the following loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant \\at(x, LoopEntry) >= x;\n*/\n```",
                    "First, let's identify the variables live at the loop head and their starting values or constraints. In this case, the variable live at the loop head is `x`, and it is assigned an unknown integer value before the loop.\n\nNext, let's analyze the loop condition and the given ranking function. The loop condition is `x >= 0`, and the ranking function is `(x)`.\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant 0 <= x <= INT_MAX;\n*/\n```\n\nThis loop invariant states that `x` is always non-negative and bounded by the maximum value of an integer. This invariant is true before the loop execution as `x` is assigned an unknown integer value. It also holds during the loop execution as the loop condition ensures that `x >= 0`. Finally, it holds after the loop termination, as the loop terminates when `x` becomes negative, which means that the last value of `x` was non-negative and less than or equal to INT_MAX.",
                    "First, let's identify the loop head and the ranking function. The loop head is `while (x >= 0)` and the ranking function is (x).\n\nNow, we'll analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `x >= 0` and the given ranking function is (x).\n\nWe need to find loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\nLet's output the loop invariants:\n\n```\n/*@ \n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant x >= -5;\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant x >= -5;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant \\at(x, LoopEntry) >= x;\n*/",
                    "/*@ \n    loop invariant 0 <= x <= INT_MAX;\n*/",
                    "/*@ \n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant x >= -5;\n*/"
                ],
                "inductive_invariants": "",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x;\n    x = unknown_int();\n\t/*@\n\nloop variant x;\n*/\nwhile ( x >= 0 ) {\n\t\tx = -2*x + 10;\n\t}\n\treturn 0;\n}",
                "checker_message": "\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x;\n    x = unknown_int();\n\twhile ( x >= 0 ) {\n\t\tx = -2*x + 10;\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(2 * x + 10)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's analyze the given program:\n\n1. x is initialized with an unknown integer value.\n2. The loop condition is \"x >= 0\".\n3. Inside the loop, x is updated using the expression \"-2 * x + 10\".\n\nNow, let's find the loop invariants to support the loop variant (2 * x + 10):\n\n- Before the loop execution:\n  - x is an integer (no specific bounds known).\n\n- In every iteration of the loop:\n  - x >= 0 (loop condition)\n  - x' = -2 * x + 10 (x' is the value of x in the next iteration)\n\n- After the loop termination:\n  - x < 0 (loop termination condition)\n\nNow let's output the loop invariants:\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant x >= 0;\n*/\n```",
                    "First, let's analyze the program:\n\n1. x is initialized with an unknown integer value.\n2. The loop condition is \"x >= 0\".\n3. Inside the loop, x is updated as \"x = -2 * x + 10\".\n\nNow, let's find the loop invariants:\n\n1. Before the loop execution, the value of x is unknown. There is no constraint on x.\n2. In every iteration, the loop condition is true: x >= 0.\n3. After the loop termination, the loop condition is false: x < 0.\n\nWe also need to find the relationship between x and the loop variant (2 * x + 10):\n\n1. The loop variant is always non-negative: 2 * x + 10 >= 0.\n2. The loop variant decreases with every iteration: x_new = -2 * x_old + 10, so (2 * x_new + 10) < (2 * x_old + 10).\n\nGiven these observations, we can now write the loop invariants:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant 2 * x + 10 >= 0;\n    loop invariant \\at(2 * x + 10, LoopEntry) > 2 * x + 10;\n*/\n```",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- x is initialized by the call to unknown_int(), so it can have any integer value.\n\nNext, let's analyze the loop body, loop condition, and the given ranking function:\n- Loop condition: x >= 0\n- Loop body: x = -2 * x + 10\n- Ranking function: 2 * x + 10\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant x >= -5;\n    loop invariant 2 * x + 10 >= 0;\n*/\n```\n\nThese loop invariants hold:\n(i) before the loop execution: x can have any integer value, so x <= \\at(x, LoopEntry) is true. x >= -5 and 2 * x + 10 >= 0 hold for any value of x that satisfies the loop condition x >= 0.\n(ii) in every iteration of the loop: as x gets updated to -2 * x + 10, it will be less than or equal to its previous value. Also, x will always be greater than or equal to -5, and 2 * x + 10 will always be non-negative.\n(iii) after the loop termination: the invariants still hold, as they are constraints on the values of x during the loop execution.",
                    "First, let's analyze the given program:\n\n- x is initialized with an unknown integer value.\n- The loop condition is x >= 0.\n- Inside the loop, x is updated with the expression -2 * x + 10.\n\nNow, let's find the loop invariants that support the loop variant (2 * x + 10):\n\n1. Before the loop execution, x can be any integer value.\n2. In every iteration of the loop, x is updated with the expression -2 * x + 10, and the loop continues as long as x >= 0.\n3. After the loop termination, x must be negative.\n\nWith these observations, we can write the loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= x <= \\at(x, LoopEntry);\n    loop invariant 2 * x + 10 >= 0;\n*/\n```",
                    "Let's analyze the given program:\n\n1. x is initialized with an unknown integer value.\n2. The loop continues while x is greater than or equal to 0.\n3. In the loop body, x is updated to -2 * x + 10.\n\nNow, let's write the loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= x <= INT_MAX;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> 2 * x + 10 > \\at(x, LoopEntry);\n*/\n```\n\nIn the loop invariants, we state that:\n1. x is always between 0 and INT_MAX.\n2. If x is greater than or equal to 0 at the beginning of the loop, then 2 * x + 10 must be greater than the initial value of x. This ensures that the ranking function (2 * x + 10) decreases with every iteration."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant x >= 0;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant 2 * x + 10 >= 0;\n    loop invariant \\at(2 * x + 10, LoopEntry) > 2 * x + 10;\n*/",
                    "/*@ \n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant x >= -5;\n    loop invariant 2 * x + 10 >= 0;\n*/",
                    "/*@ \n    loop invariant 0 <= x <= \\at(x, LoopEntry);\n    loop invariant 2 * x + 10 >= 0;\n*/",
                    "/*@ \n    loop invariant 0 <= x <= INT_MAX;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> 2 * x + 10 > \\at(x, LoopEntry);\n*/"
                ],
                "inductive_invariants": "",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x;\n    x = unknown_int();\n\t/*@\n\nloop variant 2 * x + 10;\n*/\nwhile ( x >= 0 ) {\n\t\tx = -2*x + 10;\n\t}\n\treturn 0;\n}",
                "checker_message": "\n\nLoop variant is Invalid.\n",
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c"
        ],
        "skipped": [],
        "total": 146,
        "success_count": 74,
        "failure_count": 72,
        "success_rate": 0.5068493150684932
    }
}