{
    "logs": {
        "file": "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tint z = unknown_int();\n\tif (2*y < z) {\n\t\treturn 0;\n\t}\n\twhile (x >= 0 && z == 1) {\n\t\tx = x - 2*y + 1;\n\t}\n\treturn 0;\n}",
        "success": true,
        "variants": [
            [
                "x"
            ],
            [
                "v"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tint z = unknown_int();\n\tif (2*y < z) {\n\t\treturn 0;\n\t}\n\twhile (x >= 0 && z == 1) {\n\t\tx = x - 2*y + 1;\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n- x = unknown_int() (no specific constraints)\n- y = unknown_int() (no specific constraints)\n- z = unknown_int() (no specific constraints)\n- Constraint: 2 * y < z\n\nNow let's analyze the loop body:\n\n```\nwhile (x >= 0 && z == 1) {\n    x = x - 2*y + 1;\n}\n```\n\nFind a ranking function involving the variables in the loop body. Since `x` is updated in every iteration, we can use `x` as part of our ranking function. \n\nNotice that `x` is decreasing by `2*y - 1` in every iteration. Since `2*y < z`, we know that `2*y` is less than `z`. As `z == 1`, we have `2*y < 1`. This implies that `y < 0.5`, and since `y` is an integer, it must be `y <= 0`. As `x >= 0`, we can use `x` as our ranking function.\n\nHere is the ranking function:\n\n```\n/*@\n    loop variant x;\n*/\n```\n\nThis ranking function is valid because `x` is decreasing (by `2*y - 1` in every iteration) and remains positive while the loop is executing.",
            "First, let's identify the variables that are live at the loop head. In this case, the variables are x, y, and z.\n\nNow, we analyze the loop body. In each iteration, the value of x is updated as `x = x - 2*y + 1`. The values of y and z remain unchanged.\n\nWe need to find a ranking function that decreases with each iteration and is positive while the loop is executing. Since x is the only variable that changes in the loop, our ranking function should involve x.\n\nConsidering the loop condition `x >= 0 && z == 1`, we know that the loop will only execute if x is non-negative and z equals 1. Since z is not changing within the loop, we can focus on x.\n\nLet's define the ranking function as `v = x`. Now let's check if this function satisfies the required conditions:\n\n1. Decreasing with each iteration: In each iteration, the value of x is reduced by `2*y - 1`, and since `2*y > z` (as mentioned in the if statement before the loop), we know that `2*y - 1 > 0`. Hence, the ranking function `v = x` decreases with each iteration.\n\n2. Positive while the loop is executing: As the loop condition requires x to be non-negative, the ranking function `v = x` will be positive as long as the loop executes.\n\nSo, the ranking function for this loop is `v = x`. In ACSL syntax, we can write this as:\n\n```\n/*@\n    loop variant v;\n*/\n```\n\nwhere `v = x`.",
            "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x is an unknown integer value\n- y is an unknown integer value\n- z is an unknown integer value with the constraint that 2*y >= z\n\nThe loop body consists of a single statement:\n- x = x - 2*y + 1;\n\nNow, let's find a ranking function involving the variables in the loop body. The loop continues to execute as long as x >= 0 and z == 1. The value of z remains constant throughout the loop, so we can focus on the value of x. In each iteration, x is decreased by 2*y - 1.\n\nWe can use the value of x as our ranking function, as it is decreasing in each iteration and must be positive for the loop to continue executing.\n\nThe ranking function for the loop is:\n\n```\n/*@\n    loop variant x;\n*/\n```\n\nThis is a valid ranking function because:\n- x is positive while the loop is executing, as the loop condition requires x >= 0.\n- x is decreasing in each iteration, as it is updated by subtracting 2*y - 1, and y is non-negative due to the constraint 2*y >= z.",
            "First, let's note the starting values or constraints for the variables that are live at the loop head:\n\n1. `x` is an unknown integer value.\n2. `y` is an unknown integer value.\n3. `z` is an unknown integer value, and `2*y >= z` due to the initial condition `if (2*y < z) { return 0; }`.\n\nNow, let's analyze the loop body:\n\n```\nwhile (x >= 0 && z == 1) {\n\tx = x - 2*y + 1;\n}\n```\n\nThe loop executes as long as `x >= 0` and `z == 1`. In each iteration, `x` is updated by subtracting `2*y - 1`. Since `z == 1`, we know that `2*y >= 1`.\n\nWe can now find a ranking function involving the variables in the loop body:\n\nA valid ranking function for this loop is `x`. This is because:\n\n1. `x` is a positive value when the loop starts (due to the loop condition `x >= 0`).\n2. In each iteration, `x` is decreased by at least 1 (since `x = x - 2*y + 1` and `2*y >= 1`).\n3. The loop terminates when `x` becomes negative.\n\nSo, the ranking function is:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "1. Make note of the starting values or constraints for the variables that are live at the loop head.\n- x, y, and z are live at the loop head.\n- 2*y < z initially, but since z is not modified in the loop, this constraint holds throughout the loop execution.\n- x is non-negative and z is equal to 1 for the loop to execute.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body.\n- In the loop body, x is updated as x = x - 2*y + 1.\n- Since x is non-negative at the beginning of the loop and decreases with each iteration, we can use x as the ranking function.\n\nNow we can output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```\n\nThis is a valid ranking function because:\n- The value of x is non-negative (x >= 0) for the loop to execute.\n- The value of x decreases with every iteration (x = x - 2*y + 1) since 2*y is always greater than 1 due to the constraint 2*y < z and z == 1.\n- The loop terminates when x becomes negative (x < 0)."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tint z = unknown_int();\n\tif (2*y < z) {\n\t\treturn 0;\n\t}\n\twhile (x >= 0 && z == 1) {\n\t\tx = x - 2*y + 1;\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n- x, y, and z are initialized with unknown_int(), so they can have any integer value.\n- The condition (2 * y < z) must be false for the loop to be entered, meaning 2 * y >= z.\n\nNow, let's analyze the loop condition and the given ranking function:\n\n- Loop condition: x >= 0 && z == 1\n- Ranking function: x\n\nBased on this information, we can output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant z == 1;\n    loop invariant 2*y >= z;\n    loop invariant \\at(x, LoopEntry) >= x;\n*/\n```",
                    "First, let's analyze the given program:\n\n1. `x`, `y`, and `z` are initialized with unknown integer values.\n2. If `2*y < z`, the program terminates early, so we should consider the case where `2*y >= z`.\n3. The loop condition is `(x >= 0 && z == 1)`, so the loop will execute only if `x >= 0` and `z == 1`.\n4. Inside the loop, `x` is updated as `x = x - 2*y + 1`.\n\nNow, let's derive the loop invariants to support the loop variant `(x)`:\n\n- Before the loop execution, we know that `2*y >= z`, which means that `y >= z/2`.\n- In every iteration of the loop, `x` decreases by `2*y - 1` since `x = x - 2*y + 1`. So, the value of `x` decreases with every iteration.\n- After the loop termination, the loop condition `(x >= 0 && z == 1)` becomes false. Since `z` is not updated in the loop, its value remains the same throughout the loop. Therefore, `x < 0` when the loop terminates.\n\nBased on the above analysis, we can write the loop invariants as:\n\n```\n/*@ \n    loop invariant 2*y >= z;\n    loop invariant y >= z/2;\n    loop invariant x >= \\at(x, LoopEntry) - (2*y - 1) * (\\at(x, LoopEntry) - x);\n    loop invariant z == 1 ==> x >= 0;\n*/\n```",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x, y, and z are all initialized with unknown_int(), which means they can have any integer value.\n- The condition \"2*y < z\" must be false for the program to proceed to the loop, which means \"2*y >= z\".\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- The loop condition is \"x >= 0 && z == 1\".\n- The ranking function is (x).\n\nNow, we can output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant 2*y >= z;\n    loop invariant x >= \\at(x, LoopEntry) - 2*y + 1;\n    loop invariant y == \\at(y, LoopEntry);\n    loop invariant z == \\at(z, LoopEntry);\n*/\n```\n\nExplanation:\n- The first invariant ensures that the initial condition \"2*y >= z\" holds throughout the loop.\n- The second invariant ensures that x decreases with every iteration of the loop, as x = x - 2*y + 1.\n- The third and fourth invariants ensure that the values of y and z remain constant throughout the loop.",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head.\n\nAt the loop head, x, y, and z are live variables. We have the following constraints:\n1. 2*y < z (given by the if condition)\n2. x, y, and z are integers (given by the unknown_int function)\n\nNow let's analyze the loop body and make a note of the loop condition and the given ranking function.\n\nLoop condition: x >= 0 && z == 1\nRanking function: x\n\nWe need to find loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function (x) decreases with every iteration.\n\nLoop invariants:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant z == 1;\n    loop invariant 2*y < z;\n    loop invariant \\forall integer i; 0 <= i <= x ==> x - 2*y*i + 1 >= 0;\n*/\n```",
                    "Step 1: Make note of the starting values or constraints for the variables that are live at the loop head.\n\nThe variables live at the loop head are x, y, and z. The constraints for these variables are:\n- 2 * y < z (from the if condition)\n- x, y, and z can be any integer values (since they are assigned by unknown_int())\n\nStep 2: Analyze the loop body and make a note of the loop condition and the given ranking function.\n\nThe loop condition is (x >= 0 && z == 1), and the given ranking function is (x).\n\nStep 3: Output loop invariants that are true (i) before the loop execution, (ii) in every iteration of the loop and (iii) after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\nHere are the loop invariants:\n\n```\n/*@ \n    loop invariant 2 * y < z;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant x >= 0 ==> z == 1;\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant z == 1;\n    loop invariant 2*y >= z;\n    loop invariant \\at(x, LoopEntry) >= x;\n*/",
                    "/*@ \n    loop invariant 2*y >= z;\n    loop invariant y >= z/2;\n    loop invariant x >= \\at(x, LoopEntry) - (2*y - 1) * (\\at(x, LoopEntry) - x);\n    loop invariant z == 1 ==> x >= 0;\n*/",
                    "/*@ \n    loop invariant 2*y >= z;\n    loop invariant x >= \\at(x, LoopEntry) - 2*y + 1;\n    loop invariant y == \\at(y, LoopEntry);\n    loop invariant z == \\at(z, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant z == 1;\n    loop invariant 2*y < z;\n    loop invariant \\forall integer i; 0 <= i <= x ==> x - 2*y*i + 1 >= 0;\n*/",
                    "/*@ \n    loop invariant 2 * y < z;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant x >= 0 ==> z == 1;\n*/"
                ],
                "inductive_invariants": "loop invariant i3: 2*y >= z;\nloop invariant i4: \\at(x, LoopEntry) >= x;\nloop invariant i6: y >= z/2;\nloop invariant i7: x >= \\at(x, LoopEntry) - (2*y - 1) * (\\at(x, LoopEntry) - x);\nloop invariant i11: y == \\at(y, LoopEntry);\nloop invariant i12: z == \\at(z, LoopEntry);",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tint z = unknown_int();\n\tif (2*y < z) {\n\t\treturn 0;\n\t}\n\t/*@\nloop invariant i3: 2*y >= z;\nloop invariant i4: \\at(x, LoopEntry) >= x;\nloop invariant i6: y >= z/2;\nloop invariant i7: x >= \\at(x, LoopEntry) - (2*y - 1) * (\\at(x, LoopEntry) - x);\nloop invariant i11: y == \\at(y, LoopEntry);\nloop invariant i12: z == \\at(z, LoopEntry);\nloop variant x;\n*/\nwhile (x >= 0 && z == 1) {\n\t\tx = x - 2*y + 1;\n\t}\n\treturn 0;\n}",
                "checker_message": "loop invariant 2*y >= z is inductive.\nloop invariant \\at(x, LoopEntry) >= x is inductive.\nloop invariant y >= z/2 is inductive.\nloop invariant x >= \\at(x, LoopEntry) - (2*y - 1) * (\\at(x, LoopEntry) - x) is inductive.\nloop invariant y == \\at(y, LoopEntry) is inductive.\nloop invariant z == \\at(z, LoopEntry) is inductive.\n\nLoop variant is Valid.\n",
                "success": true
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c"
        ],
        "skipped": [],
        "total": 68,
        "success_count": 31,
        "failure_count": 37,
        "success_rate": 0.45588235294117646
    }
}