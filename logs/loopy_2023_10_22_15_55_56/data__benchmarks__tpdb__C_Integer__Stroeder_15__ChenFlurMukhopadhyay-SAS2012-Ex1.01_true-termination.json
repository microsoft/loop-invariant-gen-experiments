{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x;\n    x = unknown_int();\n    while (x > 0) {\n        x = -2*x + 10;\n    }\n    return 0;\n}",
        "success": false,
        "variants": [
            [
                "x"
            ],
            [
                "2 * x"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x;\n    x = unknown_int();\n    while (x > 0) {\n        x = -2*x + 10;\n    }\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head.\n\nThe variable `x` is live at the loop head, and its initial value is unknown. However, we know that the loop executes while `x > 0`.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. In the loop body, `x` is updated with the following expression: `x = -2 * x + 10`.\n\nTo find the ranking function, we need an expression that decreases with every iteration of the loop and is positive while the loop executes.\n\nLet's consider the loop variant `v = x`. Since the loop continues to execute while `x > 0`, the value of `v` is always positive while the loop is executing.\n\nNow, let's check if `v` decreases with every iteration of the loop. In each iteration, `x` is updated as `x = -2 * x + 10`. We know that `x > 0`, so `-2 * x < 0`. Therefore, `-2 * x + 10` is strictly less than `x`, which means that `v` decreases with every iteration of the loop.\n\nThus, the ranking function for this loop is `v = x`. Here is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "1. Starting values or constraints for the variables that are live at the loop head:\n   - `x` is an integer assigned with an unknown value.\n\n2. Analyzing the loop body:\n   - Loop condition: `x > 0`\n   - Loop body: `x = -2*x + 10`\n\nNow, let's find a ranking function for the loop.\n\nConsider the expression `x`. In each iteration, the value of `x` decreases as it is multiplied by `-2` and added to `10`. The loop continues while `x > 0`. Therefore, the ranking function for this loop is `x`. \n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "First, let's analyze the starting values and constraints for the variables live at the loop head.\n\n- x is initialized with an unknown integer value.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body.\n\n- The loop condition is x > 0.\n- Inside the loop, x is updated with the expression -2*x + 10.\n\nThe ranking function for this loop is x. Let's explain why it's a valid ranking function:\n\n1. The value of x must be positive for the loop to continue executing. This is true because the loop condition is x > 0.\n2. The value of x must decrease with every successive iteration of the loop. In each iteration, x is updated with the expression -2*x + 10. Since x > 0, -2*x is negative, and -2*x + 10 is strictly less than x. Therefore, the value of x decreases with every iteration.\n\nNow, let's output the ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant x;\n*/\n```",
            "First, let's analyze the loop and make note of the starting values or constraints for the variables that are live at the loop head.\n\nIn this program, the loop variable is `x`. Initially, `x` is assigned an unknown integer value. The loop condition is `x > 0`, meaning the loop will continue to execute as long as `x` is positive.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. The loop body updates `x` with the expression `-2 * x + 10`.\n\nA suitable ranking function for this loop can be `x`. Let's show that this ranking function is valid:\n\n1. `x` is a positive value when the loop is executing, as indicated by the loop condition `x > 0`.\n2. With every iteration of the loop, the value of `x` decreases, as `x` is updated with the expression `-2 * x + 10`. Since `x` is positive, `-2 * x` will be negative, and therefore `-2 * x + 10` will be less than the previous value of `x`.\n\nNow let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n*/\n```",
            "First, let's note the starting values or constraints for the variables that are live at the loop head.\n\n- The value of `x` is non-deterministic, as it is assigned using `unknown_int()`. However, we know that the loop will only execute if `x > 0`.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body.\n\n- In each iteration of the loop, `x` is updated as `x = -2 * x + 10`.\n\nLet's find a ranking function:\n\n- We know that `x > 0` for the loop to execute. And in each iteration, `x` is updated to `-2 * x + 10`. \n- Since `x > 0`, we have `-2 * x < 0`. Thus, `-2 * x + 10 < 10`. \n- We can use `10 - (-2 * x + 10)` as the ranking function, which simplifies to `2 * x`.\n\nSo, the ranking function for the loop is `2 * x`.\n\nNow, let's verify if it is a valid ranking function:\n\n- For the loop to execute, `x > 0`. Thus, the ranking function `2 * x` is positive.\n- In each iteration, `x` is updated to `-2 * x + 10`. Since `x > 0`, the new value of `x` is less than its previous value. Hence, the ranking function `2 * x` is decreasing with every iteration.\n\nNow, let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant 2 * x;\n*/\n```"
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x;\n    x = unknown_int();\n    while (x > 0) {\n        x = -2*x + 10;\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's analyze the program and make a note of the starting values or constraints for the variables that are live at the loop head. We have one variable `x`, which is initialized with an unknown value from the `unknown_int()` function.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `x > 0`, and the ranking function is `(x)`.\n\nWe can now output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n*/\n```\n\nThe first loop invariant states that `x` is always non-negative during the loop execution. This is true because the loop condition requires `x > 0` for the loop to execute, and the loop body updates `x` to `-2*x + 10`, which is always non-negative for positive `x`. The second loop invariant states that the value of `x` at the current iteration is always less than or equal to its value at the loop entry. This is true because the loop body updates `x` to a smaller value in every iteration, and the loop condition ensures that the loop terminates when `x` is no longer positive.\n\nThese loop invariants support the validity of the ranking function `(x)` and prove the termination of the loop.",
                    "First, let's identify the variables that are live at the loop head and their constraints:\n\n- x: no constraints other than being an integer.\n\nNext, let's analyze the loop condition and the given ranking function:\n\n- Loop condition: x > 0\n- Ranking function: x\n\nNow, let's find loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n(i) before the loop execution\n(ii) in every iteration of the loop\n(iii) after the loop termination\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant x <= \\at(x, LoopEntry) + 10;\n    loop invariant x % 2 == \\at(x, LoopEntry) % 2;\n*/\n```",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x is assigned an unknown integer value.\n\nNext, let's analyze the loop condition and the given ranking function:\n- The loop condition is (x > 0).\n- The given ranking function is (x).\n\nNow, let's output loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant x >= 0 ==> x <= \\at(x, LoopEntry);\n*/\n```",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head. In this case, the variable `x` is initialized with a value from the `unknown_int()` function, so it can have any integer value.\n\nNext, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `x > 0`. The given ranking function is `(x)`.\n\nNow, let's output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n*/\n```\n\nThe first loop invariant states that `x` is always non-negative during the execution of the loop. This is true because the loop condition ensures that `x > 0` for the loop to continue executing.\n\nThe second loop invariant states that the value of `x` is always less than or equal to its value at the beginning of the loop. This is true because, in the loop body, `x` is updated as `-2*x + 10`, which decreases the value of `x` as long as `x > 0`.",
                    "Step 1: Analyze the starting values and constraints for the variables that are live at the loop head.\n\nAt the start of the loop, x can have any integer value.\n\nStep 2: Analyze the loop body, the loop condition, and the given ranking function.\n\nThe loop condition is x > 0. The loop body updates x by the expression -2 * x + 10. The given ranking function is (x).\n\nStep 3: Output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\nBased on the loop body and the ranking function, we can derive the following loop invariants:\n\n```\n/*@ \n    loop invariant 0 <= x <= INT_MAX;\n    loop invariant x >= \\at(x, LoopEntry) - 5;\n*/\n```\n\nThese loop invariants ensure that x is always within the bounds of integer values, and that x decreases by at most 5 in each iteration of the loop. This supports the ranking function (x) and proves the loop's termination."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant x <= \\at(x, LoopEntry) + 10;\n    loop invariant x % 2 == \\at(x, LoopEntry) % 2;\n*/",
                    "/*@ \n    loop invariant \\at(x, LoopEntry) >= 0;\n    loop invariant x >= 0 ==> x <= \\at(x, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n*/",
                    "/*@ \n    loop invariant 0 <= x <= INT_MAX;\n    loop invariant x >= \\at(x, LoopEntry) - 5;\n*/"
                ],
                "inductive_invariants": "",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x;\n    x = unknown_int();\n    /*@\n\nloop variant x;\n*/\nwhile (x > 0) {\n        x = -2*x + 10;\n    }\n    return 0;\n}",
                "checker_message": "\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x;\n    x = unknown_int();\n    while (x > 0) {\n        x = -2*x + 10;\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(2 * x)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note the starting value and constraints for the variables that are live at the loop head. The variable `x` is live at the loop head and is initially assigned an unknown integer value.\n\nNow, let's analyze the loop condition and the given ranking function. The loop condition is `x > 0`, and the ranking function is `(2 * x)`.\n\nWe need to find loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\nHere are the loop invariants:\n\n```\n/*@ \n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant 0 <= (2 * x) <= (2 * \\at(x, LoopEntry));\n*/\n```\n\nThese invariants imply that the ranking function (2 * x) decreases with every iteration:\n\n- The first invariant states that the value of `x` in the current iteration is always less than or equal to its value at the loop entry. This is true because `x` is updated to `-2*x + 10` inside the loop, and since `x > 0`, the new value of `x` will always be less than its previous value.\n- The second invariant states that the ranking function (2 * x) is always non-negative and less than or equal to its value at the loop entry. This is true because the value of `x` is always decreasing, as stated in the first invariant, and the loop condition ensures that `x > 0`. Therefore, (2 * x) will always be non-negative and decrease with every iteration.\n\nThese loop invariants support the validity of the ranking function (2 * x) and prove the termination of the loop.",
                    "First, let's analyze the given program:\n\n- The variable `x` is assigned an unknown integer value at the beginning.\n- The loop condition is `x > 0`, so the loop executes as long as `x` is positive.\n- Inside the loop, `x` is updated to `-2 * x + 10`.\n\nNow let's derive the loop invariants for the ranking function `(2 * x)`:\n\n1. Before the loop execution, `x` has an unknown integer value.\n2. In every iteration of the loop, `x > 0` holds (loop condition).\n3. In every iteration of the loop, `x` is updated to `-2 * x + 10`.\n4. After the loop termination, `x <= 0` holds (negation of the loop condition).\n\nWe want to ensure that the ranking function `(2 * x)` is non-negative and decreases with every iteration of the loop. To do that, we can use the following loop invariants:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant 2 * x <= \\at(2 * x, LoopEntry) - 10;\n*/\n```\n\nExplanation:\n\n- `x >= 0`: This invariant ensures that `x` is always non-negative inside the loop, which in turn ensures that the ranking function `(2 * x)` is also non-negative.\n- `2 * x <= \\at(2 * x, LoopEntry) - 10`: This invariant ensures that the ranking function `(2 * x)` decreases by at least 10 in every iteration of the loop. Since `x` is updated to `-2 * x + 10` inside the loop, we have `(2 * x) <= (2 * (-2 * x + 10)) - 10`.",
                    "First, let's make a note of the starting values or constraints for the variables that are live at the loop head:\n\n- x: x is initialized with an unknown integer value.\n\nNext, analyze the loop body and make a note of the loop condition and the given ranking function:\n\n- Loop condition: x > 0\n- Ranking function: 2 * x\n\nNow, let's output the loop invariants that support the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> 2 * x <= 2 * \\at(x, LoopEntry);\n*/\n```\n\nExplanation:\n\n1. The first loop invariant states that x is always non-negative when entering the loop. This is true because the loop condition is x > 0, so x must be non-negative for the loop to execute.\n\n2. The second loop invariant states that if x was non-negative at the beginning of the loop, then the value of the ranking function (2 * x) is always less than or equal to its initial value (2 * \\at(x, LoopEntry)). This is true because in each iteration of the loop, x is updated to -2 * x + 10, which results in a smaller value for x, and thus a smaller value for the ranking function. Since the ranking function decreases with each iteration, this invariant holds, and the loop terminates.",
                    "First, let's analyze the loop and the given ranking function:\n\n- Loop condition: x > 0\n- Loop body: x = -2 * x + 10\n- Ranking function: 2 * x\n\nNow, we can output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> (2 * \\at(x, LoopEntry) >= 2 * x);\n*/\n```",
                    "First, we know that the initial value of x is unknown, so it can be any integer. The loop condition is x > 0, and the ranking function is (2 * x). Inside the loop, x is updated with the expression -2*x + 10.\n\nNow, let's find the loop invariants to support the ranking function (2 * x):\n\n```\n/*@ \n    loop invariant 0 <= \\at(2 * x, LoopEntry);\n    loop invariant x <= \\at(x, LoopEntry);\n*/\n```\n\nThese loop invariants hold:\n1. Before the loop execution: x can be any integer, so (2 * x) can also be any non-negative integer.\n2. In every iteration of the loop: x is updated with -2*x + 10, which means x is decreasing in every iteration, and hence (2 * x) is also decreasing.\n3. After the loop termination: The loop terminates when x <= 0, so (2 * x) will be non-positive, which satisfies the loop invariant conditions."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant 0 <= (2 * x) <= (2 * \\at(x, LoopEntry));\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant 2 * x <= \\at(2 * x, LoopEntry) - 10;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> 2 * x <= 2 * \\at(x, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant \\at(x, LoopEntry) >= 0 ==> (2 * \\at(x, LoopEntry) >= 2 * x);\n*/",
                    "/*@ \n    loop invariant 0 <= \\at(2 * x, LoopEntry);\n    loop invariant x <= \\at(x, LoopEntry);\n*/"
                ],
                "inductive_invariants": "",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x;\n    x = unknown_int();\n    /*@\n\nloop variant 2 * x;\n*/\nwhile (x > 0) {\n        x = -2*x + 10;\n    }\n    return 0;\n}",
                "checker_message": "\n\nLoop variant is Invalid.\n",
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c"
        ],
        "skipped": [],
        "total": 60,
        "success_count": 26,
        "failure_count": 34,
        "success_rate": 0.43333333333333335
    }
}