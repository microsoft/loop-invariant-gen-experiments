{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int res;\n    int min;\n    x = unknown_int();\n    y = unknown_int();\n    res = 0;\n    \n    if (x < y) { min = x; }\n    else { min = y; }\n    \n    while (min == y) {\n        y = y+1;\n        res = res+1;\n        if (x < y) { min = x; }\n        else { min = y; }\n    }\n    \n    return 0;\n}",
        "success": true,
        "variants": [
            [
                "x - y"
            ],
            [
                "y - min"
            ],
            [
                "(x - y)"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int res;\n    int min;\n    x = unknown_int();\n    y = unknown_int();\n    res = 0;\n    \n    if (x < y) { min = x; }\n    else { min = y; }\n    \n    while (min == y) {\n        y = y+1;\n        res = res+1;\n        if (x < y) { min = x; }\n        else { min = y; }\n    }\n    \n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- `x` is an unknown integer value.\n- `y` is an unknown integer value.\n- `min` is either `x` or `y`.\n\nThe loop body is as follows:\n```\nwhile (min == y) {\n    y = y+1;\n    res = res+1;\n    if (x < y) { min = x; }\n    else { min = y; }\n}\n```\n\nNow, let's find a ranking function involving the variables in the loop body. We can use the difference between `x` and `y` as our ranking function. Since `x` is constant inside the loop and `y` increases in every iteration, the difference between them will decrease with every iteration. \n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x - y;\n*/\n```\n\nThis is a valid ranking function because the value of `x - y` decreases with every iteration of the loop (since `y` is incremented), and the loop continues executing as long as `min == y`. Since the loop condition requires that `min == y`, the value of `x - y` must be positive for the loop to continue executing.",
            "First, let's note the starting values or constraints for the variables that are live at the loop head.\n\n1. `x` and `y` are assigned unknown integer values before entering the loop.\n2. `min` is assigned either `x` or `y`, depending on their comparison.\n3. The loop continues to execute as long as `min` is equal to `y`.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body.\n\n1. In each iteration, `y` is incremented by 1.\n2. `res` is incremented by 1.\n3. `min` is updated to the minimum of `x` and the new value of `y`.\n\nA suitable ranking function for this loop is the difference between `x` and `y`. Let's explain why this is a valid ranking function:\n\n1. The ranking function `x - y` is always positive while the loop is executing because `min` is equal to `y`. If `x - y` were non-positive, then `min` would be equal to `x`, which contradicts the loop condition.\n2. With every iteration, the value of `y` increases by 1, so the value of `x - y` must decrease. Therefore, the ranking function is decreasing with every iteration.\n\nWe can write the ranking function as follows:\n\n```c\n/*@\n    loop variant x - y;\n*/\n```",
            "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- `x`: unknown integer\n- `y`: unknown integer\n- `min`: minimum of `x` and `y`\n\nNow, let's analyze the loop body:\n1. `y` is incremented by 1.\n2. `res` is incremented by 1.\n3. `min` is updated to be the minimum of `x` and `y`.\n\nSince the loop continues to execute as long as `min == y`, we can find the ranking function involving `y` and `min`.\n\nThe ranking function for the loop is:\n```\n/*@\n    loop variant y - min;\n*/\n```\n\nThis is a valid ranking function because:\n1. It is decreasing: Since `y` is incremented by 1 in every iteration, and `min` is either `x` or `y`, the value of `y - min` decreases with every iteration of the loop.\n2. It is positive: As long as the loop executes, `min == y`. Therefore, `y - min` is 0, which is non-negative.",
            "First, let's identify the live variables at the loop head and their initial values or constraints:\n- `x`: an unknown integer\n- `y`: an unknown integer\n- `res`: initially 0\n- `min`: initially the minimum of `x` and `y`\n\nNow, let's analyze the loop body:\n1. `y` is incremented by 1.\n2. `res` is incremented by 1.\n3. If `x` is less than `y`, `min` is set to `x`. Otherwise, `min` is set to `y`.\n\nThe loop continues executing as long as `min` is equal to `y`.\n\nWith this information, we can define the ranking function for the loop:\n\n```\n/*@\n    loop variant x - y;\n*/\n```\n\nThis ranking function is valid because:\n- The value of `x - y` is positive when the loop is executing (since `min == y` and `min` is the minimum of `x` and `y`, it means that `x > y`).\n- The value of `x - y` decreases with every iteration of the loop, as `y` is incremented by 1 in each iteration, and `x` remains unchanged.",
            "First, let's identify the variables that are live at the loop head and their constraints.\n\n1. `min` is live at the loop head, and its value is either `x` or `y` depending on the condition `x < y`. \n2. `y` is also live at the loop head, and its initial value is `unknown_int()`. We do not have any information about its value.\n3. `x` is live at the loop head, and its initial value is `unknown_int()`. We do not have any information about its value.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body.\n\n1. `y = y+1`: With each iteration, the value of `y` increases by 1.\n2. `res = res+1`: With each iteration, the value of `res` increases by 1.\n3. The loop condition is `min == y`. The loop continues to execute as long as `min` is equal to `y`.\n\nBased on this analysis, we can find a ranking function for this loop as follows:\n\n```\n/*@\n    loop variant (x - y);\n*/\n```\n\nThis is a valid ranking function because:\n1. It involves the variables in the loop body, specifically `x` and `y`.\n2. It decreases with every iteration of the loop since `y` increases by 1 in each iteration, making `(x - y)` smaller.\n3. The value of the ranking function is positive while the loop is executing, as the loop condition `min == y` implies that `y <= x`, which means `(x - y)` is non-negative."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int res;\n    int min;\n    x = unknown_int();\n    y = unknown_int();\n    res = 0;\n    \n    if (x < y) { min = x; }\n    else { min = y; }\n    \n    while (min == y) {\n        y = y+1;\n        res = res+1;\n        if (x < y) { min = x; }\n        else { min = y; }\n    }\n    \n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x - y)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's analyze the loop and the given ranking function (x - y).\n\nAt the beginning of the loop, we have the following information:\n1. x and y are unknown integers.\n2. min is the minimum of x and y.\n\nInside the loop, the following operations occur:\n1. y is incremented by 1.\n2. res is incremented by 1.\n3. min is updated to be the minimum of x and y.\n\nNow, let's find the loop invariants that support the given ranking function (x - y).\n\nBefore the loop execution:\n1. min = min(x, y)\n2. res = 0\n\nIn every iteration of the loop:\n1. min <= y\n2. min <= x\n3. res >= 0\n4. min = y ==> (x - y) > 0\n5. x >= \\at(x, LoopEntry)\n6. y <= \\at(y, LoopEntry) + res\n\nAfter the loop termination:\n1. min != y\n2. min = x\n\nNow, let's output the loop invariants.\n\n```\n/*@ \n    loop invariant min <= y;\n    loop invariant min <= x;\n    loop invariant res >= 0;\n    loop invariant min = y ==> (x - y) > 0;\n    loop invariant x >= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry) + res;\n*/\n```",
                    "First, let's analyze the loop condition and the given ranking function:\n\nLoop condition: min == y\nRanking function: (x - y)\n\nNow, let's identify the loop invariants:\n\n1. Before the loop execution and in every iteration of the loop, min is the minimum of x and y.\n\n2. In every iteration of the loop, y is incremented by 1, and res is incremented by 1.\n\n3. After the loop termination, min must be equal to x.\n\nConsidering these invariants, we can write the loop invariants as follows:\n\n```\n/*@ \n    loop invariant 0 <= res;\n    loop invariant \\at(min, LoopEntry) == (\\at(x, LoopEntry) < \\at(y, LoopEntry) ? \\at(x, LoopEntry) : \\at(y, LoopEntry));\n    loop invariant min <= x;\n    loop invariant min <= y;\n    loop invariant (min == x) ==> (y < x);\n    loop invariant (min == y) ==> (x >= y);\n*/\n```",
                    "First, let's identify the variables that are live at the loop head: `x`, `y`, `min`, and `res`. The loop condition is `min == y`. The given ranking function is `(x - y)`.\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x == \\at(x, LoopEntry);\n    loop invariant min <= x;\n    loop invariant min <= y;\n    loop invariant res >= 0;\n    loop invariant res == (y - \\at(y, LoopEntry));\n    loop invariant (min == y) ==> (x - y >= 0);\n*/\n```",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x and y are assigned unknown_int() values, so they can be any integer.\n- min is assigned either x or y based on their comparison.\n- res is initialized to 0.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: min == y\n- Given ranking function: (x - y)\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant y <= min;\n    loop invariant min <= x;\n    loop invariant res == (\\at(y, LoopEntry) - \\at(y, Pre));\n*/\n```",
                    "First, let's analyze the given program and make note of the starting values or constraints for the variables that are live at the loop head:\n- x and y are both assigned unknown_int() which means they can be any integer value.\n- res is initialized to 0.\n- min is assigned either x or y, depending on the result of the comparison (x < y).\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: min == y\n- Given ranking function: (x - y)\n\nNow, we can output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant \\at(y, LoopEntry) <= y;\n    loop invariant res == y - \\at(y, LoopEntry);\n    loop invariant x >= y ==> min == y;\n    loop invariant x < y ==> min == x;\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant min <= y;\n    loop invariant min <= x;\n    loop invariant res >= 0;\n    loop invariant min = y ==> (x - y) > 0;\n    loop invariant x >= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry) + res;\n*/",
                    "/*@ \n    loop invariant 0 <= res;\n    loop invariant \\at(min, LoopEntry) == (\\at(x, LoopEntry) < \\at(y, LoopEntry) ? \\at(x, LoopEntry) : \\at(y, LoopEntry));\n    loop invariant min <= x;\n    loop invariant min <= y;\n    loop invariant (min == x) ==> (y < x);\n    loop invariant (min == y) ==> (x >= y);\n*/",
                    "/*@ \n    loop invariant x == \\at(x, LoopEntry);\n    loop invariant min <= x;\n    loop invariant min <= y;\n    loop invariant res >= 0;\n    loop invariant res == (y - \\at(y, LoopEntry));\n    loop invariant (min == y) ==> (x - y >= 0);\n*/",
                    "/*@ \n    loop invariant y <= min;\n    loop invariant min <= x;\n    loop invariant res == (\\at(y, LoopEntry) - \\at(y, Pre));\n*/",
                    "/*@ \n    loop invariant \\at(y, LoopEntry) <= y;\n    loop invariant res == y - \\at(y, LoopEntry);\n    loop invariant x >= y ==> min == y;\n    loop invariant x < y ==> min == x;\n*/"
                ],
                "inductive_invariants": "loop invariant i1: min <= y;\nloop invariant i2: min <= x;\nloop invariant i3: res >= 0;\nloop invariant i5: x >= \\at(x, LoopEntry);\nloop invariant i6: y <= \\at(y, LoopEntry) + res;\nloop invariant i7: 0 <= res;\nloop invariant i8: \\at(min, LoopEntry) == (\\at(x, LoopEntry) < \\at(y, LoopEntry) ? \\at(x, LoopEntry) : \\at(y, LoopEntry));\nloop invariant i12: (min == y) ==> (x >= y);\nloop invariant i13: x == \\at(x, LoopEntry);\nloop invariant i17: res == (y - \\at(y, LoopEntry));\nloop invariant i18: (min == y) ==> (x - y >= 0);\nloop invariant i22: \\at(y, LoopEntry) <= y;\nloop invariant i23: res == y - \\at(y, LoopEntry);\nloop invariant i24: x >= y ==> min == y;\nloop invariant i25: x < y ==> min == x;",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int x;\n    int y;\n    int res;\n    int min;\n    x = unknown_int();\n    y = unknown_int();\n    res = 0;\n    \n    if (x < y) { min = x; }\n    else { min = y; }\n    \n    /*@\nloop invariant i1: min <= y;\nloop invariant i2: min <= x;\nloop invariant i3: res >= 0;\nloop invariant i5: x >= \\at(x, LoopEntry);\nloop invariant i6: y <= \\at(y, LoopEntry) + res;\nloop invariant i7: 0 <= res;\nloop invariant i8: \\at(min, LoopEntry) == (\\at(x, LoopEntry) < \\at(y, LoopEntry) ? \\at(x, LoopEntry) : \\at(y, LoopEntry));\nloop invariant i12: (min == y) ==> (x >= y);\nloop invariant i13: x == \\at(x, LoopEntry);\nloop invariant i17: res == (y - \\at(y, LoopEntry));\nloop invariant i18: (min == y) ==> (x - y >= 0);\nloop invariant i22: \\at(y, LoopEntry) <= y;\nloop invariant i23: res == y - \\at(y, LoopEntry);\nloop invariant i24: x >= y ==> min == y;\nloop invariant i25: x < y ==> min == x;\nloop variant x - y;\n*/\nwhile (min == y) {\n        y = y+1;\n        res = res+1;\n        if (x < y) { min = x; }\n        else { min = y; }\n    }\n    \n    return 0;\n}",
                "checker_message": "loop invariant min <= y is inductive.\nloop invariant min <= x is inductive.\nloop invariant res >= 0 is inductive.\nloop invariant x >= \\at(x, LoopEntry) is inductive.\nloop invariant y <= \\at(y, LoopEntry) + res is inductive.\nloop invariant 0 <= res is inductive.\nloop invariant \\at(min, LoopEntry) == (\\at(x, LoopEntry) < \\at(y, LoopEntry) ? \\at(x, LoopEntry) : \\at(y, LoopEntry)) is inductive.\nloop invariant (min == y) ==> (x >= y) is inductive.\nloop invariant x == \\at(x, LoopEntry) is inductive.\nloop invariant res == (y - \\at(y, LoopEntry)) is inductive.\nloop invariant (min == y) ==> (x - y >= 0) is inductive.\nloop invariant \\at(y, LoopEntry) <= y is inductive.\nloop invariant res == y - \\at(y, LoopEntry) is inductive.\nloop invariant x >= y ==> min == y is inductive.\nloop invariant x < y ==> min == x is inductive.\n\nLoop variant is Valid.\n",
                "success": true
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c"
        ],
        "skipped": [],
        "total": 149,
        "success_count": 77,
        "failure_count": 72,
        "success_rate": 0.5167785234899329
    }
}