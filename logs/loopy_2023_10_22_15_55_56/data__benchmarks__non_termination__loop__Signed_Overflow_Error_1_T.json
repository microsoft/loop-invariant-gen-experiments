{
    "logs": {
        "file": "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n    long i;\n    for( i = 1 ; i <= 0xFFFFFFFF ; i <<= 1 )\n    {\n        if( i == ( (long)1 << 31 ))\n            break;\n    }\n    return 0;\n}",
        "success": true,
        "variants": [
            [
                "0xFFFFFFFF - i"
            ],
            [
                "0xFFFFFFFF - (i / 2)"
            ],
            [
                "0x80000000 - i"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n    long i;\n    for( i = 1 ; i <= 0xFFFFFFFF ; i <<= 1 )\n    {\n        if( i == ( (long)1 << 31 ))\n            break;\n    }\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "1. Make note of the starting values or constraints for the variables that are live at the loop head.\n\nIn this case, the only variable live at the loop head is `i`, and it has an initial value of 1.\n\n2. Analyze the loop body and find a ranking function involving the variables in the loop body.\n\nThe loop body only contains a conditional statement that checks whether `i` is equal to `(long)1 << 31`. The loop condition is `i <= 0xFFFFFFFF`, and in each iteration, `i` is multiplied by 2 (`i <<= 1`). We can see that `i` is always positive and increasing, and it eventually reaches the upper bound `0xFFFFFFFF` or the break condition `(long)1 << 31`.\n\n3. Output the ranking function in one code block, in ACSL syntax.\n\nThe ranking function should involve the upper bound `0xFFFFFFFF` and the old value of `i`. Since `i` is always positive and increasing, the difference between the upper bound and `i` decreases with every iteration. Thus, the ranking function can be given as `0xFFFFFFFF - i`.\n\nHere is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant 0xFFFFFFFF - i;\n*/\n```",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head. In this case, the variable `i` is initialized to 1, and the loop condition requires `i <= 0xFFFFFFFF`.\n\nNow let's analyze the loop body. The loop body increments the value of `i` by left-shifting it by 1 in every iteration (`i <<= 1`). This means the value of `i` doubles in every iteration until `i == ( (long)1 << 31 )`, at which point the loop terminates.\n\nSo, we can create a ranking function using the upper bound `0xFFFFFFFF` and the loop variable `i`. The difference between the upper bound and the current value of `i` will decrease with every iteration, and will always be positive while the loop is executing.\n\nThe ranking function is:\n\n```\n/*@\n    loop variant 0xFFFFFFFF - i;\n*/\n```\n\nThis ranking function is valid because it decreases with every iteration of the loop (as `i` increases) and is positive as long as the loop is executing (`i <= 0xFFFFFFFF`).",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- i starts at 1.\n- i <= 0xFFFFFFFF.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body:\n- The loop body doubles the value of i in each iteration (i <<= 1).\n- The loop terminates when i reaches (1 << 31) or i > 0xFFFFFFFF.\n- Therefore, the ranking function should involve the upper bound (0xFFFFFFFF) and the old value of i in each iteration.\n\nWe can use the following ranking function for this loop:\n\n```\n/*@\n    loop variant 0xFFFFFFFF - i;\n*/\n```\n\nThis ranking function is valid because it decreases with every iteration of the loop (i increases, so 0xFFFFFFFF - i decreases), and it evaluates to a positive value while the loop is executing (since i is always less than or equal to 0xFFFFFFFF).",
            "1. The starting value of the variable `i` is 1.\n2. The loop condition is `i <= 0xFFFFFFFF`.\n3. In the loop body, the value of `i` is left-shifted by 1 (`i <<= 1`), meaning it is doubled each time.\n4. The loop terminates when `i` reaches `(long)1 << 31`.\n\nNow, let's find the ranking function for the loop:\n\n1. The upper bound for the variable `i` is `0xFFFFFFFF`.\n2. The old value of `i` in each iteration is `i / 2` (since `i` is doubled in each iteration).\n3. The ranking function should involve the upper bound and the old value of `i`.\n\nThe ranking function for the loop is:\n\n```\n/*@\n    loop variant 0xFFFFFFFF - (i / 2);\n*/\n```\n\nThis ranking function is valid because:\n\n1. It decreases with every iteration of the loop since `i` is doubled each time.\n2. It is positive while the loop is executing since `i` is always less than or equal to `0xFFFFFFFF`.\n3. The loop terminates when `i` reaches `(long)1 << 31`, and the ranking function reaches 0 at that point.",
            "1. The starting value for the loop variable `i` is 1.\n2. The loop condition requires `i` to be less than or equal to `0xFFFFFFFF`.\n3. In the loop body, `i` is left-shifted by 1 in each iteration.\n\nNow, let's find the ranking function for the loop:\n\nSince the loop condition requires `i` to be less than or equal to `0xFFFFFFFF`, the maximum value that `i` can take is `0x80000000`. The loop variable `i` is always increasing (by left-shifting) in each iteration, so we can use the difference between the upper bound (`0x80000000`) and the current value of `i` as the ranking function.\n\nHere is the ranking function:\n\n```\n/*@\n    loop variant 0x80000000 - i;\n*/\n```"
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n    long i;\n    for( i = 1 ; i <= 0xFFFFFFFF ; i <<= 1 )\n    {\n        if( i == ( (long)1 << 31 ))\n            break;\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(0xFFFFFFFF - i)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's make note of the starting values and constraints for the variables that are live at the loop head:\n- i starts with the value 1 and is of type long.\n\nNext, analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: i <= 0xFFFFFFFF\n- Ranking function: (0xFFFFFFFF - i)\n\nNow, let's output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination:\n\n```\n/*@ \n    loop invariant 1 <= i;\n    loop invariant i <= 0xFFFFFFFF;\n    loop invariant (i & (i - 1)) == 0;\n    loop invariant i == (\\at(i, LoopEntry)) << (\\at(i, LoopEntry) <= (1L << 31) ==> 1);\n*/\n```\n\nExplanation:\n1. The value of i is always greater than or equal to 1.\n2. The value of i is always less than or equal to 0xFFFFFFFF.\n3. i is always a power of 2 (i & (i - 1) is a standard bitwise trick to check if a number is a power of 2).\n4. The value of i is equal to the value of i at the loop entry, left-shifted by 1 if the value of i at the loop entry is less than or equal to (1L << 31).",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head. In this case, the variable `i` is live, and its initial value is 1.\n\nNow, let's analyze the loop body, the loop condition, and the given ranking function:\n\nLoop Condition: `i <= 0xFFFFFFFF`\nLoop Body: `i <<= 1` and the conditional break if `i == ( (long)1 << 31 )`\nRanking Function: `(0xFFFFFFFF - i)`\n\nWe are looking for loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nHere are the loop invariants:\n\n```\n/*@ \n    loop invariant i >= 1;\n    loop invariant i <= 0xFFFFFFFF;\n    loop invariant (i & (i - 1)) == 0;\n    loop invariant i == \\at(i, LoopEntry) << (\\at(i, LoopEntry) <= 0x7FFFFFFF ? 1 : 0);\n*/\n```\n\nExplanation of the invariants:\n\n1. `i >= 1`: This invariant states that the value of `i` is always greater than or equal to 1, which is true before the loop, during every iteration, and after the loop termination.\n\n2. `i <= 0xFFFFFFFF`: This invariant states that the value of `i` is always less than or equal to the maximum value of 0xFFFFFFFF, which is also true before the loop, during every iteration, and after the loop termination.\n\n3. `(i & (i - 1)) == 0`: This invariant ensures that `i` is always a power of 2 (i.e., it has only one bit set). This is true before the loop, during every iteration, and after the loop termination.\n\n4. `i == \\at(i, LoopEntry) << (\\at(i, LoopEntry) <= 0x7FFFFFFF ? 1 : 0)`: This invariant expresses the effect of the loop body on the value of `i`. It states that the value of `i` in the current iteration is the same as the value of `i` at the beginning of the loop shifted left by 1 if the value of `i` at the beginning of the loop is less than or equal to 0x7FFFFFFF, and not shifted otherwise. This is true for every iteration of the loop.\n\nThese loop invariants imply that the ranking function `(0xFFFFFFFF - i)` decreases with every iteration, proving the termination of the loop.",
                    "First, let's analyze the loop head and body:\n\n- The loop starts with i = 1.\n- The loop condition is i <= 0xFFFFFFFF.\n- The loop body increments i by left-shifting it by 1 (i.e., i <<= 1).\n- There is a conditional break statement when i reaches (1 << 31).\n\nNow, let's find the loop invariants:\n\n1. The variable i is always positive since it starts at 1 and is multiplied by 2 in each iteration.\n2. The variable i is always less than or equal to 0xFFFFFFFF due to the loop condition.\n3. The variable i always doubles its value in each iteration (i = i * 2).\n4. The variable i will never exceed (1 << 31) due to the conditional break statement.\n\nNow, let's write the loop invariants as ACSL annotations:\n\n```\n/*@ \n    loop invariant 1 <= i;\n    loop invariant i <= 0xFFFFFFFF;\n    loop invariant i == \\at(i, LoopEntry) * (1 << (1 + \\at(i, LoopEntry)));\n    loop invariant i <= (1 << 31);\n*/\n```",
                    "First, let's identify the loop condition, the variables that are live at the loop head, and the given ranking function:\n\n- Loop condition: `i <= 0xFFFFFFFF`\n- Live variables at the loop head: `i`\n- Ranking function: `0xFFFFFFFF - i`\n\nNow, we can output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant 1 <= i <= 0xFFFFFFFF;\n    loop invariant i <= (long)1 << 31;\n    loop invariant i == \\at(i, LoopEntry) << (\\at(i, LoopEntry) <= (long)1 << 31 ? 1 : 0);\n*/\n```",
                    "First, let's analyze the given program:\n\n1. The loop starts with `i = 1`.\n2. The loop condition is `i <= 0xFFFFFFFF`.\n3. In each iteration, `i` is left shifted by 1 (i.e., multiplied by 2).\n4. If `i` becomes equal to `(long)1 << 31`, the loop terminates early.\n\nNow, let's output the loop invariants to support the loop variant `(0xFFFFFFFF - i)`:\n\n```\n/*@ \n    loop invariant 1 <= i <= 0xFFFFFFFF;\n    loop invariant i == (\\at(i, LoopEntry)) * (1 << (int)((log2(i / \\at(i, LoopEntry))));\n    loop invariant (i != (\\at(i, LoopEntry)) * (1 << 31)) ==> (0xFFFFFFFF - i) < (0xFFFFFFFF - \\at(i, LoopEntry));\n*/\n```\n\nHere are the explanations for each invariant:\n\n1. `1 <= i <= 0xFFFFFFFF`: This invariant states that `i` is always between 1 and 0xFFFFFFFF, inclusive. This is true because `i` starts at 1 and can never exceed 0xFFFFFFFF due to the loop condition.\n\n2. `i == (\\at(i, LoopEntry)) * (1 << (int)((log2(i / \\at(i, LoopEntry))))`: This invariant states that at each iteration, `i` is equal to its initial value at the beginning of the loop multiplied by a power of 2. This is true because `i` is left-shifted by 1 in each iteration, which is equivalent to multiplying it by 2.\n\n3. `(i != (\\at(i, LoopEntry)) * (1 << 31)) ==> (0xFFFFFFFF - i) < (0xFFFFFFFF - \\at(i, LoopEntry))`: This invariant states that if `i` is not equal to its initial value at the beginning of the loop multiplied by `1 << 31`, then the loop variant `(0xFFFFFFFF - i)` is strictly decreasing. This is true because when `i` is not equal to `(long)1 << 31`, it is left-shifted in each iteration, moving it closer to 0xFFFFFFFF and making the loop variant strictly decreasing."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant 1 <= i;\n    loop invariant i <= 0xFFFFFFFF;\n    loop invariant (i & (i - 1)) == 0;\n    loop invariant i == (\\at(i, LoopEntry)) << (\\at(i, LoopEntry) <= (1L << 31) ==> 1);\n*/",
                    "/*@ \n    loop invariant i >= 1;\n    loop invariant i <= 0xFFFFFFFF;\n    loop invariant (i & (i - 1)) == 0;\n    loop invariant i == \\at(i, LoopEntry) << (\\at(i, LoopEntry) <= 0x7FFFFFFF ? 1 : 0);\n*/",
                    "/*@ \n    loop invariant 1 <= i;\n    loop invariant i <= 0xFFFFFFFF;\n    loop invariant i == \\at(i, LoopEntry) * (1 << (1 + \\at(i, LoopEntry)));\n    loop invariant i <= (1 << 31);\n*/",
                    "/*@ \n    loop invariant 1 <= i <= 0xFFFFFFFF;\n    loop invariant i <= (long)1 << 31;\n    loop invariant i == \\at(i, LoopEntry) << (\\at(i, LoopEntry) <= (long)1 << 31 ? 1 : 0);\n*/",
                    "/*@ \n    loop invariant 1 <= i <= 0xFFFFFFFF;\n    loop invariant i == (\\at(i, LoopEntry)) * (1 << (int)((log2(i / \\at(i, LoopEntry))));\n    loop invariant (i != (\\at(i, LoopEntry)) * (1 << 31)) ==> (0xFFFFFFFF - i) < (0xFFFFFFFF - \\at(i, LoopEntry));\n*/"
                ],
                "inductive_invariants": "loop invariant i1: 1 <= i;\nloop invariant i5: i >= 1;",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\n\nint main()\n{\n    long i;\n    /*@\nloop invariant i1: 1 <= i;\nloop invariant i5: i >= 1;\nloop variant 0xFFFFFFFF - i;\n*/\nfor( i = 1 ; i <= 0xFFFFFFFF ; i <<= 1 )\n    {\n        if( i == ( (long)1 << 31 ))\n            break;\n    }\n    return 0;\n}",
                "checker_message": "loop invariant 1 <= i is inductive.\nloop invariant i >= 1 is inductive.\n\nLoop variant is Valid.\n",
                "success": true
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c"
        ],
        "skipped": [],
        "total": 97,
        "success_count": 49,
        "failure_count": 48,
        "success_rate": 0.5051546391752577
    }
}