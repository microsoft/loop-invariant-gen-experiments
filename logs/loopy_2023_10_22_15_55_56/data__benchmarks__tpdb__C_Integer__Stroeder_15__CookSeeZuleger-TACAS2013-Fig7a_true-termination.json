{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, d;\n\tx = unknown_int();\n\ty = unknown_int();\n\td = unknown_int();\n    while (x>0 && y>0 && d>0) {\n        if (unknown_int() != 0) {\n            x = x - 1;\n            d = unknown_int();\n        } else {\n            x = unknown_int();\n            y = y - 1;\n            d = d - 1;\n        }\n    }\n    return 0;\n}",
        "success": false,
        "variants": [
            [
                "x",
                "y",
                "d"
            ],
            [
                "x + y + d"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, d;\n\tx = unknown_int();\n\ty = unknown_int();\n\td = unknown_int();\n    while (x>0 && y>0 && d>0) {\n        if (unknown_int() != 0) {\n            x = x - 1;\n            d = unknown_int();\n        } else {\n            x = unknown_int();\n            y = y - 1;\n            d = d - 1;\n        }\n    }\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "First, let's identify the variables live at the loop head and their constraints:\n- x, y, and d are the variables live at the loop head.\n- The loop condition is x > 0, y > 0, and d > 0.\n\nNow, let's analyze the loop body and find a ranking function involving these variables:\n\nIn the loop body, there are two branches:\n1. If unknown_int() != 0:\n    - x is decremented by 1.\n    - d is assigned an unknown value.\n\n2. If unknown_int() == 0:\n    - x is assigned an unknown value.\n    - y is decremented by 1.\n    - d is decremented by 1.\n\nWe can observe that either x or y is decreasing in each iteration, and d is always positive. So, a lexicographic ranking function can be formed using (x, y, d). Here's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n    loop variant d;\n*/\n```",
            "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x is assigned an unknown integer value.\n- y is assigned an unknown integer value.\n- d is assigned an unknown integer value.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body:\n\nThe loop runs while x > 0, y > 0, and d > 0. Inside the loop, there are two branches:\n1. If unknown_int() != 0, then x is decremented by 1, and d is assigned an unknown integer value.\n2. Else, x is assigned an unknown integer value, y is decremented by 1, and d is decremented by 1.\n\nThe ranking function should involve x, y, and d since they are the variables being changed inside the loop. We can use the sum of these variables as a ranking function, as the sum will always be positive while the loop is running, and it will decrease in each iteration:\n\n```\n/*@\n    loop variant x + y + d;\n*/\n```\n\nThis is a valid ranking function because:\n- The sum x + y + d is positive while the loop is executing, as each variable is positive (x > 0, y > 0, d > 0).\n- The sum x + y + d decreases with every iteration:\n  - In the first branch, x is decremented by 1, so the sum decreases.\n  - In the second branch, y is decremented by 1 and d is decremented by 1, so the sum decreases.\n- Since the ranking function decreases in each iteration and is positive while the loop is executing, it helps prove that the loop must terminate.",
            "First, let's make a note of the starting values or constraints for the variables that are live at the loop head. In this case, we have `x`, `y`, and `d`.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. The loop has two branches, one where `x` decreases and `d` gets assigned an unknown value, and the other where `x` gets assigned an unknown value, `y` decreases, and `d` decreases.\n\nSince `x` and `y` are non-negative integers and they decrease in each branch, we can use them as components of a lexicographic ranking function. Additionally, since `d` is also a non-negative integer and it decreases in one of the branches, we can use it as another component of the ranking function.\n\nHere is the ranking function for the loop in the given program:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n    loop variant d;\n*/\n```\n\nThis ranking function is valid because:\n1. The value of `x` and `y` are non-negative integers and decrease with every successive iteration of the loop.\n2. The value of `d` is a non-negative integer and decreases in at least one branch of the loop.\n3. The loop continues executing only when `x > 0`, `y > 0`, and `d > 0`, which ensures that the values of `x`, `y`, and `d` are positive.",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n- x: unknown_int()\n- y: unknown_int()\n- d: unknown_int()\n\nWe don't have any constraints on the initial values of x, y, and d.\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body. There are two branches in the loop body, and the variables change as follows:\n\n1. x = x - 1, d = unknown_int()\n2. x = unknown_int(), y = y - 1, d = d - 1\n\nThe ranking function should involve x, y, and d. To make sure it's decreasing, we can use a lexicographic ranking function with the following sequence of expressions:\n\n1. x\n2. y\n3. d\n\nNow, let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n    loop variant d;\n*/\n```\n\nThis ranking function is valid because x, y, and d are positive while the loop is executing, and for each iteration, at least one of the expressions is decreasing. Specifically:\n\n- In the first branch, x decreases.\n- In the second branch, y and d both decrease.",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n- x, y, and d are initialized with unknown integers.\n- The loop condition is (x > 0 && y > 0 && d > 0).\n\nNow, let's analyze the loop body and find a ranking function involving the variables in the loop body:\n1. If the unknown_int() function returns a non-zero value, x is decremented by 1 and d is assigned an unknown integer.\n2. If the unknown_int() function returns zero, x is assigned an unknown integer, y is decremented by 1, and d is decremented by 1.\n\nSince we don't know the exact values of x, y, and d at any point in the loop, we need to use lexicographic ranking functions to account for the various possibilities.\n\nLet's consider the following lexicographic ranking function: (x, y, d)\n\nIt is a valid ranking function because:\n1. x, y, and d must all be positive for the loop to execute, as specified in the loop condition.\n2. In every iteration, either x decreases or y and d decrease.\n\nNow, let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n    loop variant d;\n*/\n```\n\nThis lexicographic ranking function (x, y, d) ensures that the loop must terminate, as either x decreases, or y and d decrease in each iteration, while all three variables must remain positive for the loop to continue executing."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, d;\n\tx = unknown_int();\n\ty = unknown_int();\n\td = unknown_int();\n    while (x>0 && y>0 && d>0) {\n        if (unknown_int() != 0) {\n            x = x - 1;\n            d = unknown_int();\n        } else {\n            x = unknown_int();\n            y = y - 1;\n            d = d - 1;\n        }\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x, y, d)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, we will make note of the starting values or constraints for the variables that are live at the loop head. In this case, x, y, and d are all initialized by unknown_int(), which can return any integer value.\n\nNext, we will analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is (x > 0 && y > 0 && d > 0), and the ranking function is (x, y, d).\n\nNow, we will output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant \\at(x, LoopEntry) - x + \\at(y, LoopEntry) - y + \\at(d, LoopEntry) - d >= 0;\n*/\n```\n\nThese loop invariants ensure that x, y, and d are always non-negative and that the sum of their decreases throughout the loop is non-negative, implying that the ranking function (x, y, d) decreases with every iteration.",
                    "First, let's identify the loop condition and the given ranking function. The loop condition is `x>0 && y>0 && d>0`, and the given ranking function is a lexicographic ranking function (x, y, d).\n\nNow let's find the loop invariants:\n\n1. Before the loop execution, x, y, and d are set to unknown_int() values. So, we don't have any specific bounds or relations for the initial values of x, y, and d.\n\n2. In every iteration of the loop, we have two branches:\n   - If unknown_int() != 0, x decreases by 1, and d gets a new unknown_int() value.\n   - Else, x gets a new unknown_int() value, y decreases by 1, and d decreases by 1.\n\n3. We can now derive the loop invariants:\n   - x is non-negative: x >= 0\n   - y is non-negative: y >= 0\n   - d is non-negative: d >= 0\n\n4. Since the loop condition is `x>0 && y>0 && d>0`, after the loop termination at least one of x, y, or d must be non-positive.\n\nNow let's output the loop invariants:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n*/\n```",
                    "We start by analyzing the loop and its variables.\n\nInitial constraints:\n- x, y, and d are initialized with unknown_int(), which can return any integer value.\n\nLoop condition:\n- The loop continues while x > 0, y > 0, and d > 0.\n\nLoop body:\n- If unknown_int() is non-zero, x decreases by 1 and d is assigned a new unknown value.\n- Else, x is assigned a new unknown value, y decreases by 1, and d decreases by 1.\n\nNow, we can provide the loop invariants for the given loop variant (x, y, d):\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant x + y + d >= \\at(x, LoopEntry) + \\at(y, LoopEntry) + \\at(d, LoopEntry);\n    loop invariant x + y + d <= \\at(x, LoopEntry) * 2 + \\at(y, LoopEntry) + \\at(d, LoopEntry);\n*/\n```\n\nExplanation:\n1. x, y, and d are non-negative since they decrease only when positive and are assigned unknown non-negative values.\n2. The sum x + y + d is always greater than or equal to the sum of their initial values since they either decrease or are assigned new unknown values.\n3. The sum x + y + d is always less than or equal to the sum of their initial values multiplied by 2, since x can at most double its initial value, and y and d can only decrease.",
                    "First, let's analyze the loop and the given ranking function (x, y, d).\n\n1. The loop condition is `x > 0 && y > 0 && d > 0`.\n2. Inside the loop, there are two branches:\n   a. If `unknown_int() != 0`, then `x` is decremented by 1 and `d` is assigned a new value from `unknown_int()`.\n   b. Else, `x` is assigned a new value from `unknown_int()`, `y` is decremented by 1, and `d` is decremented by 1.\n\nNow, let's output the loop invariants that support the loop variant (x, y, d), such that the loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant (\\at(x, LoopEntry) == x) ==> \\at(d, LoopEntry) >= d;\n*/\n```",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x, y, and d are initialized by unknown_int() and can have any integer value.\n\nNext, let's analyze the loop body, loop condition, and the given ranking function:\n- Loop condition: x > 0 && y > 0 && d > 0\n- Loop body: \n  - If unknown_int() != 0: x = x - 1; d = unknown_int();\n  - Else: x = unknown_int(); y = y - 1; d = d - 1;\n- Ranking function: (x, y, d)\n\nNow, let's output loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant \\at(x, LoopEntry) - x >= 0;\n    loop invariant \\at(y, LoopEntry) - y >= 0;\n    loop invariant \\at(d, LoopEntry) - d >= 0;\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant \\at(x, LoopEntry) - x + \\at(y, LoopEntry) - y + \\at(d, LoopEntry) - d >= 0;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant x + y + d >= \\at(x, LoopEntry) + \\at(y, LoopEntry) + \\at(d, LoopEntry);\n    loop invariant x + y + d <= \\at(x, LoopEntry) * 2 + \\at(y, LoopEntry) + \\at(d, LoopEntry);\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant (\\at(x, LoopEntry) == x) ==> \\at(d, LoopEntry) >= d;\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant \\at(x, LoopEntry) - x >= 0;\n    loop invariant \\at(y, LoopEntry) - y >= 0;\n    loop invariant \\at(d, LoopEntry) - d >= 0;\n*/"
                ],
                "inductive_invariants": "loop invariant i17: \\at(y, LoopEntry) >= y;",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, d;\n\tx = unknown_int();\n\ty = unknown_int();\n\td = unknown_int();\n    //@ ghost variant_expression measure = { x, y, d };\n/*@\nloop invariant i17: \\at(y, LoopEntry) >= y;\nloop invariant measure.a == x && measure.b == y && measure.c == d;\nloop variant measure for lexicographic;\n*/\nwhile (x>0 && y>0 && d>0) {\n        if (unknown_int() != 0) {\n            x = x - 1;\n            d = unknown_int();\n        } else {\n            x = unknown_int();\n            y = y - 1;\n            d = d - 1;\n        }\n    \n//@ ghost measure.a = x;\n//@ ghost measure.b = y;\n//@ ghost measure.c = d;\n}\n    return 0;\n}",
                "checker_message": "loop invariant \\at(y, LoopEntry) >= y is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            },
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, d;\n\tx = unknown_int();\n\ty = unknown_int();\n\td = unknown_int();\n    while (x>0 && y>0 && d>0) {\n        if (unknown_int() != 0) {\n            x = x - 1;\n            d = unknown_int();\n        } else {\n            x = unknown_int();\n            y = y - 1;\n            d = d - 1;\n        }\n    }\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x + y + d)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note the starting values or constraints for the variables that are live at the loop head. In this program, the variables x, y, and d are live at the loop head and can have any integer value since they are assigned by unknown_int().\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is (x > 0 && y > 0 && d > 0). The ranking function is (x + y + d).\n\nLet's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination. Such loop invariants imply that the ranking function decreases with every iteration.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant (x + y + d) <= \\at(x + y + d, LoopEntry);\n*/\n```\n\nThese loop invariants state that x, y, and d are always non-negative and the value of the ranking function (x + y + d) is always less than or equal to its value at the beginning of the loop. These invariants support the loop variant (x + y + d) and prove the termination of the loop.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head:\n- x, y, and d are initialized with unknown_int() which means they can have any integer value.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: x > 0 && y > 0 && d > 0\n- Ranking function: (x + y + d)\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply that the ranking function decreases with every iteration:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant (unknown_int() != 0) ==> \\at(x, LoopEntry) >= 1;\n    loop invariant (unknown_int() == 0) ==> \\at(y, LoopEntry) >= 1;\n    loop invariant (unknown_int() == 0) ==> \\at(d, LoopEntry) >= 1;\n    loop invariant \\at(d, LoopEntry) >= 0;\n*/\n```",
                    "First, let's make note of the starting values or constraints for the variables that are live at the loop head. In this case, x, y, and d are live at the loop head, and they are all non-negative integers, because the loop condition requires that they are all positive integers. The given ranking function is (x + y + d).\n\nNow, let's analyze the loop body and loop condition:\n\nThe loop condition is: x>0 && y>0 && d>0\n\nInside the loop, there are two cases:\n\n1. If unknown_int() != 0:\n    x = x - 1;\n    d = unknown_int();\n2. Else:\n    x = unknown_int();\n    y = y - 1;\n    d = d - 1;\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant x + y + d >= \\at(x + y + d, LoopEntry);\n*/\n```\n\nThese loop invariants ensure that:\n1. x, y, and d are always non-negative integers.\n2. The ranking function (x + y + d) is always greater than or equal to its value at the beginning of the loop.\n\nSince the ranking function (x + y + d) is non-negative and decreases with every iteration of the loop, the loop will eventually terminate.",
                    "First, let's make a note of the starting values or constraints for the variables that are live at the loop head:\n- x, y, and d are all live at the loop head.\n- x, y, and d are initialized with unknown_int() and may take any integer value.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: x > 0 && y > 0 && d > 0\n- Ranking function: (x + y + d)\n\nNow, let's output the loop invariants that support the validity of the ranking function and prove the termination of the loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(d, LoopEntry) >= d;\n*/\n```\n\nThese loop invariants ensure that x, y, and d are always non-negative and that their values decrease with every iteration of the loop, which implies that the ranking function (x + y + d) also decreases with every iteration, thus proving the termination of the loop.",
                    "First, let's note the starting values or constraints for the variables that are live at the loop head. Since `x`, `y`, and `d` are initialized with `unknown_int()`, they can have any integer value.\n\nThe loop condition is `(x > 0 && y > 0 && d > 0)`. The given ranking function is `(x + y + d)`.\n\nNow let's output the loop invariants to support the loop variant `(x + y + d)`:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant x + y + d <= \\at(x + y + d, LoopEntry);\n*/\n```"
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant (x + y + d) <= \\at(x + y + d, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant (unknown_int() != 0) ==> \\at(x, LoopEntry) >= 1;\n    loop invariant (unknown_int() == 0) ==> \\at(y, LoopEntry) >= 1;\n    loop invariant (unknown_int() == 0) ==> \\at(d, LoopEntry) >= 1;\n    loop invariant \\at(d, LoopEntry) >= 0;\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant x + y + d >= \\at(x + y + d, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant d >= 0;\n    loop invariant \\at(x, LoopEntry) >= x;\n    loop invariant \\at(y, LoopEntry) >= y;\n    loop invariant \\at(d, LoopEntry) >= d;\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant 0 <= d;\n    loop invariant x + y + d <= \\at(x + y + d, LoopEntry);\n*/"
                ],
                "inductive_invariants": "loop invariant i20: \\at(y, LoopEntry) >= y;",
                "final_checker_input": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int x, y, d;\n\tx = unknown_int();\n\ty = unknown_int();\n\td = unknown_int();\n    /*@\nloop invariant i20: \\at(y, LoopEntry) >= y;\nloop variant x + y + d;\n*/\nwhile (x>0 && y>0 && d>0) {\n        if (unknown_int() != 0) {\n            x = x - 1;\n            d = unknown_int();\n        } else {\n            x = unknown_int();\n            y = y - 1;\n            d = d - 1;\n        }\n    }\n    return 0;\n}",
                "checker_message": "loop invariant \\at(y, LoopEntry) >= y is inductive.\n\nLoop variant is Invalid.\n",
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Gothenburg_v2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.08.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.03.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.02.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_AG313.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Bangalore_v4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c"
        ],
        "skipped": [],
        "total": 209,
        "success_count": 111,
        "failure_count": 98,
        "success_rate": 0.5311004784688995
    }
}