{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x, y;\n\twhile (x >= 0 && y >= 0) {\n\t\ty = y - 1;\n\t\tif (y < 0) {\n\t\t\tx = x - 1;\n\t\t\ty = unknown_int();\n\t\t}\n\t}\n    return 0;\n}",
        "success": true,
        "variants": [
            [
                "x",
                "Y - y"
            ],
            [
                "x",
                "y"
            ]
        ],
        "variant_llm_output": [
            {
                "role": "system",
                "content": "A ranking function (also called variant) is an expression over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function that helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and find a ranking function involving the variables in the loop body\n- Output the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\n- If the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. \n\nRules:\n- **Do not use constants or functions not defined in the program. Use the ternary operator to describe the absolute value of an expression.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:  \n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x, y;\n\twhile (x >= 0 && y >= 0) {\n\t\ty = y - 1;\n\t\tif (y < 0) {\n\t\t\tx = x - 1;\n\t\t\ty = unknown_int();\n\t\t}\n\t}\n    return 0;\n}\n```\nFind the ranking function for the loop in the given program. \n\nEnsure that the ranking function (or the sequence of expressions) is **decreasing** with every iteration of the loop, and evaluates to a **positive value** while the loop is executing.\n\n**If there is an upper bound to the loop variable, and the loop condition requires the loop variable to not decrease, output an expression involving the upper bound and the old value of the loop variable in every iteration.**\n\nLet's think step by step. "
            },
            "1. Starting values or constraints for the variables that are live at the loop head:\n   - `x` and `y` can be any integer values at the beginning.\n   - The loop executes only when `x >= 0` and `y >= 0`.\n\n2. Analyze the loop body:\n   - In each iteration, `y` is decreased by 1.\n   - If `y` becomes negative, `x` is decreased by 1, and `y` is assigned a new value from the `unknown_int()` function.\n\nNow, let's find a ranking function involving `x` and `y`.\n\nSince we don't know the exact value returned by the `unknown_int()` function, we can use an upper bound for `y`. Let's consider the upper bound for `y` as `Y`. Therefore, the ranking function should involve `x`, `y`, and `Y`.\n\nA possible lexicographic ranking function can be `(x, Y - y)`, because:\n- Both expressions are positive while the loop executes (`x >= 0`, `y >= 0`, and `Y - y >= 0`).\n- The value of `x` either decreases or remains the same. If it remains the same, the value of `Y - y` decreases since `y` is increased by the `unknown_int()` function.\n\nSo, the ranking function is:\n```\n/*@\n    loop variant x;\n    loop variant Y - y;\n*/\n```",
            "1. Variables live at the loop head: `x` and `y`. The loop condition requires both `x` and `y` to be non-negative.\n2. Analyzing the loop body:\n    - `y` is decremented by 1.\n    - If `y` becomes negative, `x` is decremented by 1, and `y` is updated to an unknown value.\n\nSince the loop terminates when either `x` or `y` becomes negative, we can use a lexicographic ranking function involving both variables. We can choose `(x, y)` as the lexicographic ranking function.\n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n*/\n```\n\nThis ranking function is valid because:\n\n1. Both `x` and `y` are non-negative at the start of the loop.\n2. In each iteration of the loop, either `y` decreases (when `y >= 0`) or `x` decreases (when `y < 0`). Therefore, the lexicographic ranking function `(x, y)` is decreasing in each iteration.\n3. The loop terminates when either `x` or `y` becomes negative, which means the ranking function will no longer be positive, ensuring termination.",
            "Step 1: Make note of the starting values or constraints for the variables that are live at the loop head.\n- x and y are both live at the loop head. Their values are unknown, but the loop condition requires both x and y to be non-negative (x >= 0 && y >= 0).\n\nStep 2: Analyze the loop body and find a ranking function involving the variables in the loop body.\n- In the loop body, y is always decreased by 1.\n- If y becomes negative after the decrement, x is decreased by 1, and y is assigned an unknown non-negative value (since the loop condition still holds).\n- So, in each iteration, either y decreases or x decreases, and y gets a new unknown non-negative value.\n\nStep 3: Output the ranking function in one code block, in ACSL syntax.\n\nBased on the analysis, we can use a lexicographic ranking function with two expressions involving x and y. The first expression decreases when y < 0, and the second expression decreases in every iteration.\n\nHere is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n*/\n```",
            "First, let's make note of the starting values or constraints for the variables that are live at the loop head:\n\n- `x` and `y` are the variables live at the loop head.\n- The loop condition is `x >= 0 && y >= 0`.\n\nNow, let's analyze the loop body:\n\n1. `y = y - 1;`: Here, `y` is being decremented by 1 in every iteration.\n2. `if (y < 0) {`: This condition checks if `y` becomes negative.\n3. `x = x - 1;`: If `y` is negative, `x` is decremented by 1.\n4. `y = unknown_int();`: `y` is assigned an unknown integer value.\n\nTo find a ranking function, we can analyze the values of `x` and `y`. Since the loop condition requires `x` and `y` to be non-negative, we can consider the lexicographic tuple `(x, y)` as a ranking function. The lexicographic order ensures that either `x` decreases or, if `x` remains the same, `y` decreases.\n\nHere's the ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant x;\n    loop variant y;\n*/\n```\n\nThis is a valid ranking function because:\n\n- The values of `x` and `y` are non-negative at the beginning of each loop iteration.\n- The value of `x` decreases if `y` becomes negative, ensuring termination.\n- If `x` remains the same, the value of `y` must decrease, ensuring termination.\n\nHence, the lexicographic ranking function `(x, y)` proves that the loop must terminate.",
            "First, let's note the starting values or constraints for the variables that are live at the loop head. In this case, we have `x` and `y` which are both non-negative integers (since the loop condition is `x >= 0 && y >= 0`).\n\nNext, let's analyze the loop body. We can see that `y` is decreased by 1 in each iteration. If `y` becomes negative, `x` is decreased by 1 and `y` is assigned an unknown value. Since `y` must be non-negative for the loop to continue, we can assume that the unknown value assigned to `y` is also non-negative.\n\nNow, let's find a ranking function involving the variables in the loop body. We can use the lexicographic ranking function (x, y) as it satisfies the conditions mentioned above.\n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant x;\n    loop variant y;\n*/\n```\n\nThis ranking function is valid because:\n1. The value of `x` and `y` are both non-negative integers, and they must be positive for the loop to continue executing.\n2. In each iteration, either the value of `x` decreases (when `y` becomes negative) or the value of `y` decreases (when `y` is non-negative). Therefore, this ranking function is decreasing with every iteration of the loop."
        ],
        "variant_log": [
            {
                "invariant_llm_output": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression over program variables that are live at the loop head, whose value is non-negative and decreases with every iteration of the loop.\nA ranking function can be used to prove the termination of a loop. Lexicographic ranking functions are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nGiven a program with a ranking function for the loop in the program, find loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\nInstructions:\n- Make note of the starting values or constraints for the variables that are live at the loop head.\n- Analyze the loop body and make a note of the loop condition and the given ranking function.\n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply that the ranking function decreases with every iteration.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **Assume all uninitialized variables to contain garbage values.**\n- **Assume non-deterministic functions to return any value permitted by its return type.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of a variable \"x\" at the beginning of the loop.**"
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x, y;\n\twhile (x >= 0 && y >= 0) {\n\t\ty = y - 1;\n\t\tif (y < 0) {\n\t\t\tx = x - 1;\n\t\t\ty = unknown_int();\n\t\t}\n\t}\n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nOutput the loop invariants to support the loop variant **(x, Y - y)**, for the loop in the program above. Let's think step by step."
                    },
                    "First, let's analyze the program and make note of the constraints and loop condition:\n\n- The loop condition is `x >= 0 && y >= 0`\n- The given ranking function is `(x, Y - y)` where Y is the value of y at the beginning of the loop.\n- The loop body updates y and x as follows:\n  - `y = y - 1;`\n  - If `y < 0`, then `x = x - 1;` and `y = unknown_int();`\n\nNow, let's find the loop invariants that hold before the loop execution, during the loop iterations, and after the loop termination:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry);\n*/\n```\n\nThese loop invariants hold true because:\n- `x >= 0` and `y >= 0` are true before the loop execution and are preserved during the loop iterations due to the loop condition.\n- `y <= \\at(y, LoopEntry)` holds true because:\n  - Before the loop execution, `y = \\at(y, LoopEntry)`.\n  - During the loop iterations, `y` is either decremented by 1 or assigned an unknown integer value, but it never increases beyond its initial value at the loop entry. Therefore, `y <= \\at(y, LoopEntry)` remains true.",
                    "First, let's identify the starting values or constraints for the variables that are live at the loop head:\n- x and y are both uninitialized, so they can have any integer value.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function:\n- Loop condition: x >= 0 && y >= 0\n- Ranking function: (x, Y - y), where Y is the value of y at the beginning of the loop.\n\nLet's output the loop invariants that support the given ranking function:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant y >= 0 ==> y < \\at(y, LoopEntry);\n    loop invariant y < 0 ==> x < \\at(x, LoopEntry);\n*/\n```\n\nExplanation:\n1. x >= 0: This invariant states that x is always non-negative during the loop execution.\n2. y >= 0: This invariant states that y is always non-negative during the loop execution.\n3. x <= \\at(x, LoopEntry): This invariant states that x never increases during the loop execution.\n4. y <= \\at(y, LoopEntry): This invariant states that y never increases during the loop execution.\n5. y >= 0 ==> y < \\at(y, LoopEntry): This invariant states that when y is non-negative, its value is less than its value at the beginning of the loop.\n6. y < 0 ==> x < \\at(x, LoopEntry): This invariant states that when y is negative, x must be less than its value at the beginning of the loop.\n\nThese loop invariants imply that the ranking function (x, Y - y) decreases with every iteration, which in turn proves the termination of the loop.",
                    "First, let's analyze the given code and make note of starting values, constraints, loop condition, and the ranking function.\n\n- Starting values: x and y are uninitialized, so they can have any integer value.\n- Constraints: x >= 0 and y >= 0 (loop condition)\n- Loop condition: x >= 0 && y >= 0\n- Ranking function: (x, Y - y), where Y is the value of y at the beginning of the loop.\n\nNow, let's find the loop invariants that support the validity of the ranking function and prove the termination of the loop.\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry);\n*/\n```",
                    "Let's analyze the program and create loop invariants for the loop variant (x, Y - y):\n\n- At the start of the loop, x and y have unknown values.\n- The loop condition is \"x >= 0 && y >= 0\".\n- In the loop body, y is decremented by 1.\n- If y becomes negative, x is decremented by 1 and y is assigned an unknown integer value.\n- The loop variant is (x, Y - y), where Y is the value of y at the beginning of the loop.\n\nNow, let's write the loop invariants:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry);\n*/\n```\n\nThese loop invariants ensure that:\n1. x and y are non-negative at the start of each loop iteration.\n2. y always decreases within a loop iteration, unless it becomes negative and is reset to an unknown non-negative value.\n3. The loop variant (x, Y - y) decreases with each iteration, implying the loop's termination.",
                    "First, we need to make note of the starting values or constraints for the variables that are live at the loop head. In this case, the variables are `x` and `y`. We don't have any information about their initial values, so we cannot make any specific constraints about them.\n\nNow, let's analyze the loop body and make a note of the loop condition and the given ranking function. The loop condition is `x >= 0 && y >= 0`, and the given ranking function is `(x, Y - y)`.\n\nTo find loop invariants that support the validity of the ranking function and prove the termination of the loop, let's analyze the loop body:\n\n1. `y` is decremented by 1: `y = y - 1`.\n2. If `y < 0`, `x` is decremented by 1: `x = x - 1`, and `y` is assigned a new value: `y = unknown_int()`.\n\nNow, let's output the loop invariants for the given loop:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\at(y, LoopEntry) >= 0 ==> y <= \\at(y, LoopEntry);\n*/\n```\n\nThese invariants are true:\n1. Before the loop execution: Since the loop condition is `x >= 0 && y >= 0`, both `x` and `y` must be non-negative.\n2. In every iteration of the loop: The loop condition ensures that `x` and `y` remain non-negative. Moreover, in each iteration, either `y` is decremented or `y` is assigned a new value which is less than or equal to its initial value at the beginning of the loop iteration.\n3. After the loop termination: The loop terminates when either `x < 0` or `y < 0`, which means that the invariants hold after the loop termination as well."
                ],
                "invariant_code_blocks": [
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= \\at(x, LoopEntry);\n    loop invariant y <= \\at(y, LoopEntry);\n    loop invariant y >= 0 ==> y < \\at(y, LoopEntry);\n    loop invariant y < 0 ==> x < \\at(x, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant y <= \\at(y, LoopEntry);\n*/",
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\at(y, LoopEntry) >= 0 ==> y <= \\at(y, LoopEntry);\n*/"
                ],
                "inductive_invariants": "loop invariant i6: x <= \\at(x, LoopEntry);",
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x, y;\n\t//@ ghost variant_expression measure = { x, Y - y };\n/*@\nloop invariant i6: x <= \\at(x, LoopEntry);\nloop invariant measure.a == x && measure.b == Y - y;\nloop variant measure for lexicographic;\n*/\nwhile (x >= 0 && y >= 0) {\n\t\ty = y - 1;\n\t\tif (y < 0) {\n\t\t\tx = x - 1;\n\t\t\ty = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = x;\n//@ ghost measure.b = Y - y;\n}\n    return 0;\n}",
                "checker_message": "No JSON report found",
                "success": false
            },
            {
                "invariant_code_blocks": [],
                "invariant_llm_output": [],
                "inductive_invariants": [
                    "Invariants not needed"
                ],
                "final_checker_input": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n\tint x, y;\n\t//@ ghost variant_expression measure = { x, y };\n/*@\n\nloop invariant measure.a == x && measure.b == y;\nloop variant measure for lexicographic;\n*/\nwhile (x >= 0 && y >= 0) {\n\t\ty = y - 1;\n\t\tif (y < 0) {\n\t\t\tx = x - 1;\n\t\t\ty = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = x;\n//@ ghost measure.b = y;\n}\n    return 0;\n}",
                "success": true
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c"
        ],
        "skipped": [],
        "total": 48,
        "success_count": 22,
        "failure_count": 26,
        "success_rate": 0.4583333333333333
    }
}