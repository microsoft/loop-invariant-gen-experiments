{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop3.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\twhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
        "success": false,
        "llm_conversation": [
            {
                "role": "system",
                "content": ""
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\twhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t\n```\n\nOutput the loop invariants for the loop in the program above.\nOutput all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```"
            },
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant oddExp >= evenExp - term;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant (count % 2 == 0) ==> (evenExp >= oddExp);\n    loop invariant (count % 2 != 0) ==> (oddExp >= evenExp);\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant evenExp >= oddExp;\n    loop invariant (count % 2) == 0;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= 1;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant oddExp >= evenExp;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/\n```",
            "```\n/*@ \n    loop invariant term >= 0;\n    loop invariant count >= 2;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 0;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= oddExp;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= 0;\n    loop invariant (count % 2 == 0) ==> (oddExp <= evenExp);\n    loop invariant (count % 2 == 1) ==> (oddExp >= evenExp);\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant 0 <= multFactor <= 1;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= 0;\n    loop invariant evenExp >= oddExp;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term >= 0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= 1;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= oddExp;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= oddExp;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant oddExp >= 0 && oddExp <= x;\n    loop invariant evenExp >= 1 && evenExp <= 1 + x;\n*/\n```",
            "```\n/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant oddExp >= evenExp - term;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant (count % 2 == 0) ==> (evenExp >= oddExp);\n    loop invariant (count % 2 != 0) ==> (oddExp >= evenExp);\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant evenExp >= oddExp;\n    loop invariant (count % 2) == 0;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= 1;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant oddExp >= evenExp;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
            "/*@ \n    loop invariant term >= 0;\n    loop invariant count >= 2;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 0;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= oddExp;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= 0;\n    loop invariant (count % 2 == 0) ==> (oddExp <= evenExp);\n    loop invariant (count % 2 == 1) ==> (oddExp >= evenExp);\n*/",
            "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant 0 <= multFactor <= 1;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= 0;\n    loop invariant evenExp >= oddExp;\n*/",
            "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term >= 0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= 1;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
            "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= oddExp;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= oddExp;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
            "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant oddExp >= 0 && oddExp <= x;\n    loop invariant evenExp >= 1 && evenExp <= 1 + x;\n*/",
            "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 4,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant oddExp >= evenExp - term;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nloop invariant evenExp >= 1 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant oddExp >= evenExp - term is inductive.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant (count % 2 == 0) ==> (evenExp >= oddExp);\n    loop invariant (count % 2 != 0) ==> (oddExp >= evenExp);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is established but not preserved.\nloop invariant term > 0 is established but not preserved.\nloop invariant evenExp >= 1.0 is established but not preserved.\nloop invariant oddExp >= x is established but not preserved.\nloop invariant (count % 2 == 0) ==> (evenExp >= oddExp) is established but not preserved.\nloop invariant (count % 2 != 0) ==> (oddExp >= evenExp) is established but not preserved.\nAssertion evenExp >= oddExp: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant evenExp >= oddExp;\n    loop invariant (count % 2) == 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is established but not preserved.\nloop invariant term >= 0 is established but not preserved.\nloop invariant evenExp >= oddExp is established but not preserved.\nloop invariant (count % 2) == 0 is established but not preserved.\nAssertion evenExp >= oddExp: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= 1;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant oddExp >= evenExp;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant oddExp >= evenExp is preserved but not established.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant term >= 0;\n    loop invariant count >= 2;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 0;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= oddExp;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant term >= 0 is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nloop invariant evenExp >= 0 is inductive.\nloop invariant oddExp >= 0 is inductive.\nloop invariant evenExp >= oddExp is inductive.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= 0;\n    loop invariant (count % 2 == 0) ==> (oddExp <= evenExp);\n    loop invariant (count % 2 == 1) ==> (oddExp >= evenExp);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is established but not preserved.\nloop invariant term >= 0 is established but not preserved.\nloop invariant oddExp >= 0 is established but not preserved.\nloop invariant evenExp >= 0 is established but not preserved.\nloop invariant (count % 2 == 0) ==> (oddExp <= evenExp) is established but not preserved.\nloop invariant (count % 2 == 1) ==> (oddExp >= evenExp) is established but not preserved.\nAssertion evenExp >= oddExp: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant 0 <= multFactor <= 1;\n    loop invariant oddExp >= 0;\n    loop invariant evenExp >= 0;\n    loop invariant evenExp >= oddExp;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 && count % 2 == 0 is established but not preserved.\nloop invariant term > 0 is established but not preserved.\nloop invariant 0 <= multFactor <= 1 is established but not preserved.\nloop invariant oddExp >= 0 is established but not preserved.\nloop invariant evenExp >= 0 is established but not preserved.\nloop invariant evenExp >= oddExp is established but not preserved.\nAssertion evenExp >= oddExp: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term >= 0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= 1;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 && count % 2 == 0 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= oddExp;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 && count % 2 == 0 is established but not preserved.\nloop invariant term > 0 is established but not preserved.\nloop invariant evenExp >= 1.0 is established but not preserved.\nloop invariant oddExp >= x is established but not preserved.\nloop invariant evenExp >= oddExp is established but not preserved.\nAssertion evenExp >= oddExp: Unproven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term >= 0;\n    loop invariant evenExp >= 1;\n    loop invariant oddExp >= x;\n    loop invariant evenExp >= oddExp;\n    loop invariant multFactor == 1 || multFactor == -1;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= oddExp is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2 && count % 2 == 0;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant oddExp >= 0 && oddExp <= x;\n    loop invariant evenExp >= 1 && evenExp <= 1 + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 && count % 2 == 0 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nloop invariant oddExp >= 0 && oddExp <= x is inductive.\nloop invariant evenExp >= 1 && evenExp <= 1 + x is inductive.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant count >= 2;\n    loop invariant term > 0;\n    loop invariant multFactor == 1 || multFactor == -1;\n    loop invariant evenExp >= 1.0;\n    loop invariant oddExp >= x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nAssertion evenExp >= oddExp: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
                "checker_output_after_prune": false
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "loop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is preserved but not established.\nloop invariant evenExp >= 1 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant oddExp >= evenExp - term is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant (count % 2 == 0) ==> (evenExp >= oddExp) is inductive.\nloop invariant (count % 2 != 0) ==> (oddExp >= evenExp) is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant evenExp >= oddExp is inductive.\nloop invariant (count % 2) == 0 is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant oddExp >= evenExp is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant evenExp >= 0 is inductive.\nloop invariant oddExp >= 0 is inductive.\nloop invariant evenExp >= oddExp is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant oddExp >= 0 is inductive.\nloop invariant evenExp >= 0 is inductive.\nloop invariant (count % 2 == 0) ==> (oddExp <= evenExp) is inductive.\nloop invariant (count % 2 == 1) ==> (oddExp >= evenExp) is inductive.\nloop invariant count >= 2 && count % 2 == 0 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant 0 <= multFactor <= 1 is inductive.\nloop invariant oddExp >= 0 is inductive.\nloop invariant evenExp >= 0 is inductive.\nloop invariant evenExp >= oddExp is inductive.\nloop invariant count >= 2 && count % 2 == 0 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant count >= 2 && count % 2 == 0 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= oddExp is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term >= 0 is inductive.\nloop invariant evenExp >= 1 is inductive.\nloop invariant oddExp >= x is inductive.\nloop invariant evenExp >= oddExp is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant count >= 2 && count % 2 == 0 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant oddExp >= 0 && oddExp <= x is inductive.\nloop invariant evenExp >= 1 && evenExp <= 1 + x is inductive.\nloop invariant count >= 2 is inductive.\nloop invariant term > 0 is inductive.\nloop invariant multFactor == 1 || multFactor == -1 is inductive.\nloop invariant evenExp >= 1.0 is inductive.\nloop invariant oddExp >= x is inductive.\nAssertion evenExp >= oddExp: Partially proven",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\nloop invariant i1: count >= 2;\nloop invariant i2: term > 0;\nloop invariant i3: multFactor == 1 || multFactor == -1;\nloop invariant i4: evenExp >= 1;\nloop invariant i5: oddExp >= x;\nloop invariant i6: oddExp >= evenExp - term;\nloop invariant i7: count >= 2;\nloop invariant i8: term > 0;\nloop invariant i9: evenExp >= 1.0;\nloop invariant i10: oddExp >= x;\nloop invariant i11: (count % 2 == 0) ==> (evenExp >= oddExp);\nloop invariant i12: (count % 2 != 0) ==> (oddExp >= evenExp);\nloop invariant i13: count >= 2;\nloop invariant i14: term >= 0;\nloop invariant i15: evenExp >= oddExp;\nloop invariant i16: (count % 2) == 0;\nloop invariant i17: count >= 2;\nloop invariant i18: term >= 0;\nloop invariant i19: oddExp >= x;\nloop invariant i20: evenExp >= 1;\nloop invariant i21: multFactor == 1 || multFactor == -1;\nloop invariant i22: count >= 2;\nloop invariant i23: term > 0;\nloop invariant i24: evenExp >= 1;\nloop invariant i25: oddExp >= x;\nloop invariant i26: multFactor == 1 || multFactor == -1;\nloop invariant i27: count >= 2;\nloop invariant i28: term > 0;\nloop invariant i29: evenExp >= 1.0;\nloop invariant i30: oddExp >= x;\nloop invariant i31: multFactor == 1 || multFactor == -1;\nloop invariant i32: count >= 2;\nloop invariant i33: term > 0;\nloop invariant i34: evenExp >= 1.0;\nloop invariant i35: oddExp >= x;\nloop invariant i36: oddExp >= evenExp;\nloop invariant i37: multFactor == 1 || multFactor == -1;\nloop invariant i38: term >= 0;\nloop invariant i39: count >= 2;\nloop invariant i40: multFactor == 1 || multFactor == -1;\nloop invariant i41: evenExp >= 0;\nloop invariant i42: oddExp >= 0;\nloop invariant i43: evenExp >= oddExp;\nloop invariant i44: count >= 2;\nloop invariant i45: term >= 0;\nloop invariant i46: oddExp >= 0;\nloop invariant i47: evenExp >= 0;\nloop invariant i48: (count % 2 == 0) ==> (oddExp <= evenExp);\nloop invariant i49: (count % 2 == 1) ==> (oddExp >= evenExp);\nloop invariant i50: count >= 2 && count % 2 == 0;\nloop invariant i51: term > 0;\nloop invariant i52: 0 <= multFactor <= 1;\nloop invariant i53: oddExp >= 0;\nloop invariant i54: evenExp >= 0;\nloop invariant i55: evenExp >= oddExp;\nloop invariant i56: count >= 2 && count % 2 == 0;\nloop invariant i57: term >= 0;\nloop invariant i58: oddExp >= x;\nloop invariant i59: evenExp >= 1;\nloop invariant i60: multFactor == 1 || multFactor == -1;\nloop invariant i61: count >= 2 && count % 2 == 0;\nloop invariant i62: term > 0;\nloop invariant i63: evenExp >= 1.0;\nloop invariant i64: oddExp >= x;\nloop invariant i65: evenExp >= oddExp;\nloop invariant i66: count >= 2;\nloop invariant i67: term >= 0;\nloop invariant i68: evenExp >= 1;\nloop invariant i69: oddExp >= x;\nloop invariant i70: evenExp >= oddExp;\nloop invariant i71: multFactor == 1 || multFactor == -1;\nloop invariant i72: count >= 2 && count % 2 == 0;\nloop invariant i73: term > 0;\nloop invariant i74: multFactor == 1 || multFactor == -1;\nloop invariant i75: oddExp >= 0 && oddExp <= x;\nloop invariant i76: evenExp >= 1 && evenExp <= 1 + x;\nloop invariant i77: count >= 2;\nloop invariant i78: term > 0;\nloop invariant i79: multFactor == 1 || multFactor == -1;\nloop invariant i80: evenExp >= 1.0;\nloop invariant i81: oddExp >= x;\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
        "combined_annotation_num_solver_calls": 7,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nfloat pi = 3.14159 ;\n\nint main()\n{\n\tfloat x = unknown_float() ;\n\tfloat octant1 = 0 ;\n\tfloat octant2 = pi/8 ;\n\tassume(x > octant1 && x < octant2) ;\n\tfloat oddExp = x ;\n\tfloat evenExp = 1.0 ;\n\tfloat term = x ;\n\tunsigned int count = 2 ;\n\tint multFactor = 0 ;\n\tint temp ;\n\n\t/*@\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\nwhile(1)\n\t{\n\t\tterm = term * (x/count) ;\n\t\tmultFactor = (count>>1 % 2 == 0) ? 1 : -1 ;\n\n\t\tevenExp = evenExp + multFactor*term ;\n\n\t\tcount++ ;\n\n\t\tterm = term * (x/count) ;\t\t\n\t\t\n\t\toddExp = oddExp + multFactor*term ;\n\t\t\n\t\tcount++ ;\n\n\t\ttemp = unknown_int() ;\n\t\tif(temp == 0) break ;\n\t}\n\n\t{;\n//@ assert( evenExp >= oddExp );\n}\n\n\treturn 0 ;\n}\t",
        "checker_output_after_prune": false
    },
    "stats": {
        "success": [
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono1_1-2.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_11.c"
        ],
        "failure": [
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-simple/nested_1b.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/linear-inequality-inv-b.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono1_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop2-1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono3_1.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/linear-inequality-inv-a.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop3.c"
        ],
        "skipped": [],
        "total": 11,
        "success_count": 2,
        "failure_count": 9,
        "success_rate": 0.18181818181818182
    }
}