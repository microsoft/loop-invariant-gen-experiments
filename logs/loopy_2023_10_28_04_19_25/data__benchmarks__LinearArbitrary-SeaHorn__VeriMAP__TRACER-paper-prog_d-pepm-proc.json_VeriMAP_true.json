{
    "logs": {
        "file": "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-paper-prog_d-pepm-proc.c_VeriMAP_true.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\twhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": ""
            },
            {
                "role": "user",
                "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\twhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}\n```\n\nOutput the loop invariants for the loop in the program above.\nOutput all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```"
            },
            "```\n/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, LoopEntry) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant x <= 10000;\n    loop invariant x == y;\n    loop invariant y >= 0;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/\n```",
            "```\n/*@ \n    loop invariant 0 <= x <= 10000;\n    loop invariant y >= 0;\n    loop invariant y == x + unknown_uint();\n*/\n```",
            "```\n/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/\n```",
            "```\n/*@ \n    loop invariant y == x;\n    loop invariant x <= 10000;\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == x + \\at(y, PreLoop);\n*/\n```",
            "```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == x + \\at(y, Pre);\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
            "/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, LoopEntry) + x;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
            "/*@ \n    loop invariant x <= 10000;\n    loop invariant x == y;\n    loop invariant y >= 0;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
            "/*@ \n    loop invariant 0 <= x <= 10000;\n    loop invariant y >= 0;\n    loop invariant y == x + unknown_uint();\n*/",
            "/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/",
            "/*@ \n    loop invariant y == x;\n    loop invariant x <= 10000;\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == x + \\at(y, PreLoop);\n*/",
            "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == x + \\at(y, Pre);\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant y == x is preserved but not established.\nloop invariant x >= 0 is inductive.\nloop invariant y >= 0 is inductive.\nloop invariant x <= 10000 is inductive.\nAssertion \\false: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\n\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x <= 10000;\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant y == x is preserved but not established.\nloop invariant x >= 0 is inductive.\nloop invariant y >= 0 is inductive.\nloop invariant x <= 10000 is inductive.\nAssertion \\false: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\n\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x <= 10000;\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, LoopEntry) + x;\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant x >= 0 is inductive.\nloop invariant y >= 0 is inductive.\nloop invariant x <= 10000 is inductive.\nloop invariant y == \\at(y, LoopEntry) + x is inductive.\nAssertion \\false: Valid"
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x <= 10000;\n    loop invariant x == y;\n    loop invariant y >= 0;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant x <= 10000 is inductive.\nloop invariant x == y is preserved but not established.\nloop invariant y >= 0 is inductive.\nAssertion \\false: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x <= 10000;\n\nloop invariant i3: y >= 0;\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == \\at(y, Pre) + x;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant 0 <= x <= 10000;\n    loop invariant y >= 0;\n    loop invariant y == x + unknown_uint();\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 16: unexpected token ')'",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: 0 <= x <= 10000;\nloop invariant i2: y >= 0;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant y == x;\n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant y == x is preserved but not established.\nloop invariant x >= 0 is inductive.\nloop invariant y >= 0 is inductive.\nloop invariant x <= 10000 is inductive.\nAssertion \\false: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\n\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x <= 10000;\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 3,
                "annotations": "/*@ \n    loop invariant y == x;\n    loop invariant x <= 10000;\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "loop invariant y == x is preserved but not established.\nloop invariant x <= 10000 is inductive.\nAssertion \\false: Partially proven",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\n\nloop invariant i2: x <= 10000;\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == x + \\at(y, PreLoop);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: logic label `PreLoop' not found. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant x <= 10000;\n    loop invariant y == x + \\at(y, Pre);\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 17: unbound logic variable y. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i3: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
                "checker_output_after_prune": true
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 55: unexpected token ')'",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\nloop invariant i1: y == x;\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x <= 10000;\nloop invariant i5: x >= 0;\nloop invariant i6: y >= 0;\nloop invariant i7: x <= 10000;\nloop invariant i8: y == \\at(y, Pre) + x;\nloop invariant i9: x >= 0;\nloop invariant i10: y >= 0;\nloop invariant i11: x <= 10000;\nloop invariant i12: y == \\at(y, Pre) + x;\nloop invariant i13: y == x;\nloop invariant i14: x >= 0;\nloop invariant i15: y >= 0;\nloop invariant i16: x <= 10000;\nloop invariant i17: x >= 0;\nloop invariant i18: y >= 0;\nloop invariant i19: x <= 10000;\nloop invariant i20: y == \\at(y, LoopEntry) + x;\nloop invariant i21: x >= 0;\nloop invariant i22: y >= 0;\nloop invariant i23: x <= 10000;\nloop invariant i24: y == \\at(y, Pre) + x;\nloop invariant i25: x >= 0;\nloop invariant i26: y >= 0;\nloop invariant i27: x <= 10000;\nloop invariant i28: y == \\at(y, Pre) + x;\nloop invariant i29: x >= 0;\nloop invariant i30: y >= 0;\nloop invariant i31: x <= 10000;\nloop invariant i32: y == \\at(y, Pre) + x;\nloop invariant i33: x <= 10000;\nloop invariant i34: x == y;\nloop invariant i35: y >= 0;\nloop invariant i36: x >= 0;\nloop invariant i37: y >= 0;\nloop invariant i38: x <= 10000;\nloop invariant i39: y == \\at(y, Pre) + x;\nloop invariant i40: 0 <= x <= 10000;\nloop invariant i41: y >= 0;\nloop invariant i42: y == x + unknown_uint();\nloop invariant i43: y == x;\nloop invariant i44: x >= 0;\nloop invariant i45: y >= 0;\nloop invariant i46: x <= 10000;\nloop invariant i47: y == x;\nloop invariant i48: x <= 10000;\nloop invariant i49: x >= 0;\nloop invariant i50: y >= 0;\nloop invariant i51: x <= 10000;\nloop invariant i52: y == x + \\at(y, PreLoop);\nloop invariant i53: x >= 0;\nloop invariant i54: y >= 0;\nloop invariant i55: x <= 10000;\nloop invariant i56: y == x + \\at(y, Pre);\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
        "combined_annotation_num_solver_calls": 12,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n;\n\nvoid errorFn() {ERROR: goto ERROR;}\nint main(){\nint y = unknown_uint();\nint x=0;\n\n    assume(y>=0);\n\n\t/*@\n\nloop invariant i2: x >= 0;\nloop invariant i3: y >= 0;\nloop invariant i4: x <= 10000;\nloop invariant i5: x >= 0;\nloop invariant i6: y >= 0;\nloop invariant i7: x <= 10000;\n\nloop invariant i9: x >= 0;\nloop invariant i10: y >= 0;\nloop invariant i11: x <= 10000;\n\n\nloop invariant i14: x >= 0;\nloop invariant i15: y >= 0;\nloop invariant i16: x <= 10000;\nloop invariant i17: x >= 0;\nloop invariant i18: y >= 0;\nloop invariant i19: x <= 10000;\nloop invariant i20: y == \\at(y, LoopEntry) + x;\nloop invariant i21: x >= 0;\nloop invariant i22: y >= 0;\nloop invariant i23: x <= 10000;\n\nloop invariant i25: x >= 0;\nloop invariant i26: y >= 0;\nloop invariant i27: x <= 10000;\n\nloop invariant i29: x >= 0;\nloop invariant i30: y >= 0;\nloop invariant i31: x <= 10000;\n\nloop invariant i33: x <= 10000;\n\nloop invariant i35: y >= 0;\nloop invariant i36: x >= 0;\nloop invariant i37: y >= 0;\nloop invariant i38: x <= 10000;\n\nloop invariant i40: 0 <= x <= 10000;\nloop invariant i41: y >= 0;\n\n\nloop invariant i44: x >= 0;\nloop invariant i45: y >= 0;\nloop invariant i46: x <= 10000;\n\nloop invariant i48: x <= 10000;\nloop invariant i49: x >= 0;\nloop invariant i50: y >= 0;\nloop invariant i51: x <= 10000;\n\nloop invariant i53: x >= 0;\nloop invariant i54: y >= 0;\nloop invariant i55: x <= 10000;\n\n*/\nwhile ( x < 10000) {\n\t\ty = y + 1;\n\t\tx = x + 1;\n\t}\n\n\tif( y + x < 10000)\t\t\n\t\tgoto ERROR;\n\n\treturn 0;\n{ ERROR: {; \n//@ assert(\\false);\n}\n}\n\treturn -1;\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono1_1-2.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/mono-crafted_11.c",
            "../data/benchmarks/sv-benchmarks/loop-simple/nested_1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/MAP-forward_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/invgen/ken-imp.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/MAP-CPA-example_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/MAP-singleloop2-pepm-proc.c_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/MAP-disj_VeriMAP_true.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/TRACER-paper-prog_d-pepm-proc.c_VeriMAP_true.c"
        ],
        "failure": [
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop1-2.c",
            "../data/benchmarks/sv-benchmarks/loop-simple/nested_1b.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/linear-inequality-inv-b.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono1_1-1.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop2-1.c",
            "../data/benchmarks/sv-benchmarks/loops-crafted-1/Mono3_1.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop2-2.c",
            "../data/benchmarks/sv-benchmarks/loop-invariants/linear-inequality-inv-a.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop3.c",
            "../data/benchmarks/sv-benchmarks/loop-floats-scientific-comp/loop1-1.c",
            "../data/benchmarks/LinearArbitrary-SeaHorn/VeriMAP/MAP-interpolants_needed-pepm-proc.c_VeriMAP_true.c"
        ],
        "skipped": [],
        "total": 20,
        "success_count": 9,
        "failure_count": 11,
        "success_rate": 0.45
    }
}