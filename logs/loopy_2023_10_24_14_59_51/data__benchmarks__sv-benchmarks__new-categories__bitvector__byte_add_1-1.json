{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/new-categories/bitvector/byte_add_1-1.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/* Function_mp_add */\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /* Loop_A */  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /* Loop_B */  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/* Function_main */\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "Given a program, you can find loop invariants and function contracts, which can then be used to verify the properties in the program.\nA loop invariant is an expression that is true before, during and after the execution of a loop.\nA function contract is a pair of expressions, (called the pre-condition and post-condition) that are true before and after the execution of the function, respectively.\nThe pre-condition is usually an expression over the arguments of the function, and the post-condition is usually an expression over the arguments and the return value of the function.\nFor the given program, find the necessary loop invariants for each loop, and the function contract for each function in the program.\nEach loop is marked by a label provided as a comment at the beginning of the loop statement. A loop label is of the form Loop_X, where X is an uppercase letter, e.g., Loop_A, Loop_B, etc.\nEach function is marked by a label provided as a comment at the beginning of the function definition. A function label is of the form Function_X, where X is the name of the function, e.g., Function_main, Function_foo, etc.\n\nInstructions:\n- For every function in the given program,\n    - Make a note of the arguments given to the function.\n    - Analyze the function body and make a note of the return value(s).\n    - Output the function contract that comprises of requires and ensures clause, that are true before and after the function execution, respectively. \n    - Output the contract in ACSL syntax, with the corresponding labels.\n- For every loop in the given program,\n    - Make a note of the pre-conditions or variable assignments in the program.\n    - Analyze the loop body and make a note of the loop condition. \n    - Output loop invariants that are true\n    (i) before the loop execution, \n    (ii) in every iteration of the loop and \n    (iii) after the loop termination, \n    such that the loop invariants imply the post condition.\n    - If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants and function contracts in one code block, with the corresponding labels as XML tags.\nOutput each function contract in an XML tag of the form <Function_X>, where Function_X is the function label. Ensure each clause is in a separate line.\nOutput each loop invariant in an XML tag of the form <Loop_X>, where Loop_X is the loop label.\nFor example:\n```\n/*@\n    <Function_main> \n        requires r1;\n        ensures r2;\n    </Function_main>\n\n    <Function_foo> \n        requires r3;\n        ensures r4;\n    </Function_foo>\n\n    <Loop_A>\n        loop invariant i1;\n        loop invariant i2;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i3;\n    </Loop_B>\n*/\n```\n\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Assume that all variables that are not explicitly initialized, have garbage (unknown) values.**\n- **Assume that all functions that are not explicitly defined, have unknown behavior.**\n- **Use the expression \"\\at(x, Pre)\" or \"\\old(x)\" to refer to the value of variable x before the execution of the function.**\n- **Use the expression \"\\at(x, Post)\" to refer to the value of variable x after the execution of the function.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of variable x at the beginning of the loop.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/* Function_mp_add */\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /* Loop_A */  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /* Loop_B */  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/* Function_main */\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}\n```\n\nUse the ACSL syntax to specify the loop invariants for each of the loops in the program, and function contracts for the functions in the program. \nThe function contracts must include the pre- and post-conditions, and the loop invariants must be specified for each loop in the program. \nThe loop invariants must be specified using the \"loop invariant\" annotation and must end with a semi-colon.\nThe function contracts must be specified using the \"requires\" and \"ensures\" clauses and must end with semi-colons.\nAll the annotations must be provided along with the label of the loop or function, in XML format.\n\nConsider all uninitialized variables contain garbage values. Ensure that the invariants and function contracts are specified in such a way that the program is verified successfully.\nLet's think step by step."
            },
            "Here are the loop invariants and function contracts for the given program using ACSL syntax:\n\n```\n/*@\n    <Function_mp_add>\n        requires a >= 0;\n        requires b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0;\n        loop invariant na <= 4;\n        loop invariant nb <= 4;\n        loop invariant ((i <= na) && (i <= nb)) || (carry == 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 4 <= i <= 4;\n    </Loop_B>\n*/\n```\n\nThese annotations specify the preconditions, postconditions, and loop invariants necessary for the verification of the given C program.",
            "```\n/*@\n    <Function_mp_add> \n        requires a <= UINT32_MAX;\n        requires b <= UINT32_MAX;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main>\n        requires b <= UINT32_MAX;\n        ensures r == 234770789 + b;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant 0 <= carry <= 1;\n        loop invariant partial_sum == carry + (i < na ? (i == 0 ? a0 : (i == 1 ? a1 : (i == 2 ? a2 : a3))) : 0) + (i < nb ? (i == 0 ? b0 : (i == 1 ? b1 : (i == 2 ? b2 : b3))) : 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/\n```",
            "First, let's write the function contract for Function_mp_add. The function takes two unsigned int arguments a and b and returns an unsigned int r, which is the sum of a and b. So, the pre-condition is true (no restrictions on a and b), and the post-condition is r == a + b.\n\nNow, let's analyze the loops. Loop_A calculates the addition of a and b in an iterative way, with the help of carry and partial_sum variables. Loop_B initializes the rest of the result bytes to 0 if they were not set in Loop_A.\n\nHere are the loop invariants and function contracts:\n\n```\n/*@\n    <Function_mp_add> \n        requires \\true;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0 && partial_sum <= 511;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/\n```\nThese loop invariants and function contracts should help in verifying the properties of the program.",
            "First, we will analyze the function `mp_add` and find its contract.\nFunction arguments: `unsigned int a, unsigned int b`\nReturn value: `unsigned int r`\n\nPre-condition: None\nPost-condition: `r == a + b`\n\nNow, we will analyze the loops and find their invariants.\n\nLoop_A:\n- Pre-conditions/variable assignments:\n    - `carry = (unsigned short)0`\n    - `i = (unsigned char)0`\n- Loop condition: `(i < na) || (i < nb) || (carry != (unsigned short)0)`\n\nLoop invariants:\n1. `0 <= i <= 4`\n2. `0 <= carry <= 1`\n3. `partial_sum == carry + (i < na ? a[i] : 0) + (i < nb ? b[i] : 0)`\n\nLoop_B:\n- Pre-conditions/variable assignments:\n    - `i` is coming from the previous loop.\n- Loop condition: `i < (unsigned char)4`\n\nLoop invariants:\n1. `0 <= i <= 4`\n2. `r[i] == 0` for `i` in the range of the loop condition.\n\nPutting everything together in ACSL syntax, we get:\n\n```C\n/*@\n    <Function_mp_add> \n        requires true;\n        ensures r == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant 0 <= carry <= 1;\n        loop invariant partial_sum == carry + (i < na ? a[i] : 0) + (i < nb ? b[i] : 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n        loop invariant r[i] == 0;\n    </Loop_B>\n*/\n```",
            "First, let's analyze the function mp_add and specify the function contract.\n\nThe function takes two unsigned integers a and b as input and returns their sum r. There are no specific requirements on the input values.\n\nThe post-condition ensures that the returned value r is equal to the sum of a and b.\n\nNow, let's analyze the loops.\n\nLoop_A iterates while i is less than na or nb or carry is not equal to 0. In each iteration, it calculates the partial sum for each byte of the input numbers a and b, and updates the carry if needed. The loop invariant should ensure that the partial sum and carry are correctly updated at each step.\n\nLoop_B iterates while i is less than 4 and sets the remaining bytes of the result r to 0. The loop invariant should ensure that the remaining bytes of the result are set to 0.\n\nNow, let's write the loop invariants and function contracts in ACSL syntax with the corresponding labels.\n\n```\n/*@\n    <Function_mp_add> \n        requires a == \\at(a, Pre) && b == \\at(b, Pre);\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant \\forall unsigned char j; 0 <= j < i ==> (r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U)) == \\at(a, Pre) + \\at(b, Pre) - carry - partial_sum;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n        loop invariant \\forall unsigned char j; i <= j < 4 ==> (((r0 << 8U) | r1) | (r2 << 16U) | ((unsigned int)r3 << 24U)) & (1U << (8U * j)) == 0;\n    </Loop_B>\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@\n    <Function_mp_add>\n        requires a >= 0;\n        requires b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0;\n        loop invariant na <= 4;\n        loop invariant nb <= 4;\n        loop invariant ((i <= na) && (i <= nb)) || (carry == 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 4 <= i <= 4;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires a <= UINT32_MAX;\n        requires b <= UINT32_MAX;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main>\n        requires b <= UINT32_MAX;\n        ensures r == 234770789 + b;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant 0 <= carry <= 1;\n        loop invariant partial_sum == carry + (i < na ? (i == 0 ? a0 : (i == 1 ? a1 : (i == 2 ? a2 : a3))) : 0) + (i < nb ? (i == 0 ? b0 : (i == 1 ? b1 : (i == 2 ? b2 : b3))) : 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires \\true;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0 && partial_sum <= 511;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires true;\n        ensures r == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant 0 <= carry <= 1;\n        loop invariant partial_sum == carry + (i < na ? a[i] : 0) + (i < nb ? b[i] : 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n        loop invariant r[i] == 0;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires a == \\at(a, Pre) && b == \\at(b, Pre);\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant \\forall unsigned char j; 0 <= j < i ==> (r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U)) == \\at(a, Pre) + \\at(b, Pre) - carry - partial_sum;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n        loop invariant \\forall unsigned char j; i <= j < 4 ==> (((r0 << 8U) | r1) | (r2 << 16U) | ((unsigned int)r3 << 24U)) & (1U << (8U * j)) == 0;\n    </Loop_B>\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_mp_add>\n        requires a >= 0;\n        requires b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0;\n        loop invariant na <= 4;\n        loop invariant nb <= 4;\n        loop invariant ((i <= na) && (i <= nb)) || (carry == 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 4 <= i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 4 <= i <= 4 is preserved but not established.\nloop invariant 0 <= i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant partial_sum >= 0 is inductive.\nloop invariant na <= 4 is inductive.\nloop invariant nb <= 4 is inductive.\nloop invariant ((i <= na) && (i <= nb)) || (carry == 0) is established but not preserved.\nAssertion r == a + b: Valid\nPre-condition a >= 0 on line 10: Valid\nPre-condition b >= 0 on line 11: Valid\nPost-condition \\result == \\old(a) + \\old(b) on line 13: Unknown"
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@\n    <Function_mp_add> \n        requires a <= UINT32_MAX;\n        requires b <= UINT32_MAX;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main>\n        requires b <= UINT32_MAX;\n        ensures r == 234770789 + b;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant 0 <= carry <= 1;\n        loop invariant partial_sum == carry + (i < na ? (i == 0 ? a0 : (i == 1 ? a1 : (i == 2 ? a2 : a3))) : 0) + (i < nb ? (i == 0 ? b0 : (i == 1 ? b1 : (i == 2 ? b2 : b3))) : 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 10: unbound logic variable UINT32_MAX. Ignoring logic specification of function mp_add",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/*@\n\n\n\nensures \\result == a + b;\n*/\n\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /*@\n\nloop invariant i2: 0 <= i <= 4;\nloop invariant i3: 0 <= carry <= 1;\nloop invariant i4: partial_sum == carry + (i < na ? (i == 0 ? a0 : (i == 1 ? a1 : (i == 2 ? a2 : a3))) : 0) + (i < nb ? (i == 0 ? b0 : (i == 1 ? b1 : (i == 2 ? b2 : b3))) : 0);\n*/\n  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /*@\n\nloop invariant i1: 0 <= i <= 4;\n*/\n  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/*@\nrequires \\true;\n\n\n*/\n\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
                "checker_output_after_prune": true
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_mp_add> \n        requires \\true;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0 && partial_sum <= 511;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 0 <= i <= 4 is inductive.\nloop invariant 0 <= i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant partial_sum >= 0 && partial_sum <= 511 is neither established nor preserved.\nAssertion r == a + b: Valid\nPre-condition \\true on line 10: Valid\nPost-condition \\result == \\old(a) + \\old(b) on line 12: Unknown"
            },
            {
                "num_solver_calls": 4,
                "annotations": "/*@\n    <Function_mp_add> \n        requires true;\n        ensures r == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant 0 <= carry <= 1;\n        loop invariant partial_sum == carry + (i < na ? a[i] : 0) + (i < nb ? b[i] : 0);\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n        loop invariant r[i] == 0;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 10: unbound logic variable true. Ignoring logic specification of function mp_add",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/*@\n\n\n\n*/\n\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /*@\n\nloop invariant i3: 0 <= i <= 4;\nloop invariant i4: 0 <= carry <= 1;\nloop invariant i5: partial_sum == carry + (i < na ? a[i] : 0) + (i < nb ? b[i] : 0);\n*/\n  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /*@\n\nloop invariant i1: 0 <= i <= 4;\nloop invariant i2: r[i] == 0;\n*/\n  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
                "checker_output_after_prune": false
            },
            {
                "num_solver_calls": 2,
                "annotations": "/*@\n    <Function_mp_add> \n        requires a == \\at(a, Pre) && b == \\at(b, Pre);\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant \\forall unsigned char j; 0 <= j < i ==> (r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U)) == \\at(a, Pre) + \\at(b, Pre) - carry - partial_sum;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n        loop invariant \\forall unsigned char j; i <= j < 4 ==> (((r0 << 8U) | r1) | (r2 << 16U) | ((unsigned int)r3 << 24U)) & (1U << (8U * j)) == 0;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": false,
                "checker_message_for_annotations": "Annotation error on line 98: invalid operands to binary &; unexpected ℤ and 𝔹. Ignoring loop annotation",
                "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/*@\nrequires a == \\at(a, Pre) && b == \\at(b, Pre);\n\nensures \\result == a + b;\n*/\n\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /*@\n\nloop invariant i3: 0 <= i <= 4;\nloop invariant i4: \\forall unsigned char j; 0 <= j < i ==> (r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U)) == \\at(a, Pre) + \\at(b, Pre) - carry - partial_sum;\n*/\n  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /*@\n\nloop invariant i1: 0 <= i <= 4;\n\n*/\n  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
                "checker_output_after_prune": true
            }
        ],
        "checker_output_for_combined_annotations": false,
        "checker_message_for_combined_annotations": "Annotation error on line 11: unbound logic variable true. Ignoring logic specification of function mp_add",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/*@\nrequires a == \\at(a, Pre) && b == \\at(b, Pre);\nrequires true;\nrequires \\true;\nrequires a <= UINT32_MAX;\nrequires b <= UINT32_MAX;\nrequires a >= 0;\nrequires b >= 0;\n\nensures \\result == a + b;\nensures \\result == a + b;\nensures \\result == a + b;\nensures r == a + b;\nensures \\result == a + b;\n*/\n\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /*@\n\nloop invariant i2: 0 <= i <= 4;\nloop invariant i3: carry == 0 || carry == 1;\nloop invariant i4: partial_sum >= 0;\nloop invariant i5: na <= 4;\nloop invariant i6: nb <= 4;\nloop invariant i7: ((i <= na) && (i <= nb)) || (carry == 0);\nloop invariant i9: 0 <= i <= 4;\nloop invariant i10: 0 <= carry <= 1;\nloop invariant i11: partial_sum == carry + (i < na ? (i == 0 ? a0 : (i == 1 ? a1 : (i == 2 ? a2 : a3))) : 0) + (i < nb ? (i == 0 ? b0 : (i == 1 ? b1 : (i == 2 ? b2 : b3))) : 0);\nloop invariant i13: 0 <= i <= 4;\nloop invariant i14: carry == 0 || carry == 1;\nloop invariant i15: partial_sum >= 0 && partial_sum <= 511;\nloop invariant i18: 0 <= i <= 4;\nloop invariant i19: 0 <= carry <= 1;\nloop invariant i20: partial_sum == carry + (i < na ? a[i] : 0) + (i < nb ? b[i] : 0);\nloop invariant i23: 0 <= i <= 4;\nloop invariant i24: \\forall unsigned char j; 0 <= j < i ==> (r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U)) == \\at(a, Pre) + \\at(b, Pre) - carry - partial_sum;\n*/\n  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /*@\n\nloop invariant i1: 4 <= i <= 4;\nloop invariant i8: 0 <= i <= 4;\nloop invariant i12: 0 <= i <= 4;\nloop invariant i16: 0 <= i <= 4;\nloop invariant i17: r[i] == 0;\nloop invariant i21: 0 <= i <= 4;\nloop invariant i22: \\forall unsigned char j; i <= j < 4 ==> (((r0 << 8U) | r1) | (r2 << 16U) | ((unsigned int)r3 << 24U)) & (1U << (8U * j)) == 0;\n*/\n  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/*@\nrequires \\true;\n\nensures r == 234770789 + b;\n*/\n\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
        "combined_annotation_num_solver_calls": 9,
        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/*@\nrequires a == \\at(a, Pre) && b == \\at(b, Pre);\n\nrequires \\true;\n\n\nrequires a >= 0;\nrequires b >= 0;\n\nensures \\result == a + b;\nensures \\result == a + b;\nensures \\result == a + b;\n\nensures \\result == a + b;\n*/\n\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /*@\n\nloop invariant i2: 0 <= i <= 4;\nloop invariant i3: carry == 0 || carry == 1;\nloop invariant i4: partial_sum >= 0;\nloop invariant i5: na <= 4;\nloop invariant i6: nb <= 4;\nloop invariant i7: ((i <= na) && (i <= nb)) || (carry == 0);\nloop invariant i9: 0 <= i <= 4;\nloop invariant i10: 0 <= carry <= 1;\nloop invariant i11: partial_sum == carry + (i < na ? (i == 0 ? a0 : (i == 1 ? a1 : (i == 2 ? a2 : a3))) : 0) + (i < nb ? (i == 0 ? b0 : (i == 1 ? b1 : (i == 2 ? b2 : b3))) : 0);\nloop invariant i13: 0 <= i <= 4;\nloop invariant i14: carry == 0 || carry == 1;\nloop invariant i15: partial_sum >= 0 && partial_sum <= 511;\nloop invariant i18: 0 <= i <= 4;\nloop invariant i19: 0 <= carry <= 1;\n\nloop invariant i23: 0 <= i <= 4;\nloop invariant i24: \\forall unsigned char j; 0 <= j < i ==> (r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U)) == \\at(a, Pre) + \\at(b, Pre) - carry - partial_sum;\n*/\n  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /*@\n\nloop invariant i1: 4 <= i <= 4;\nloop invariant i8: 0 <= i <= 4;\nloop invariant i12: 0 <= i <= 4;\nloop invariant i16: 0 <= i <= 4;\n\nloop invariant i21: 0 <= i <= 4;\n\n*/\n  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/*@\nrequires \\true;\n\n\n*/\n\nint main()\n{\n    unsigned int a, b, r;\n\n    b = unknown_uint();\n\n    a = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
        "checker_output_after_prune": true
    },
    "stats": {
        "success": [
            "../data/benchmarks/sv-benchmarks/new-categories/bitvector/byte_add_1-1.c"
        ],
        "failure": [],
        "skipped": [],
        "total": 1,
        "success_count": 1,
        "failure_count": 0,
        "success_rate": 1.0
    }
}