{
    "logs": {
        "file": "../data/benchmarks/sv-benchmarks/new-categories/bitvector/byte_add_2-2.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/* Function_mp_add */\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /* Loop_A */  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /* Loop_B */  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/* Function_main */\nint main()\n{\n    unsigned int a, b, r;\n\n    a = unknown_uint();\n    b = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}",
        "success": true,
        "llm_conversation": [
            {
                "role": "system",
                "content": "Given a program, you can find loop invariants and function contracts, which can then be used to verify the properties in the program.\nA loop invariant is an expression that is true before, during and after the execution of a loop.\nA function contract is a pair of expressions, (called the pre-condition and post-condition) that are true before and after the execution of the function, respectively.\nThe pre-condition is usually an expression over the arguments of the function, and the post-condition is usually an expression over the arguments and the return value of the function.\nFor the given program, find the necessary loop invariants for each loop, and the function contract for each function in the program.\nEach loop is marked by a label provided as a comment at the beginning of the loop statement. A loop label is of the form Loop_X, where X is an uppercase letter, e.g., Loop_A, Loop_B, etc.\nEach function is marked by a label provided as a comment at the beginning of the function definition. A function label is of the form Function_X, where X is the name of the function, e.g., Function_main, Function_foo, etc.\n\nInstructions:\n- For every function in the given program,\n    - Make a note of the arguments given to the function.\n    - Analyze the function body and make a note of the return value(s).\n    - Output the function contract that comprises of requires and ensures clause, that are true before and after the function execution, respectively. \n    - Output the contract in ACSL syntax, with the corresponding labels.\n- For every loop in the given program,\n    - Make a note of the pre-conditions or variable assignments in the program.\n    - Analyze the loop body and make a note of the loop condition. \n    - Output loop invariants that are true\n    (i) before the loop execution, \n    (ii) in every iteration of the loop and \n    (iii) after the loop termination, \n    such that the loop invariants imply the post condition.\n    - If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants and function contracts in one code block, with the corresponding labels as XML tags.\nOutput each function contract in an XML tag of the form <Function_X>, where Function_X is the function label. Ensure each clause is in a separate line.\nOutput each loop invariant in an XML tag of the form <Loop_X>, where Loop_X is the loop label.\nFor example:\n```\n/*@\n    <Function_main> \n        requires r1;\n        ensures r2;\n    </Function_main>\n\n    <Function_foo> \n        requires r3;\n        ensures r4;\n    </Function_foo>\n\n    <Loop_A>\n        loop invariant i1;\n        loop invariant i2;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i3;\n    </Loop_B>\n*/\n```\n\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Assume that all variables that are not explicitly initialized, have garbage (unknown) values.**\n- **Assume that all functions that are not explicitly defined, have unknown behavior.**\n- **Use the expression \"\\at(x, Pre)\" or \"\\old(x)\" to refer to the value of variable x before the execution of the function.**\n- **Use the expression \"\\at(x, Post)\" to refer to the value of variable x after the execution of the function.**\n- **Use the expression \"\\at(x, LoopEntry)\" to refer to the value of variable x at the beginning of the loop.**"
            },
            {
                "role": "user",
                "content": "Consider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/* Function_mp_add */\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /* Loop_A */  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /* Loop_B */  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/* Function_main */\nint main()\n{\n    unsigned int a, b, r;\n\n    a = unknown_uint();\n    b = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}\n```\n\nUse the ACSL syntax to specify the loop invariants for each of the loops in the program, and function contracts for the functions in the program. \nThe function contracts must include the pre- and post-conditions, and the loop invariants must be specified for each loop in the program. \nThe loop invariants must be specified using the \"loop invariant\" annotation and must end with a semi-colon.\nThe function contracts must be specified using the \"requires\" and \"ensures\" clauses and must end with semi-colons.\nAll the annotations must be provided along with the label of the loop or function, in XML format.\n\nConsider all uninitialized variables contain garbage values. Ensure that the invariants and function contracts are specified in such a way that the program is verified successfully.\nLet's think step by step."
            },
            "First, let's analyze the Function_main and Function_mp_add, and identify their arguments and return values.\n\nFunction_main has no arguments and has a return value of type int (0).\n\nFunction_mp_add has two arguments, a and b, both of type unsigned int, and has a return value of type unsigned int (r).\n\nNow let's analyze the two loops in the program.\n\nLoop_A has a loop condition ((i < na) || (i < nb) || (carry != (unsigned short)0)), and the loop variable i is incremented by 1 in each iteration.\n\nLoop_B has a loop condition (i < (unsigned char)4), and the loop variable i is incremented by 1 in each iteration.\n\nConsidering these observations, we can write the loop invariants and function contracts as follows:\n\n```\n/*@\n    <Function_main> \n        requires \\true;\n        ensures \\result == 0;\n    </Function_main>\n\n    <Function_mp_add> \n        requires \\true;\n        ensures \\result == \\at(a, Pre) + \\at(b, Pre);\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/\n```",
            "```\n/*@\n    <Function_mp_add> \n        requires a <= 0xFFFFFFFF;\n        requires b <= 0xFFFFFFFF;\n        ensures \\result <= 0xFFFFFFFF;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum <= 511;\n        loop invariant r0 <= 255;\n        loop invariant r1 <= 255;\n        loop invariant r2 <= 255;\n        loop invariant r3 <= 255;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i <= 4;\n    </Loop_B>\n*/\n```",
            "First, we can analyze the Function_mp_add and write a function contract for it.\n- The function takes two unsigned integers a and b as input.\n- It returns the sum of a and b as an unsigned integer.\n\nNow, we can analyze the loops in the program and write loop invariants for them.\n- Loop_A iterates while i is less than na or nb or carry is not equal to 0.\n- Loop_B iterates while i is less than 4.\n\nHere are the loop invariants and function contracts for the given program:\n\n```\n/*@\n    <Function_mp_add> \n        requires a >= 0 && b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0;\n        loop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) - (carry << (8 * i));\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 4 <= i <= 4;\n        loop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre);\n    </Loop_B>\n*/\n```",
            "First, let's analyze the function contracts.\n\nFunction_mp_add:\n- Arguments: unsigned int a, unsigned int b\n- Return value: unsigned int r\n\nFunction_main:\n- Arguments: none\n- Return value: int (0)\n\nNow, let's analyze the loop conditions and find the loop invariants.\n\nLoop_A:\n- Loop condition: (i < na) || (i < nb) || (carry != (unsigned short)0)\n- Loop invariant candidates: i is within the bounds [0, 4], partial_sum is within the bounds [0, 255 + carry]\n\nLoop_B:\n- Loop condition: i < (unsigned char)4\n- Loop invariant candidates: i is within the bounds [0, 4]\n\nNow, let's write the loop invariants and function contracts using ACSL syntax in XML format.\n\n```\n/*@\n    <Function_mp_add>\n        requires a >= 0 && a <= 0xFFFFFFFF;\n        requires b >= 0 && b <= 0xFFFFFFFF;\n        ensures \\result >= 0 && \\result <= 0xFFFFFFFF;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main>\n        ensures \\result == 0;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant i >= 0 && i <= 4;\n        loop invariant partial_sum >= 0 && partial_sum <= 255 + carry;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i >= 0 && i <= 4;\n    </Loop_B>\n*/\n```",
            "First, let's find the function contracts for Function_mp_add and Function_main.\n\nFor Function_mp_add:\n- Arguments: unsigned int a, unsigned int b\n- Return value: unsigned int r\n\nFor Function_main:\n- Arguments: none\n- Return value: int (0)\n\nNow, let's analyze the loop invariants for Loop_A and Loop_B.\n\nFor Loop_A:\n- Pre-conditions: carry = 0, i = 0\n- Loop condition: (i < na) || (i < nb) || (carry != 0)\n\nFor Loop_B:\n- Pre-conditions: i set from Loop_A\n- Loop condition: i < 4\n\nNow, we can write the loop invariants and function contracts:\n\n```\n/*@\n    <Function_mp_add> \n        requires a >= 0 && b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main> \n        requires 1;\n        ensures \\result == 0;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/\n```"
        ],
        "annotation_blocks": [
            "/*@\n    <Function_main> \n        requires \\true;\n        ensures \\result == 0;\n    </Function_main>\n\n    <Function_mp_add> \n        requires \\true;\n        ensures \\result == \\at(a, Pre) + \\at(b, Pre);\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires a <= 0xFFFFFFFF;\n        requires b <= 0xFFFFFFFF;\n        ensures \\result <= 0xFFFFFFFF;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum <= 511;\n        loop invariant r0 <= 255;\n        loop invariant r1 <= 255;\n        loop invariant r2 <= 255;\n        loop invariant r3 <= 255;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i <= 4;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires a >= 0 && b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0;\n        loop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) - (carry << (8 * i));\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 4 <= i <= 4;\n        loop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre);\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add>\n        requires a >= 0 && a <= 0xFFFFFFFF;\n        requires b >= 0 && b <= 0xFFFFFFFF;\n        ensures \\result >= 0 && \\result <= 0xFFFFFFFF;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main>\n        ensures \\result == 0;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant i >= 0 && i <= 4;\n        loop invariant partial_sum >= 0 && partial_sum <= 255 + carry;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i >= 0 && i <= 4;\n    </Loop_B>\n*/",
            "/*@\n    <Function_mp_add> \n        requires a >= 0 && b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main> \n        requires 1;\n        ensures \\result == 0;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/"
        ],
        "completions": [
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_main> \n        requires \\true;\n        ensures \\result == 0;\n    </Function_main>\n\n    <Function_mp_add> \n        requires \\true;\n        ensures \\result == \\at(a, Pre) + \\at(b, Pre);\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 0 <= i <= 4 is inductive.\nloop invariant 0 <= i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nAssertion r == a + b: Valid\nPre-condition \\true on line 10: Valid\nPost-condition \\result == \\at(a,Pre) + \\at(b,Pre) on line 12: Unknown\nPre-condition \\true on line 115: Valid\nPost-condition \\result == 0 on line 117: Valid"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_mp_add> \n        requires a <= 0xFFFFFFFF;\n        requires b <= 0xFFFFFFFF;\n        ensures \\result <= 0xFFFFFFFF;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum <= 511;\n        loop invariant r0 <= 255;\n        loop invariant r1 <= 255;\n        loop invariant r2 <= 255;\n        loop invariant r3 <= 255;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant i <= 4 is inductive.\nloop invariant i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant partial_sum <= 511 is preserved but not established.\nloop invariant r0 <= 255 is inductive.\nloop invariant r1 <= 255 is inductive.\nloop invariant r2 <= 255 is inductive.\nloop invariant r3 <= 255 is inductive.\nAssertion r == a + b: Valid\nPre-condition a <= 0xFFFFFFFF on line 10: Valid\nPre-condition b <= 0xFFFFFFFF on line 11: Valid\nPost-condition \\result <= 0xFFFFFFFF on line 13: Unknown\nPost-condition \\result == \\old(a) + \\old(b) on line 14: Unknown"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_mp_add> \n        requires a >= 0 && b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n        loop invariant partial_sum >= 0;\n        loop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) - (carry << (8 * i));\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 4 <= i <= 4;\n        loop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre);\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 4 <= i <= 4 is preserved but not established.\nloop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) is inductive.\nloop invariant 0 <= i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant partial_sum >= 0 is inductive.\nloop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) - (carry << (8 * i)) is neither established nor preserved.\nAssertion r == a + b: Valid\nPre-condition a >= 0 && b >= 0 on line 10: Valid\nPost-condition \\result == \\old(a) + \\old(b) on line 12: Unknown"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_mp_add>\n        requires a >= 0 && a <= 0xFFFFFFFF;\n        requires b >= 0 && b <= 0xFFFFFFFF;\n        ensures \\result >= 0 && \\result <= 0xFFFFFFFF;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main>\n        ensures \\result == 0;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant i >= 0 && i <= 4;\n        loop invariant partial_sum >= 0 && partial_sum <= 255 + carry;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant i >= 0 && i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant i >= 0 && i <= 4 is inductive.\nloop invariant i >= 0 && i <= 4 is established but not preserved.\nloop invariant partial_sum >= 0 && partial_sum <= 255 + carry is neither established nor preserved.\nAssertion r == a + b: Valid\nPre-condition a >= 0 && a <= 0xFFFFFFFF on line 10: Valid\nPre-condition b >= 0 && b <= 0xFFFFFFFF on line 11: Valid\nPost-condition \\result >= 0 && \\result <= 0xFFFFFFFF on line 13: Unknown\nPost-condition \\result == \\old(a) + \\old(b) on line 14: Unknown\nPre-condition \\true on line 117: Valid\nPost-condition \\result == 0 on line 119: Valid"
            },
            {
                "num_solver_calls": 1,
                "annotations": "/*@\n    <Function_mp_add> \n        requires a >= 0 && b >= 0;\n        ensures \\result == a + b;\n    </Function_mp_add>\n\n    <Function_main> \n        requires 1;\n        ensures \\result == 0;\n    </Function_main>\n\n    <Loop_A>\n        loop invariant 0 <= i <= 4;\n        loop invariant carry == 0 || carry == 1;\n    </Loop_A>\n\n    <Loop_B>\n        loop invariant 0 <= i <= 4;\n    </Loop_B>\n*/",
                "checker_output_for_annotations": true,
                "checker_message_for_annotations": "loop invariant 0 <= i <= 4 is inductive.\nloop invariant 0 <= i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nAssertion r == a + b: Valid\nPre-condition a >= 0 && b >= 0 on line 10: Valid\nPost-condition \\result == \\old(a) + \\old(b) on line 12: Unknown\nPre-condition \\true on line 115: Valid\nPost-condition \\result == 0 on line 117: Valid"
            }
        ],
        "checker_output_for_combined_annotations": true,
        "checker_message_for_combined_annotations": "loop invariant 0 <= i <= 4 is inductive.\nloop invariant 0 <= i <= 4 is established but not preserved.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant i <= 4 is inductive.\nloop invariant i <= 4 is inductive.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant partial_sum <= 511 is preserved but not established.\nloop invariant r0 <= 255 is inductive.\nloop invariant r1 <= 255 is inductive.\nloop invariant r2 <= 255 is inductive.\nloop invariant r3 <= 255 is inductive.\nloop invariant 4 <= i <= 4 is preserved but not established.\nloop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) is inductive.\nloop invariant 0 <= i <= 4 is inductive.\nloop invariant carry == 0 || carry == 1 is inductive.\nloop invariant partial_sum >= 0 is inductive.\nloop invariant r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) - (carry << (8 * i)) is neither established nor preserved.\nloop invariant i >= 0 && i <= 4 is inductive.\nloop invariant i >= 0 && i <= 4 is inductive.\nloop invariant partial_sum >= 0 && partial_sum <= 255 + carry is preserved but not established.\nloop invariant 0 <= i <= 4 is inductive.\nloop invariant 0 <= i <= 4 is inductive.\nloop invariant carry == 0 || carry == 1 is inductive.\nAssertion r == a + b: Valid\nPre-condition a >= 0 && b >= 0 on line 10: Valid\nPre-condition a >= 0 && a <= 0xFFFFFFFF on line 11: Valid\nPre-condition b >= 0 && b <= 0xFFFFFFFF on line 12: Valid\nPre-condition a >= 0 && b >= 0 on line 13: Valid\nPre-condition a <= 0xFFFFFFFF on line 14: Valid\nPre-condition b <= 0xFFFFFFFF on line 15: Valid\nPre-condition \\true on line 16: Valid\nPost-condition \\result == \\at(a,Pre) + \\at(b,Pre) on line 18: Unknown\nPost-condition \\result <= 0xFFFFFFFF on line 19: Unknown\nPost-condition \\result == \\old(a) + \\old(b) on line 20: Unknown\nPost-condition \\result == \\old(a) + \\old(b) on line 21: Unknown\nPost-condition \\result >= 0 && \\result <= 0xFFFFFFFF on line 22: Unknown\nPost-condition \\result == \\old(a) + \\old(b) on line 23: Unknown\nPost-condition \\result == \\old(a) + \\old(b) on line 24: Unknown\nPre-condition \\true on line 147: Valid\nPre-condition \\true on line 148: Valid\nPre-condition \\true on line 149: Valid\nPost-condition \\result == 0 on line 151: Valid\nPost-condition \\result == 0 on line 152: Valid\nPost-condition \\result == 0 on line 153: Valid",
        "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern unsigned int unknown_uint(void);\n\n#include <assert.h>\n\n#include <assert.h>\n\n\n/*@\nrequires a >= 0 && b >= 0;\nrequires a >= 0 && a <= 0xFFFFFFFF;\nrequires b >= 0 && b <= 0xFFFFFFFF;\nrequires a >= 0 && b >= 0;\nrequires a <= 0xFFFFFFFF;\nrequires b <= 0xFFFFFFFF;\nrequires \\true;\n\nensures \\result == \\at(a, Pre) + \\at(b, Pre);\nensures \\result <= 0xFFFFFFFF;\nensures \\result == a + b;\nensures \\result == a + b;\nensures \\result >= 0 && \\result <= 0xFFFFFFFF;\nensures \\result == a + b;\nensures \\result == a + b;\n*/\n\nunsigned int mp_add(unsigned int a, unsigned int b)\n{\n    unsigned char a0, a1, a2, a3;\n    unsigned char b0, b1, b2, b3;\n    unsigned char r0, r1, r2, r3;\n\n    unsigned short carry;\n    unsigned short partial_sum;\n    unsigned int r;\n    unsigned char i;\n    unsigned char na, nb;\n\n    a0 = a;\n    a1 = a >> 8;\n    a2 = a >> 16U;\n    a3 = a >> 24U;\n\n    b0 = b;\n    b1 = b >> 8U;\n    b2 = b >> 16U;\n    b3 = b >> 24U;\n\n    na = (unsigned char)4; \n    if (a3 == (unsigned char)0) {\n        na = na - 1;\n        if (a2 == (unsigned char)0) {\n            na = na - 1;\n            if (a1 == (unsigned char)0) {\n                na = na - 1;\n            }\n        }\n    }\n\n    nb = (unsigned char)4; \n    if (b3 == (unsigned char)0) {\n        nb = nb - 1;\n        if (b2 == (unsigned char)0) {\n            nb = nb - 1;\n            if (b1 == (unsigned char)0) {\n                nb = nb - 1;\n            }\n        }\n    }\n    \n    carry = (unsigned short)0;\n    i = (unsigned char)0;\n    /*@\n\nloop invariant i2: 0 <= i <= 4;\nloop invariant i3: carry == 0 || carry == 1;\nloop invariant i5: i <= 4;\nloop invariant i6: carry == 0 || carry == 1;\nloop invariant i7: partial_sum <= 511;\nloop invariant i8: r0 <= 255;\nloop invariant i9: r1 <= 255;\nloop invariant i10: r2 <= 255;\nloop invariant i11: r3 <= 255;\nloop invariant i14: 0 <= i <= 4;\nloop invariant i15: carry == 0 || carry == 1;\nloop invariant i16: partial_sum >= 0;\nloop invariant i17: r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre) - (carry << (8 * i));\nloop invariant i19: i >= 0 && i <= 4;\nloop invariant i20: partial_sum >= 0 && partial_sum <= 255 + carry;\nloop invariant i22: 0 <= i <= 4;\nloop invariant i23: carry == 0 || carry == 1;\n*/\n  while ((i < na) || (i < nb) || (carry != (unsigned short)0)) {\n        partial_sum = carry;\n        carry = (unsigned short)0;\n\n        if (i < na) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + a0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + a1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + a2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + a3; }\n        }\n        if (i < nb) {\n            if (i == (unsigned char)0) { partial_sum = partial_sum + b0; }\n            if (i == (unsigned char)1) { partial_sum = partial_sum + b1; }\n            if (i == (unsigned char)2) { partial_sum = partial_sum + b2; }\n            if (i == (unsigned char)3) { partial_sum = partial_sum + b3; }\n        }\n        if (partial_sum > ((unsigned char)255)) {\n            partial_sum = partial_sum & ((unsigned char)255);\n            carry = (unsigned short)1;\n        }\n\n        if (i == (unsigned char)0) { r0 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)partial_sum; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)partial_sum; }        \n\n        i = i + (unsigned char)1;\n    }\n\n    /*@\n\nloop invariant i1: 0 <= i <= 4;\nloop invariant i4: i <= 4;\nloop invariant i12: 4 <= i <= 4;\nloop invariant i13: r0 + (r1 << 8U) + (r2 << 16U) + ((unsigned int)r3 << 24U) == \\at(a, Pre) + \\at(b, Pre);\nloop invariant i18: i >= 0 && i <= 4;\nloop invariant i21: 0 <= i <= 4;\n*/\n  while (i < (unsigned char)4) {\n        if (i == (unsigned char)0) { r0 = (unsigned char)0; }\n        if (i == (unsigned char)1) { r1 = (unsigned char)0; }\n        if (i == (unsigned char)2) { r2 = (unsigned char)0; }\n        if (i == (unsigned char)3) { r3 = (unsigned char)0; }\n\n        i = i + (unsigned char)1;\n    }\n\n    r = r0 | (r1 << 8U) | (r2 << 16U) | ((unsigned int)r3 << 24U);\n\n    return r;\n}\n\n\n/*@\nrequires \\true;\nrequires \\true;\nrequires \\true;\n\nensures \\result == 0;\nensures \\result == 0;\nensures \\result == 0;\n*/\n\nint main()\n{\n    unsigned int a, b, r;\n\n    a = unknown_uint();\n    b = 234770789;\n\n    r = mp_add(a, b);\n\n    {;\n//@ assert(r == a + b);\n}\n\n    return 0;\n}"
    },
    "stats": {
        "success": [
            "../data/benchmarks/sv-benchmarks/new-categories/bitvector/byte_add_1-1.c",
            "../data/benchmarks/sv-benchmarks/new-categories/bitvector/byte_add_2-2.c"
        ],
        "failure": [],
        "skipped": [],
        "total": 2,
        "success_count": 2,
        "failure_count": 0,
        "success_rate": 1.0
    }
}