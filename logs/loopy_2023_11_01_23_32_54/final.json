{
    "params": {
        "config_file": "../config/expt2.yaml",
        "local_loopy": false,
        "termination_analysis": false,
        "svcomp_files": false,
        "loop_invariants": true,
        "loopy_prompt": "with_nudges",
        "repair_invariants": false,
        "repair_1": "",
        "repair_2": "",
        "checker": "frama-c",
        "model": "gpt-4",
        "temperature": 0.7,
        "num_completions": 1,
        "benchmark_file": "benchmarks.txt",
        "repair_input": "",
        "recheck_input": "",
        "output_dir": "../logs/loopy_2023_11_01_23_32_54/",
        "repair_input_2": "",
        "repair_retries": 5,
        "repair_from_k": 0,
        "max_benchmarks": 2,
        "start_index": 0,
        "problem_ids": [],
        "provider": "azure-open-ai",
        "benchmark_features": "one_loop_one_method",
        "debug": true,
        "json_output": true,
        "local_llm_output": "",
        "classify": false,
        "ground_truth_file": "",
        "loopy_sequence": false
    },
    "logs": [
        {
            "file": "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c",
            "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  for(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
            "success": false,
            "llm_conversation": [
                {
                    "role": "system",
                    "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
                },
                {
                    "role": "user",
                    "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  for(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
                },
                "Pre-conditions and variable assignments:\n- Variable `n` is assigned a value by the function `unknown_int()`. The exact value is not known, but it's assumed that `n` is less than 1000 and greater than or equal to -1000.\n- Variable `i` is initialized as 1.\n- Variable `sn` is initialized as 0.\n\nLoop:\n- The loop condition is `i <= n`.\n- On each iteration, `sn` is increased by 2 and `i` is increased by 1.\n\nPost-condition:\n- The post-condition asserts that `sn` is either equal to `n*2` or `sn` is 0.\n\nFrom these observations, we can determine the following loop invariants:\n\n```\n/*@ \n    loop invariant i1: 1 <= i <= n+1;\n    loop invariant i2: sn == 2*(i-1);\n    loop invariant i3: n < 1000 && n >= -1000;\n*/\n```\n\nThese invariants hold:\n\n(i) Before the loop execution: `i` is 1, `sn` is 0, and `n` is within the range [-1000, 1000].\n(ii) In every iteration of the loop: `i` is increased by 1, `sn` is increased by 2, and `n` does not change.\n(iii) After the loop termination: `i` is `n+1`, `sn` is `2*n`, and `n` is still within the range [-1000, 1000].\n\nThese loop invariants imply the post condition. If `n` is greater than or equal to 1, then `sn` is `2*n` after the loop. If `n` is less than 1, then the loop does not execute and `sn` remains 0.",
                "Pre-conditions or variable assignments in the program:\n- Variable 'n' is assigned a value from the 'unknown_int' function.\n- The value of 'n' is assumed to be less than 1000 and greater than or equal to -1000.\n- Variable 'sn' is initialized to 0.\n- Variable 'i' is initialized to 1.\n\nLoop condition:\n- The loop executes as long as 'i' is less than or equal to 'n'.\n\nPost-condition:\n- After the loop termination, the value of 'sn' should be equal to 'n*2' or 'sn' should be 0.\n\nLoop Invariants:\n```\n/*@ \n    loop invariant i >= 1;\n    loop invariant i <= n+1;\n    loop invariant sn >= 0;\n    loop invariant sn <= 2*n;\n    loop invariant sn == 2*(i-1);\n*/\n```\nExplanation:\n- The loop invariant 'i >= 1' ensures that 'i' is always greater than or equal to 1.\n- The loop invariant 'i <= n+1' ensures that 'i' is always less than or equal to 'n+1'.\n- The loop invariant 'sn >= 0' ensures that 'sn' is always greater than or equal to 0.\n- The loop invariant 'sn <= 2*n' ensures that 'sn' is always less than or equal to '2*n'.\n- The loop invariant 'sn == 2*(i-1)' ensures that 'sn' is always equal to '2*(i-1)'. This loop invariant is necessary to ensure that the post-condition 'sn == n*2' or 'sn == 0' is met.",
                "Pre-conditions or variable assignments:\n- `i` is an integer variable.\n- `n` is an integer initialized with a value from `unknown_int()`.\n- `sn` is an integer initialized to `0`.\n- We assume `n` is less than `1000` and greater than or equal to `-1000`.\n\nLoop condition:\nThe loop runs while `i` is less than or equal to `n`.\n\nLoop body:\n- `sn` is incremented by `2` in each iteration.\n- `i` is incremented by `1` in each iteration.\n\nPost-condition:\n- `sn` is either equal to `n*2` or `sn` is `0`.\n\nBased on these, the loop invariants are as follows:\n\n```\n//@ loop invariant 1 <= i <= n+1;\n//@ loop invariant sn == 2*(i-1);\n//@ loop invariant (n <= 0) ==> (sn == 0);\n//@ loop invariant (n >= 0) ==> (sn == 2*i);\n``` \n\nHere's why these invariants work:\n- Before the loop begins, `i` is `1` which satisfies the first invariant `1 <= i <= n+1`. The second invariant `sn == 2*(i-1)` also holds since `sn` is `0` at this point. The third and fourth invariants are trivially true because they are implications and their condition part is false. \n- During each iteration, `i` is incremented by `1` and `sn` is incremented by `2` which maintains the first and second invariants. The third and fourth invariants hold depending upon the value of `n`.\n- After the loop terminates, the first invariant `1 <= i <= n+1` ensures that `i` is at most `n+1`. The second invariant `sn == 2*(i-1)` gives us `sn == 2*n`, which is our post-condition. The third and fourth invariants hold depending upon the value of `n`, thus ensuring the post-condition `sn == n*2 || sn == 0`.",
                "Pre-conditions or variable assignments in the program:\n- n is assigned a value from the function unknown_int(). The exact value is not known.\n- sn is initialized to 0.\n- i is not initialized before the loop, but is set to 1 at the start of the loop.\n- The function assume() is used to ensure that n is between -1000 and 1000.\n\nLoop condition and body:\n- The loop runs as long as i is less than or equal to n.\n- In each iteration, sn is increased by 2 and i is incremented by 1.\n\nPost-condition:\n- The assertion checks whether sn is equal to 2*n or sn is equal to 0.\n\nNow let's derive the loop invariants:\n\n1. Before the loop execution, i is set to 1. So, we have the invariant:\n```\n    loop invariant i == 1;\n```\n\n2. In every iteration of the loop, i is incremented by 1 and sn is increased by 2. The value of sn is always 2*(i-1) (since sn starts at 0 and gets incremented by 2 in each iteration). Also, i is always less than or equal to n+1 (since the loop runs as long as i is less than or equal to n). So, we have the invariants:\n```\n    loop invariant sn == 2*(i-1);\n    loop invariant i <= n+1;\n```\n\n3. After the loop termination, i is equal to n+1 (since the loop condition is i <= n). So, we have the invariant:\n```\n    loop invariant i == n+1;\n```\n\n4. The loop invariants imply the post condition since after the loop, sn is equal to 2*n (which is one of the conditions in the post-condition) or sn is equal to 0 (which is the other condition in the post-condition).\n\nSo, we can put all the invariants in one code block:\n```\n/*@ \n    loop invariant i == 1;\n    loop invariant sn == 2*(i-1);\n    loop invariant i <= n+1;\n    loop invariant i == n+1;\n*/\n```",
                "Pre-conditions:\n- The variable `n` is assigned a non-deterministic integer value, but it's bounded by the `assume` statement, which restricts `n` to be less than 1000 and greater than or equal to -1000.\n- The variable `i` is initialized to 1.\n- The variable `sn` is initialized to 0.\n\nLoop condition:\n- The loop executes as long as `i` is less than or equal to `n`.\n\nLoop body:\n- In each iteration, `sn` is incremented by 2 and `i` is incremented by 1.\n\nPost-condition:\n- The assertion after the loop states that `sn` should be equal to `n * 2` or `sn` should be 0.\n\nBased on the above observations, the loop invariants that hold true before, during, and after the loop execution are as follows:\n\n```\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant sn >= 0;\n    loop invariant n >= -1000 && n < 1000;\n*/\n```",
                "1. Pre-conditions or variable assignments in the program: \n```\nint i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n```\nThe variable `n` is initialized with an unknown integer value but we assume that it is between -1000 and 1000 (inclusive). The variable `sn` is initialized as 0.\n\n2. Loop condition: \n```\nfor(i=1; i<=n; i++)\n```\nThe loop runs while `i` is less than or equal to `n`, starting from `i=1`. `i` is incremented by 1 in each iteration.\n\n3. The loop body:\n```\nsn = sn +(2);\n```\nIn each iteration, `sn` is incremented by 2.\n\n4. Post-condition:\n```\n//@ assert(sn==n*(2)|| sn == 0);\n```\nThe post-condition asserts that `sn` is equal to `n` multiplied by 2 or `sn` is 0.\n\nNow, let's generate the loop invariants:\n\n```\n/*@\n  loop invariant 1 <= i && i <= n+1;\n  loop invariant sn == 2*(i-1);\n  loop invariant n < 1000 && n >= -1000;\n*/\n```\n\n1. `1 <= i && i <= n+1`: This invariant states that `i` is always between 1 and `n+1`. This is true before the loop (when `i` is initialized to 1), during the loop (since `i` is incremented by 1 in each iteration until it reaches `n+1`), and after the loop (when `i` is `n+1`).\n\n2. `sn == 2*(i-1)`: This invariant states that `sn` is always equal to `2` multiplied by `(i-1)`. This is true before the loop (when `sn` and `i` are initialized to 0 and 1 respectively), during the loop (since `sn` is incremented by `2` in each iteration while `i` is incremented by 1), and after the loop (when `sn` equals `2n` and `i` equals `n+1`).\n\n3. `n < 1000 && n >= -1000`: This invariant states the assumption we made about `n`, which doesn't change during the loop. \n\nThese invariants are true before the loop execution, in every iteration of the loop, and after the loop termination, and they imply the post condition. The post-condition `sn==n*(2)|| sn == 0` is satisfied when `i=n+1` or `n=-1000` respectively.",
                "- Pre-conditions or variable assignments in the program: `n` is an integer that is less than 1000 and greater than or equal to -1000. The variables `i` and `sn` are initialized as 0.\n- The loop condition is `i<=n`, and the loop increments `sn` by 2 in every iteration, and increments `i` by 1.\n\nThe loop invariants that hold before the loop execution, during every iteration of the loop, and after the loop termination are:\n```\n/*@ \n    loop invariant 0 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant n < 1000 && n >= -1000;\n*/\n```\n\nThe loop invariant `0 <= i <= n+1` ensures that `i` is always within the range [0, n+1], which is the range of values that `i` can take as per the loop condition.\n\nThe loop invariant `sn == 2*(i-1)` ensures that `sn` is always twice the value of `i-1`, which is true because `sn` is incremented by 2 in every iteration of the loop and `i` is incremented by 1.\n\nThe loop invariant `n < 1000 && n >= -1000` is a pre-condition that is assumed at the start of the program.\n\nThese loop invariants help Frama-C to verify the post-condition `sn==n*(2) || sn == 0`.",
                "The variable `i` is initialized to 1, `n` is assigned a value from the function `unknown_int()`, and `sn` is initialized to 0. The pre-condition `assume(n < 1000 && n >= -1000)` is given.\n\nThe loop condition is `i<=n`.\n\nThe loop body increments `i` by 1 and `sn` by 2 in each iteration.\n\nWe can derive the following loop invariants:\n- `i` is always greater than 0 and less than or equal to `n+1`.\n- `n` stays within the bounds -1000 and 1000 throughout the loop.\n- `sn` is always greater than or equal to 0 and less than or equal to `2*n`.\n\nThe post-condition of the program is `sn==n*(2)|| sn == 0`. \n\nHere are the loop invariants for the loop in the program:\n\n```c\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant -1000 <= n <= 1000;\n    loop invariant 0 <= sn <= 2*n;\n    loop assigns i, sn;\n    loop variant n - i;\n*/\n```",
                "Pre-conditions or variable assignments in the program:\n- The variable `n` is assigned a value from the function `unknown_int()`.\n- The variable `i` is declared but not initialized.\n- The variable `sn` is initialized to `0`.\n- The function `assume(e)` ensures that `n` is less than `1000` and greater than or equal to `-1000`.\n\nLoop condition:\n- The loop executes while `i` is less than or equal to `n`.\n\nLoop invariants:\n\nBefore loop execution:\n- `i` is equal to `1`.\n- `sn` is equal to `0`.\n\nIn every iteration of the loop:\n- `i` is always greater than or equal to `1` and less than or equal to `n+1`.\n- `sn` is always equal to `2 * (i-1)`.\n\nAfter loop termination:\n- `i` is equal to `n+1`.\n- `sn` is equal to `2 * n` if `n` is greater than or equal to `1`, and `sn` is equal to `0` if `n` is less than `1`.\n\nPost-condition:\n- `sn` is equal to `2 * n` or `sn` is equal to `0`.\n\nThe loop invariants that need to be added are:\n\n```\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0);\n*/\n```",
                "First, let's make a note of the pre-conditions or variable assignments in the program.\n- The variable `n` is assigned a value by a call to `unknown_int()` function. We don't know exactly what this value is, but it is constrained by the `assume` statement to be less than 1000 and greater than or equal to -1000.\n- The variable `i` is assigned the value 1 before the loop begins.\n- The variable `sn` is initialized to 0 before the loop begins.\n\nNext, let's analyze the loop body and make a note of the loop condition.\n- The loop condition is `i <= n`.\n- Inside the loop, `sn` is incremented by 2 in each iteration, and `i` is incremented by 1.\n\nBased on this information, we can identify the following loop invariants:\n\n```\n/*@\n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant sn == 2*(i-1);\n*/\n```\n\nThese invariants are true before the loop begins (when `i` is 1 and `sn` is 0), during every iteration of the loop (as `i` and `sn` are incremented), and after the loop terminates (when `i` is `n+1` and `sn` is `2*n`). These invariants imply the post condition: `sn == 2*n || sn == 0`. \n\nNote that the third invariant uses an implication to handle the case when `n` is less than 1, in which case the loop is not executed and `sn` remains 0.",
                "- Before the loop begins, the variable `i` is set to 1, `n` is assigned a non-deterministic value that is less than 1000 and greater than or equal to -1000, and `sn` is initialized to 0.\n- The loop condition is `i <= n`.\n- In each iteration of the loop, `sn` is increased by 2 and `i` is incremented by 1.\n- The post-condition is that `sn` is equal to `2 * n` or `sn` is 0.\n\nFrom these observations, we can deduce the following loop invariants:\n\n- `i` is always less than or equal to `n + 1`.\n- `sn` is always less than or equal to `2 * n`.\n- `sn` is always equal to `2 * (i - 1)`.\n- If `n` is less than 1, `sn` is 0.\n\nHere are the loop invariants in ACSL:\n\n```\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2 * n;\n    loop invariant sn == 2 * (i - 1);\n    loop invariant n < 1 ==> sn == 0;\n*/\n```\nEach of these invariants hold true before the loop, during each iteration, and after the loop ends. The invariants imply the post-condition, thus helping Frama-C verify it.",
                "Before the loop execution, the variables `i` and `sn` are initialized to 1 and 0 respectively. The variable `n` is assigned an unknown integer value and it is assumed that `n` is less than 1000 and greater than or equal to -1000.\n\nThe loop condition is `i<=n`. \n\nThe loop body increments `i` by 1 and `sn` by 2 in each iteration.\n\nThe post-condition assertion is that `sn` is equal to twice `n` or `sn` is 0. This is true when `n` is greater than 0 and when `n` is less than or equal to 0 respectively.\n\nThe loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination are:\n1. `i` is always greater than or equal to 1 and less than or equal to `n`+1. \n2. `sn` is always greater than or equal to 0 and less than or equal to 2*`n`.\n3. `sn` is always equal to 2*(`i`-1) when `i` is less than or equal to `n` and `n` is greater than or equal to 0.\n4. `sn` is always 0 when `n` is less than or equal to 0.\n\nHere are these loop invariants in ACSL:\n```c\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant i <= n ==> sn == 2*(i-1);\n    loop invariant n <= 0 ==> sn == 0;\n*/\n```",
                "Pre-conditions or variable assignments in the program:\n- `n` is assigned an unknown integer value.\n- `sn` is initialized to 0.\n- `i` is not initialized but it is assigned 1 before the loop starts.\n- The program assumes that `n` is less than 1000 and greater than or equal to -1000.\n\nLoop condition:\n- The loop continues as long as `i` is less than or equal to `n`.\n\nNow, let's find the loop invariants:\n\nBefore the loop execution:\n- `i` is equal to 1.\n- `sn` is equal to 0.\n\nIn every iteration of the loop:\n- `sn` is incremented by 2.\n- `i` is incremented by 1.\n- `sn` is always less than or equal to `2*n`.\n- `i` is always less than or equal to `n+1`.\n\nAfter the loop termination:\n- `sn` is equal to `2*n` if `n` is greater than 0.\n- `sn` is equal to 0 if `n` is less than or equal to 0.\n\nSo, the loop invariants are:\n```\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant sn == 2*(i-1) ==> i <= n;\n    loop invariant sn == 2*n ==> i > n;\n*/\n```",
                "Firstly, note the preconditions and initial variable assignments. The variable `n` is assigned a value by an unknown function `unknown_int()`, but it is bounded to be between -1000 and 1000, inclusive. The variable `i` is initialized to 1, and `sn` is initialized to 0.\n\nNext, consider the loop. The loop condition is `i<=n`. The loop body increments `i` by 1 and `sn` by 2 in every iteration.\n\nGiven the post-condition, `sn==n*(2) || sn == 0`, it's clear that the loop is calculating twice the sum of `n` natural numbers if `n` is positive and `sn` remains 0 if `n` is non-positive.\n\nNow, let's consider the loop invariants which are true before the loop execution, in every iteration of the loop, and after the loop termination:\n\n1) `i` is always positive and less than or equal to `n + 1`. This is a direct consequence of the loop condition and the increment operation in the loop body.\n\n2) `sn` is always twice the sum of the first `i - 1` natural numbers if `i > 1`. This is because `sn` is incremented by 2 in each iteration of the loop. If `i <= 1`, `sn` is 0.\n\n3) `sn` is always less than or equal to `2n`. This is a consequence of the fact that `sn` is the sum of twice the first `i - 1` natural numbers, and `i - 1` is always less than or equal to `n`.\n\nPutting these together, the loop invariants are:\n\n```\n/*@ \n    loop invariant 1 <= i <= n + 1;\n    loop invariant sn == 2*(i - 1) ==> i > 1;\n    loop invariant sn == 0 ==> i <= 1;\n    loop invariant 0 <= sn <= 2*n;\n*/\n```",
                "Pre-conditions or variable assignments in the program:\n\n1. `i` is declared but not initialized, so it could contain any value. \n2. `n` is assigned a value through `unknown_int()`, which could be any integer. \n3. `sn` is initialized to 0. \n4. An assumption is made that `n` is less than 1000 and greater than or equal to -1000.\n\nThe loop condition:\n\nThe loop will run as long as `i` is less than or equal to `n`.\n\nThe loop invariants that are true before the loop execution, in every iteration of the loop and after the loop termination, such that the loop invariants imply the post condition are:\n\n```\n/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant n < 1000 && n >= -1000;\n*/\n```\n\nExplanation:\n\n1. `1 <= i <= n+1`: This invariant is always true because `i` is initialized to 1 before the loop and is incremented by 1 during each iteration of the loop. After the loop, `i` will be `n+1`.\n\n2. `sn == 2*(i-1)`: This invariant is always true because `sn` is initialized to 0 before the loop and is incremented by 2 during each iteration of the loop. Thus, `sn` is always equal to 2 times the number of completed loop iterations.\n\n3. `n < 1000 && n >= -1000`: This invariant is always true because it is assumed before the loop and `n` is never changed during or after the loop."
            ],
            "annotation_blocks": [
                "/*@ \n    loop invariant i1: 1 <= i <= n+1;\n    loop invariant i2: sn == 2*(i-1);\n    loop invariant i3: n < 1000 && n >= -1000;\n*/",
                "/*@ \n    loop invariant i >= 1;\n    loop invariant i <= n+1;\n    loop invariant sn >= 0;\n    loop invariant sn <= 2*n;\n    loop invariant sn == 2*(i-1);\n*/",
                "//@ loop invariant 1 <= i <= n+1;\n//@ loop invariant sn == 2*(i-1);\n//@ loop invariant (n <= 0) ==> (sn == 0);\n//@ loop invariant (n >= 0) ==> (sn == 2*i);",
                "    loop invariant i == 1;",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant sn >= 0;\n    loop invariant n >= -1000 && n < 1000;\n*/",
                "/*@\n  loop invariant 1 <= i && i <= n+1;\n  loop invariant sn == 2*(i-1);\n  loop invariant n < 1000 && n >= -1000;\n*/",
                "/*@ \n    loop invariant 0 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant n < 1000 && n >= -1000;\n*/",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant -1000 <= n <= 1000;\n    loop invariant 0 <= sn <= 2*n;\n    loop assigns i, sn;\n    loop variant n - i;\n*/",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0);\n*/",
                "/*@\n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant sn == 2*(i-1);\n*/",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2 * n;\n    loop invariant sn == 2 * (i - 1);\n    loop invariant n < 1 ==> sn == 0;\n*/",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant i <= n ==> sn == 2*(i-1);\n    loop invariant n <= 0 ==> sn == 0;\n*/",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant sn == 2*(i-1) ==> i <= n;\n    loop invariant sn == 2*n ==> i > n;\n*/",
                "/*@ \n    loop invariant 1 <= i <= n + 1;\n    loop invariant sn == 2*(i - 1) ==> i > 1;\n    loop invariant sn == 0 ==> i <= 1;\n    loop invariant 0 <= sn <= 2*n;\n*/",
                "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant n < 1000 && n >= -1000;\n*/"
            ],
            "completions": [
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@ \n    loop invariant i1: 1 <= i <= n+1;\n    loop invariant i2: sn == 2*(i-1);\n    loop invariant i3: n < 1000 && n >= -1000;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n < 1000 && n >= -1000 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: n < 1000 && n >= -1000;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 4,
                    "annotations": "/*@ \n    loop invariant i >= 1;\n    loop invariant i <= n+1;\n    loop invariant sn >= 0;\n    loop invariant sn <= 2*n;\n    loop invariant sn == 2*(i-1);\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant i >= 1 is partially proven to be inductive.\nloop invariant i <= n+1 is preserved but not established.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant sn <= 2*n is partially proven to be inductive.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\nloop invariant i1: i >= 1;\n\nloop invariant i3: sn >= 0;\n\nloop invariant i5: sn == 2*(i-1);\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "//@ loop invariant 1 <= i <= n+1;\n//@ loop invariant sn == 2*(i-1);\n//@ loop invariant (n <= 0) ==> (sn == 0);\n//@ loop invariant (n >= 0) ==> (sn == 2*i);",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant (n <= 0) ==> (sn == 0) is partially proven to be inductive.\nloop invariant (n >= 0) ==> (sn == 2*i) is preserved but not established.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: (n <= 0) ==> (sn == 0);\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 2,
                    "annotations": "    loop invariant i == 1;",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant i == 1 is established but not preserved.\nAssertion sn == n * 2 || sn == 0: Unproven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant sn >= 0;\n    loop invariant n >= -1000 && n < 1000;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant n >= -1000 && n < 1000 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: sn >= 0;\nloop invariant i4: n >= -1000 && n < 1000;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@\n  loop invariant 1 <= i && i <= n+1;\n  loop invariant sn == 2*(i-1);\n  loop invariant n < 1000 && n >= -1000;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i && i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n < 1000 && n >= -1000 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: n < 1000 && n >= -1000;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@ \n    loop invariant 0 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant n < 1000 && n >= -1000;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 0 <= i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n < 1000 && n >= -1000 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: n < 1000 && n >= -1000;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant -1000 <= n <= 1000;\n    loop invariant 0 <= sn <= 2*n;\n    loop assigns i, sn;\n    loop variant n - i;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant -1000 <= n <= 1000 is partially proven to be inductive.\nloop invariant 0 <= sn <= 2*n is established but not preserved.\nAssertion sn == n * 2 || sn == 0: Unproven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: -1000 <= n <= 1000;\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0);\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0) is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 4,
                    "annotations": "/*@\n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant sn == 2*(i-1);\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant 0 <= sn <= 2*n is partially proven to be inductive.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n\nloop invariant i3: sn == 2*(i-1);\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 4,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2 * n;\n    loop invariant sn == 2 * (i - 1);\n    loop invariant n < 1 ==> sn == 0;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant 0 <= sn <= 2 * n is partially proven to be inductive.\nloop invariant sn == 2 * (i - 1) is partially proven to be inductive.\nloop invariant n < 1 ==> sn == 0 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n\nloop invariant i3: sn == 2 * (i - 1);\nloop invariant i4: n < 1 ==> sn == 0;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 4,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant i <= n ==> sn == 2*(i-1);\n    loop invariant n <= 0 ==> sn == 0;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant 0 <= sn <= 2*n is partially proven to be inductive.\nloop invariant i <= n ==> sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n <= 0 ==> sn == 0 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Unproven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n\nloop invariant i3: i <= n ==> sn == 2*(i-1);\nloop invariant i4: n <= 0 ==> sn == 0;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 2,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant 0 <= sn <= 2*n;\n    loop invariant sn == 2*(i-1) ==> i <= n;\n    loop invariant sn == 2*n ==> i > n;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant 0 <= sn <= 2*n is established but not preserved.\nloop invariant sn == 2*(i-1) ==> i <= n is neither established nor preserved.\nloop invariant sn == 2*n ==> i > n is established but not preserved.\nAssertion sn == n * 2 || sn == 0: Unproven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n\n\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 4,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n + 1;\n    loop invariant sn == 2*(i - 1) ==> i > 1;\n    loop invariant sn == 0 ==> i <= 1;\n    loop invariant 0 <= sn <= 2*n;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n + 1 is preserved but not established.\nloop invariant sn == 2*(i - 1) ==> i > 1 is preserved but not established.\nloop invariant sn == 0 ==> i <= 1 is partially proven to be inductive.\nloop invariant 0 <= sn <= 2*n is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\n\n\n\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                },
                {
                    "num_solver_calls": 3,
                    "annotations": "/*@ \n    loop invariant 1 <= i <= n+1;\n    loop invariant sn == 2*(i-1);\n    loop invariant n < 1000 && n >= -1000;\n*/",
                    "checker_output_for_annotations": false,
                    "checker_message_for_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n < 1000 && n >= -1000 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
                    "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: n < 1000 && n >= -1000;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
                    "checker_output_after_prune": false
                }
            ],
            "checker_output_for_combined_annotations": false,
            "checker_message_for_combined_annotations": "loop invariant 1 <= i <= n+1 is preserved but not established.\nloop invariant sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n < 1000 && n >= -1000 is partially proven to be inductive.\nloop invariant i >= 1 is partially proven to be inductive.\nloop invariant i <= n+1 is partially proven to be inductive.\nloop invariant sn >= 0 is partially proven to be inductive.\nloop invariant sn <= 2*n is partially proven to be inductive.\nloop invariant (n <= 0) ==> (sn == 0) is partially proven to be inductive.\nloop invariant (n >= 0) ==> (sn == 2*i) is preserved but not established.\nloop invariant i == 1 is partially proven to be inductive.\nloop invariant n >= -1000 && n < 1000 is partially proven to be inductive.\nloop invariant 1 <= i && i <= n+1 is partially proven to be inductive.\nloop invariant 0 <= i <= n+1 is partially proven to be inductive.\nloop invariant -1000 <= n <= 1000 is partially proven to be inductive.\nloop invariant 0 <= sn <= 2*n is partially proven to be inductive.\nloop invariant (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0) is partially proven to be inductive.\nloop invariant 0 <= sn <= 2 * n is partially proven to be inductive.\nloop invariant sn == 2 * (i - 1) is partially proven to be inductive.\nloop invariant n < 1 ==> sn == 0 is partially proven to be inductive.\nloop invariant i <= n ==> sn == 2*(i-1) is partially proven to be inductive.\nloop invariant n <= 0 ==> sn == 0 is partially proven to be inductive.\nloop invariant sn == 2*(i-1) ==> i <= n is partially proven to be inductive.\nloop invariant sn == 2*n ==> i > n is partially proven to be inductive.\nloop invariant 1 <= i <= n + 1 is partially proven to be inductive.\nloop invariant sn == 2*(i - 1) ==> i > 1 is partially proven to be inductive.\nloop invariant sn == 0 ==> i <= 1 is partially proven to be inductive.\nAssertion sn == n * 2 || sn == 0: Partially proven",
            "code_with_combined_annotations": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\nloop invariant i1: 1 <= i <= n+1;\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: n < 1000 && n >= -1000;\nloop invariant i4: i >= 1;\nloop invariant i5: i <= n+1;\nloop invariant i6: sn >= 0;\nloop invariant i7: sn <= 2*n;\nloop invariant i8: (n <= 0) ==> (sn == 0);\nloop invariant i9: (n >= 0) ==> (sn == 2*i);\nloop invariant i10: i == 1;\nloop invariant i11: n >= -1000 && n < 1000;\nloop invariant i12: 1 <= i && i <= n+1;\nloop invariant i13: 0 <= i <= n+1;\nloop invariant i14: -1000 <= n <= 1000;\nloop invariant i15: 0 <= sn <= 2*n;\nloop invariant i16: (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0);\nloop invariant i17: 0 <= sn <= 2 * n;\nloop invariant i18: sn == 2 * (i - 1);\nloop invariant i19: n < 1 ==> sn == 0;\nloop invariant i20: i <= n ==> sn == 2*(i-1);\nloop invariant i21: n <= 0 ==> sn == 0;\nloop invariant i22: sn == 2*(i-1) ==> i <= n;\nloop invariant i23: sn == 2*n ==> i > n;\nloop invariant i24: 1 <= i <= n + 1;\nloop invariant i25: sn == 2*(i - 1) ==> i > 1;\nloop invariant i26: sn == 0 ==> i <= 1;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
            "combined_annotation_num_solver_calls": 10,
            "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown_int(void);\n\nint main(){\n  int i, n=unknown_int(), sn=0;\nassume(n < 1000 && n >= -1000);\n  /*@\n\nloop invariant i2: sn == 2*(i-1);\nloop invariant i3: n < 1000 && n >= -1000;\nloop invariant i4: i >= 1;\n\nloop invariant i6: sn >= 0;\n\nloop invariant i8: (n <= 0) ==> (sn == 0);\n\n\nloop invariant i11: n >= -1000 && n < 1000;\n\n\nloop invariant i14: -1000 <= n <= 1000;\n\nloop invariant i16: (n >= 1 ==> sn == 2 * (i-1)) && (n < 1 ==> sn == 0);\n\nloop invariant i18: sn == 2 * (i - 1);\nloop invariant i19: n < 1 ==> sn == 0;\nloop invariant i20: i <= n ==> sn == 2*(i-1);\nloop invariant i21: n <= 0 ==> sn == 0;\n\nloop invariant i23: sn == 2*n ==> i > n;\n\n\nloop invariant i26: sn == 0 ==> i <= 1;\n*/\nfor(i=1; i<=n; i++){\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==n*(2)|| sn == 0);\n}\n\n}",
            "checker_output_after_prune": false
        }
    ],
    "stats": {
        "success": [],
        "failure": [
            "../data/benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum01_true-unreach-call_true-termination.i.annot.c"
        ],
        "skipped": [],
        "total": 1,
        "success_count": 0,
        "failure_count": 1,
        "success_rate": 0.0
    }
}