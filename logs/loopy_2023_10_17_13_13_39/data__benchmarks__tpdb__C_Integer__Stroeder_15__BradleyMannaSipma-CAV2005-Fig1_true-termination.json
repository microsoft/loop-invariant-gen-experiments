{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \twhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
        "success": true,
        "log": [
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_invariants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
                    },
                    {
                        "role": "user",
                        "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \twhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note the pre-conditions and variable assignments in the program:\n\n1. y1 and y2 are assigned non-deterministic integer values.\n2. The loop executes only if y1 > 0 and y2 > 0.\n\nNow, let's analyze the loop body and make a note of the loop condition:\n\n1. The loop condition is y1 != y2.\n2. Inside the loop, y1 is decremented by y2 if y1 > y2, otherwise y2 is decremented by y1.\n\nNow we can find the necessary loop invariants for the while loop:\n\n```\n/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant y1 > 0 ==> y2 > 0;\n*/\n```",
                    "First, let's analyze the given program:\n\nPre-conditions / variable assignments:\n1. y1 and y2 are assigned unknown integers.\n2. The loop only executes if y1 > 0 and y2 > 0.\n\nLoop condition:\nThe loop executes as long as y1 != y2.\n\nNow, let's find the loop invariants:\n\n1. Both y1 and y2 are always positive during the loop execution.\n2. During the loop execution, y1 and y2 always have the same initial values modulo their initial difference.\n3. At the end of the loop, y1 is equal to y2.\n\nThe loop invariants for the while loop are as follows:\n\n```\n/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant (y1 - y2) % (y1 + y2) == 0;\n*/\n```",
                    "First, let's make a note of the pre-conditions or variable assignments in the program:\n- y1 and y2 are assigned non-deterministic integer values.\n- The loop executes only if y1 > 0 and y2 > 0.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is y1 != y2.\n- If y1 > y2, y1 is updated to y1 - y2.\n- If y1 <= y2, y2 is updated to y2 - y1.\n\nNow, let's output the loop invariants for the loop:\n\n```\n/*@\n    loop invariant y1 > 0 && y2 > 0;\n    loop invariant \\abs(y1 - y2) <= \\max(y1, y2);\n    loop invariant (y1_initial == y1 && y2_initial == y2) ==> y1 != y2;\n*/\n```\n\nThese loop invariants are true:\n- Before the loop execution: y1 and y2 are positive, and the absolute difference between them is less than or equal to their maximum.\n- In every iteration of the loop: y1 and y2 remain positive, and the absolute difference between them is still less than or equal to their maximum.\n- After the loop termination: y1 and y2 remain positive, and since the loop condition is y1 != y2, the implication ensures the invariant is trivially true.",
                    "Pre-conditions and variable assignments:\n- y1 and y2 are assigned non-deterministic values.\n- y1 > 0 and y2 > 0\n\nLoop condition:\n- y1 != y2\n\nNow, let's derive the loop invariants:\n\n```\n/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n*/\n```",
                    "First, let's make a note of the pre-conditions or variable assignments in the program:\n- y1 and y2 are initialized with unknown_int() values.\n- The loop starts executing if y1 > 0 and y2 > 0.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is y1 != y2.\n- Inside the loop, if y1 > y2, then y1 is updated to y1 - y2; otherwise, y2 is updated to y2 - y1.\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination:\n\n```\n/*@ \n    loop invariant y1 >= 0 && y2 >= 0;\n    loop invariant y1 + y2 >= 0;\n    loop invariant \\old(y1) > 0 ==> y1 > 0;\n    loop invariant \\old(y2) > 0 ==> y2 > 0;\n*/\n```\n\nThese loop invariants are true:\n- Before the loop execution: y1 and y2 are non-negative and their sum is non-negative.\n- In every iteration of the loop: y1 and y2 remain non-negative, and their sum remains non-negative.\n- After the loop termination: y1 and y2 are still non-negative, and their sum is still non-negative.\n- If y1 and y2 were initially positive, they remain positive throughout the loop execution."
                ],
                "output": [
                    "/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant y1 > 0 ==> y2 > 0;\n*/",
                    "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant (y1 - y2) % (y1 + y2) == 0;\n*/",
                    "/*@\n    loop invariant y1 > 0 && y2 > 0;\n    loop invariant \\abs(y1 - y2) <= \\max(y1, y2);\n    loop invariant (y1_initial == y1 && y2_initial == y2) ==> y1 != y2;\n*/",
                    "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n*/",
                    "/*@ \n    loop invariant y1 >= 0 && y2 >= 0;\n    loop invariant y1 + y2 >= 0;\n    loop invariant \\old(y1) > 0 ==> y1 > 0;\n    loop invariant \\old(y2) > 0 ==> y2 > 0;\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "num_solver_calls": 1,
                        "success": true,
                        "invariants": "/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant y1 > 0 ==> y2 > 0;\n*/",
                        "checker_output_for_invariants": true,
                        "checker_message_for_invariants": "loop invariant y1 >= 0 is inductive.\nloop invariant y2 >= 0 is inductive.\nloop invariant y1 > 0 ==> y2 > 0 is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant (y1 - y2) % (y1 + y2) == 0;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant y1 > 0 is inductive.\nloop invariant y2 > 0 is inductive.\nloop invariant (y1 - y2) % (y1 + y2) == 0 is preserved but not established.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@\n    loop invariant y1 > 0 && y2 > 0;\n    loop invariant \\abs(y1 - y2) <= \\max(y1, y2);\n    loop invariant (y1_initial == y1 && y2_initial == y2) ==> y1 != y2;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "Annotation error on line 15: unbound logic variable y2_initial. Ignoring loop annotation"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": true,
                        "invariants": "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n*/",
                        "checker_output_for_invariants": true,
                        "checker_message_for_invariants": "loop invariant y1 > 0 is inductive.\nloop invariant y2 > 0 is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant y1 >= 0 && y2 >= 0;\n    loop invariant y1 + y2 >= 0;\n    loop invariant \\old(y1) > 0 ==> y1 > 0;\n    loop invariant \\old(y2) > 0 ==> y2 > 0;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "Annotation error on line 15: \\old undefined in this context. Ignoring loop annotation"
                    }
                ],
                "success": true
            },
            {
                "step": "Houdini for individual completion",
                "success": true,
                "completions": [
                    {
                        "num_solver_calls": 0,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant y1 >= 0;\n    loop invariant y2 >= 0;\n    loop invariant y1 > 0 ==> y2 > 0;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n    loop invariant (y1 - y2) % (y1 + y2) == 0;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 > 0;\nloop invariant i2: y2 > 0;\n\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@\n    loop invariant y1 > 0 && y2 > 0;\n    loop invariant \\abs(y1 - y2) <= \\max(y1, y2);\n    loop invariant (y1_initial == y1 && y2_initial == y2) ==> y1 != y2;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 > 0 && y2 > 0;\nloop invariant i2: \\abs(y1 - y2) <= \\max(y1, y2);\n\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 0,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant y1 > 0;\n    loop invariant y2 > 0;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 > 0;\nloop invariant i2: y2 > 0;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 2,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant y1 >= 0 && y2 >= 0;\n    loop invariant y1 + y2 >= 0;\n    loop invariant \\old(y1) > 0 ==> y1 > 0;\n    loop invariant \\old(y2) > 0 ==> y2 > 0;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 >= 0 && y2 >= 0;\nloop invariant i2: y1 + y2 >= 0;\n\n\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    }
                ]
            },
            {
                "step": "Houdini for combined completion",
                "solver_calls": 4,
                "success": true,
                "code_with_combined_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\nloop invariant i4: y1 > 0;\nloop invariant i5: y2 > 0;\n\nloop invariant i7: y1 > 0 && y2 > 0;\nloop invariant i8: \\abs(y1 - y2) <= \\max(y1, y2);\n\nloop invariant i12: y1 >= 0 && y2 >= 0;\nloop invariant i13: y1 + y2 >= 0;\n\n\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                "checker_output": true
            },
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_variants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression  over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\nOutput the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\nIf the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. "
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:  \n```  \n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \twhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program and explain why it is a valid ranking function. Let's think step by step. "
                    },
                    "First, let's identify the loop in the given program:\n\n```\nwhile (y1 != y2) {\n    if (y1 > y2) {\n        y1 = y1 - y2;\n    } else {\n        y2 = y2 - y1;\n    }\n}\n```\n\nNow, let's find the ranking function for this loop. Since the values of y1 and y2 are changing in each iteration, we can use a lexicographic ranking function:\n\n```\n/*@\n    loop variant y1;\n    loop variant y2;\n*/\n```\n\nThis lexicographic ranking function is valid because:\n\n1. The values of y1 and y2 are always positive for the loop to execute, as specified in the precondition (y1 > 0 && y2 > 0).\n\n2. In each iteration of the loop, either y1 decreases (when y1 > y2) or y2 decreases (when y1 < y2). This ensures that the lexicographic ranking function decreases in every iteration.\n\n3. Since y1 and y2 are always positive, and one of them decreases in each iteration, the loop must eventually terminate when y1 and y2 become equal.",
                    "First, let's identify the loop in the given program:\n\n```\nwhile (y1 != y2) {\n    if (y1 > y2) {\n        y1 = y1 - y2;\n    } else {\n        y2 = y2 - y1;\n    }\n}\n```\n\nNow, we need to find a ranking function that decreases with every iteration of the loop and is positive while the loop continues to execute.\n\nWe can use a lexicographic ranking function with two expressions. The first expression will be the absolute difference between y1 and y2, and the second expression will be the sum of y1 and y2.\n\nThe ranking function will look like this:\n\n```\n/*@\n    loop variant abs(y1 - y2);\n    loop variant y1 + y2;\n*/\n```\n\nTo prove that this is a valid ranking function, we need to show that the values of the expressions are positive while the loop continues to execute, and that either the first expression decreases, or if it remains the same, the second expression decreases.\n\n1. Positivity: Since y1 and y2 are both positive integers (as given in the precondition `if (y1 > 0 && y2 > 0)`), their sum (y1 + y2) is always positive. The absolute difference between y1 and y2 (abs(y1 - y2)) is also always non-negative.\n\n2. Decreasing property: In each iteration of the loop, either y1 > y2 or y2 > y1. If y1 > y2, then y1 is updated to y1 - y2, which decreases the absolute difference abs(y1 - y2). If y2 > y1, then y2 is updated to y2 - y1, which also decreases the absolute difference abs(y1 - y2). In both cases, the sum of y1 and y2 also decreases.\n\nThus, the given ranking function is a valid ranking function for the loop in the program.",
                    "First, let's identify the loop and the loop condition:\n\n```c\nwhile (y1 != y2) {\n    ...\n}\n```\n\nThe loop continues to execute as long as `y1` is not equal to `y2`.\n\nNow, let's analyze the loop body:\n\n```c\nif (y1 > y2) {\n    y1 = y1 - y2;\n} else {\n    y2 = y2 - y1;\n}\n```\n\nIn each iteration, either `y1` or `y2` is decreased by the smaller of the two values. This means that the values of `y1` and `y2` are strictly decreasing, but they always remain positive.\n\nTherefore, a valid ranking function for this loop is the sum of `y1` and `y2`. Here's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant y1 + y2;\n*/\n```\n\nThis is a valid ranking function because:\n\n1. The value of the ranking function (`y1 + y2`) is always positive, as both `y1` and `y2` are positive integers.\n2. The value of the ranking function strictly decreases with every iteration, as either `y1` or `y2` is decreased by the smaller of the two values in each iteration.\n3. Since the value of the ranking function is always positive and strictly decreasing, the loop must eventually terminate.",
                    "First, let's analyze the loop and its conditions. The loop executes as long as `y1 != y2`. Inside the loop, if `y1 > y2`, then `y1` is updated to `y1 - y2`. If `y1 <= y2`, then `y2` is updated to `y2 - y1`.\n\nWe can use a lexicographic ranking function with two expressions: the absolute difference between `y1` and `y2`, and the value of `y1`. Here's the ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant abs(y1 - y2);\n    loop variant y1;\n*/\n```\n\nNow, let's explain why this is a valid ranking function:\n\n1. The value of each expression must be positive for the loop to execute. In our case, since `y1 != y2`, the absolute difference `abs(y1 - y2)` is positive. Also, `y1` is positive because it's given by the precondition `y1 > 0`.\n\n2. The lexicographic order states that either the first expression must decrease, or if its value remains the same, the second expression must decrease. In our case, if `y1 > y2`, then `y1` is updated to `y1 - y2`, and the absolute difference decreases. If `y1 <= y2`, then `y2` is updated to `y2 - y1`, and the absolute difference still decreases. In both cases, the first expression in the ranking function decreases, satisfying the lexicographic order.\n\nSince the ranking function satisfies both conditions, it is a valid ranking function that proves the loop must terminate.",
                    "First, let's identify the loop:\n\n```\nwhile (y1 != y2) {\n    if (y1 > y2) {\n        y1 = y1 - y2;\n    } else {\n        y2 = y2 - y1;\n    }\n}\n```\n\nNow, let's find the ranking function. In this case, the ranking function is a lexicographic ranking function with two expressions:\n\n```\n/*@\n    loop variant y1 + y2;\n    loop variant y1;\n*/\n```\n\nExplanation:\n\n1. The sum of y1 and y2 (y1 + y2) is always non-negative since y1 and y2 are both initially positive. And it must decrease in each iteration, as either y1 or y2 is decreased by the value of the other.\n\n2. The value of y1 is the second expression in the lexicographic ranking function. It is also non-negative, and either it decreases (when y1 > y2) or remains the same (when y1 <= y2). If it remains the same, the value of y1 + y2 decreases, as explained above.\n\nThus, this lexicographic ranking function ensures that the loop will terminate, as the values of the expressions decrease with each iteration."
                ],
                "output": [
                    "/*@\n    loop variant y1;\n    loop variant y2;\n*/",
                    "/*@\n    loop variant abs(y1 - y2);\n    loop variant y1 + y2;\n*/",
                    "/*@\n    loop variant y1 + y2;\n*/",
                    "/*@\n    loop variant abs(y1 - y2);\n    loop variant y1;\n*/",
                    "/*@\n    loop variant y1 + y2;\n    loop variant y1;\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t//@ ghost variant_expression measure = { y1, y2 };\n/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\nloop invariant i4: y1 > 0;\nloop invariant i5: y2 > 0;\nloop invariant i7: y1 > 0 && y2 > 0;\nloop invariant i8: \\abs(y1 - y2) <= \\max(y1, y2);\nloop invariant i12: y1 >= 0 && y2 >= 0;\nloop invariant i13: y1 + y2 >= 0;\nloop invariant measure.a == y1 && measure.b == y2;\nloop variant measure for lexicographic;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    \n//@ ghost measure.a = y1;\n//@ ghost measure.b = y2;\n}\n\t}\n\treturn 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant y1 >= 0 is inductive.\nloop invariant y2 >= 0 is inductive.\nloop invariant y1 > 0 ==> y2 > 0 is inductive.\nloop invariant y1 > 0 is inductive.\nloop invariant y2 > 0 is inductive.\nloop invariant y1 > 0 && y2 > 0 is inductive.\nloop invariant \\abs(y1 - y2) <= \\max(y1, y2) is inductive.\nloop invariant y1 >= 0 && y2 >= 0 is inductive.\nloop invariant y1 + y2 >= 0 is inductive.\n\nLoop variant is Valid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t//@ ghost variant_expression measure = { abs(y1 - y2), y1 + y2 };\n/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\nloop invariant i4: y1 > 0;\nloop invariant i5: y2 > 0;\nloop invariant i7: y1 > 0 && y2 > 0;\nloop invariant i8: \\abs(y1 - y2) <= \\max(y1, y2);\nloop invariant i12: y1 >= 0 && y2 >= 0;\nloop invariant i13: y1 + y2 >= 0;\nloop invariant measure.a == abs(y1 - y2) && measure.b == y1 + y2;\nloop variant measure for lexicographic;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    \n//@ ghost measure.a = abs(y1 - y2);\n//@ ghost measure.b = y1 + y2;\n}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 34: unbound logic function abs. Ignoring loop annotation"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\nloop invariant i4: y1 > 0;\nloop invariant i5: y2 > 0;\nloop invariant i7: y1 > 0 && y2 > 0;\nloop invariant i8: \\abs(y1 - y2) <= \\max(y1, y2);\nloop invariant i12: y1 >= 0 && y2 >= 0;\nloop invariant i13: y1 + y2 >= 0;\nloop variant y1 + y2;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    }\n\t}\n\treturn 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant y1 >= 0 is inductive.\nloop invariant y2 >= 0 is inductive.\nloop invariant y1 > 0 ==> y2 > 0 is inductive.\nloop invariant y1 > 0 is inductive.\nloop invariant y2 > 0 is inductive.\nloop invariant y1 > 0 && y2 > 0 is inductive.\nloop invariant \\abs(y1 - y2) <= \\max(y1, y2) is inductive.\nloop invariant y1 >= 0 && y2 >= 0 is inductive.\nloop invariant y1 + y2 >= 0 is inductive.\n\nLoop variant is Valid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t//@ ghost variant_expression measure = { abs(y1 - y2), y1 };\n/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\nloop invariant i4: y1 > 0;\nloop invariant i5: y2 > 0;\nloop invariant i7: y1 > 0 && y2 > 0;\nloop invariant i8: \\abs(y1 - y2) <= \\max(y1, y2);\nloop invariant i12: y1 >= 0 && y2 >= 0;\nloop invariant i13: y1 + y2 >= 0;\nloop invariant measure.a == abs(y1 - y2) && measure.b == y1;\nloop variant measure for lexicographic;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    \n//@ ghost measure.a = abs(y1 - y2);\n//@ ghost measure.b = y1;\n}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 34: unbound logic function abs. Ignoring loop annotation"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false, true} bool;\n\nint main() {\n    int y1, y2;\n\ty1 = unknown_int();\n\ty2 = unknown_int();\n\tif (y1 > 0 && y2 > 0) {\n    \t//@ ghost variant_expression measure = { y1 + y2, y1 };\n/*@\nloop invariant i1: y1 >= 0;\nloop invariant i2: y2 >= 0;\nloop invariant i3: y1 > 0 ==> y2 > 0;\nloop invariant i4: y1 > 0;\nloop invariant i5: y2 > 0;\nloop invariant i7: y1 > 0 && y2 > 0;\nloop invariant i8: \\abs(y1 - y2) <= \\max(y1, y2);\nloop invariant i12: y1 >= 0 && y2 >= 0;\nloop invariant i13: y1 + y2 >= 0;\nloop invariant measure.a == y1 + y2 && measure.b == y1;\nloop variant measure for lexicographic;\n*/\nwhile (y1 != y2) {\n\t    \tif (y1 > y2) {\n\t\t    \ty1 = y1 - y2;\n    \t\t} else {\n\t    \t\ty2 = y2 - y1;\n\t\t    }\n\t    \n//@ ghost measure.a = y1 + y2;\n//@ ghost measure.b = y1;\n}\n\t}\n\treturn 0;\n}",
                        "checker_output": true,
                        "checker_message": "loop invariant y1 >= 0 is inductive.\nloop invariant y2 >= 0 is inductive.\nloop invariant y1 > 0 ==> y2 > 0 is inductive.\nloop invariant y1 > 0 is inductive.\nloop invariant y2 > 0 is inductive.\nloop invariant y1 > 0 && y2 > 0 is inductive.\nloop invariant \\abs(y1 - y2) <= \\max(y1, y2) is inductive.\nloop invariant y1 >= 0 && y2 >= 0 is inductive.\nloop invariant y1 + y2 >= 0 is inductive.\n\nLoop variant is Valid.\n"
                    }
                ],
                "success": true
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c"
        ],
        "skipped": [],
        "total": 148,
        "success_count": 68,
        "failure_count": 80,
        "success_rate": 0.4594594594594595
    }
}