{
    "logs": {
        "file": "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
        "success": false,
        "log": [
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_invariants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
                    },
                    {
                        "role": "user",
                        "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
                    },
                    "First, note the variable assignments before the loop:\n```\nint i = unknown_int();\nint j = unknown_int();\nint k = unknown_int();\nint an = unknown_int();\nint bn = unknown_int();\nint tk = unknown_int();\n```\n\nNext, analyze the loop condition:\n```\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1)\n```\n\nNow, let's output the necessary loop invariants:\n\n```\n/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant an >= 0;\n    loop invariant bn >= 0;\n\n    loop invariant (an >= i && bn >= j) ==> (j >= \\at(j, Pre) && i >= \\at(i, Pre));\n    loop invariant (an >= i && bn <= j) ==> i >= \\at(i, Pre);\n    loop invariant (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n\n    loop invariant (an >= i && bn >= j) ==> (tk <= k);\n    loop invariant (an <= i && bn >= j) ==> (tk <= k);\n*/\n```",
                    "First, let's make a note of the variable assignments and loop condition:\n- `i`, `j`, `k`, `an`, `bn`, and `tk` are assigned non-deterministic integer values from `unknown_int()` function.\n- Loop condition: `((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1`\n\nNow, let's find the loop invariants:\n\n```\n/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> i >= \\at(i, Pre);\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n    loop invariant k >= tk + 1 ==> tk == \\at(k, Pre) - 1;\n*/\n```\n\nThese loop invariants are true:\n- before the loop execution (i), \n- in every iteration of the loop (ii), and \n- after the loop termination (iii). \n\nThey help in verifying the post-condition of the program.",
                    "First, let's note down the pre-conditions and variable assignments in the program.\n\n1. i, j, k, an, bn, and tk are initialized with unknown_int(), which means they can have any integer value.\n\nNow, let's analyze the loop body and make a note of the loop condition.\n\n2. The loop condition is: \n```\n((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n```\n\nWith this information, we can now output the necessary loop invariants for the while loop:\n\n```\n/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k <= tk + 1;\n*/\n```",
                    "First, make a note of the initial assignments:\n- i, j, k, an, bn, and tk are assigned non-deterministic values.\n\nAnalyze the loop body and make a note of the loop condition:\n- The loop condition is `((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1`.\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply the post-condition. Since there's no post-condition, we'll focus on invariants that hold true throughout the loop.\n\n```\n/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k < tk + 1;\n*/\n```\n\nThese loop invariants hold true before the loop execution, in every iteration of the loop, and after the loop termination.",
                    "First, let's make a note of the variable assignments and loop condition:\n\n- Variable assignments: i, j, k, an, bn, and tk are assigned unknown_int() values.\n- Loop condition: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n\nNow, let's determine the loop invariants:\n\n1. Before the loop execution, all variables i, j, k, an, bn, and tk have arbitrary values.\n2. In every iteration of the loop, the loop condition holds.\n3. After the loop termination, the loop condition is false.\n\nBased on these observations, we can write the loop invariants:\n\n```\n/*@ \n    loop invariant i >= 0 && j >= 0 && k >= 0 && an >= 0 && bn >= 0 && tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j);\n    loop invariant k >= tk + 1;\n*/\n```\n\nThese loop invariants hold true (i) before the loop execution, (ii) in every iteration of the loop, and (iii) after the loop termination."
                ],
                "output": [
                    "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant an >= 0;\n    loop invariant bn >= 0;\n\n    loop invariant (an >= i && bn >= j) ==> (j >= \\at(j, Pre) && i >= \\at(i, Pre));\n    loop invariant (an >= i && bn <= j) ==> i >= \\at(i, Pre);\n    loop invariant (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n\n    loop invariant (an >= i && bn >= j) ==> (tk <= k);\n    loop invariant (an <= i && bn >= j) ==> (tk <= k);\n*/",
                    "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> i >= \\at(i, Pre);\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n    loop invariant k >= tk + 1 ==> tk == \\at(k, Pre) - 1;\n*/",
                    "/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k <= tk + 1;\n*/",
                    "/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k < tk + 1;\n*/",
                    "/*@ \n    loop invariant i >= 0 && j >= 0 && k >= 0 && an >= 0 && bn >= 0 && tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j);\n    loop invariant k >= tk + 1;\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant an >= 0;\n    loop invariant bn >= 0;\n\n    loop invariant (an >= i && bn >= j) ==> (j >= \\at(j, Pre) && i >= \\at(i, Pre));\n    loop invariant (an >= i && bn <= j) ==> i >= \\at(i, Pre);\n    loop invariant (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n\n    loop invariant (an >= i && bn >= j) ==> (tk <= k);\n    loop invariant (an <= i && bn >= j) ==> (tk <= k);\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "Annotation error on line 19: unbound logic variable i. Ignoring loop annotation"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> i >= \\at(i, Pre);\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n    loop invariant k >= tk + 1 ==> tk == \\at(k, Pre) - 1;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "Annotation error on line 17: unbound logic variable i. Ignoring loop annotation"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": true,
                        "invariants": "/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k <= tk + 1;\n*/",
                        "checker_output_for_invariants": true,
                        "checker_message_for_invariants": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\nloop invariant k >= tk + 1 || k <= tk + 1 is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": true,
                        "invariants": "/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k < tk + 1;\n*/",
                        "checker_output_for_invariants": true,
                        "checker_message_for_invariants": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\nloop invariant k >= tk + 1 || k < tk + 1 is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant i >= 0 && j >= 0 && k >= 0 && an >= 0 && bn >= 0 && tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j);\n    loop invariant k >= tk + 1;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant i >= 0 && j >= 0 && k >= 0 && an >= 0 && bn >= 0 && tk >= 0 is neither established nor preserved.\nloop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) is neither established nor preserved.\nloop invariant k >= tk + 1 is neither established nor preserved.\n\n"
                    }
                ],
                "success": true
            },
            {
                "step": "Houdini for individual completion",
                "success": true,
                "completions": [
                    {
                        "num_solver_calls": 5,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant an >= 0;\n    loop invariant bn >= 0;\n\n    loop invariant (an >= i && bn >= j) ==> (j >= \\at(j, Pre) && i >= \\at(i, Pre));\n    loop invariant (an >= i && bn <= j) ==> i >= \\at(i, Pre);\n    loop invariant (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n\n    loop invariant (an >= i && bn >= j) ==> (tk <= k);\n    loop invariant (an <= i && bn >= j) ==> (tk <= k);\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\n\n\n\n\n\n\n\n\n\n\n\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": false
                    },
                    {
                        "num_solver_calls": 5,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant i >= 0;\n    loop invariant j >= 0;\n    loop invariant k >= 0;\n    loop invariant tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> i >= \\at(i, Pre);\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j) ==> j >= \\at(j, Pre);\n    loop invariant k >= tk + 1 ==> tk == \\at(k, Pre) - 1;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\n\n\n\n\n\n\n\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": false
                    },
                    {
                        "num_solver_calls": 0,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k <= tk + 1;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\nloop invariant i1: an >= i || an <= i;\nloop invariant i2: bn >= j || bn <= j;\nloop invariant i3: k >= tk + 1 || k <= tk + 1;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 0,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant an >= i || an <= i;\n    loop invariant bn >= j || bn <= j;\n    loop invariant k >= tk + 1 || k < tk + 1;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\nloop invariant i1: an >= i || an <= i;\nloop invariant i2: bn >= j || bn <= j;\nloop invariant i3: k >= tk + 1 || k < tk + 1;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 2,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant i >= 0 && j >= 0 && k >= 0 && an >= 0 && bn >= 0 && tk >= 0;\n    loop invariant (an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j);\n    loop invariant k >= tk + 1;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\n\n\n\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": false
                    }
                ]
            },
            {
                "step": "Houdini for combined completion",
                "solver_calls": 7,
                "success": true,
                "code_with_combined_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t/*@\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nloop invariant i19: an >= i || an <= i;\nloop invariant i20: bn >= j || bn <= j;\n\n\n\n\n\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}",
                "checker_output": true
            },
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_variants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression  over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\nOutput the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\nIf the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. "
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:  \n```  \n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\twhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program and explain why it is a valid ranking function. Let's think step by step. "
                    },
                    "First, let's analyze the loop. The loop's condition checks if any of the three conditions (an >= i && bn >= j), (an >= i && bn <= j), or (an <= i && bn >= j) are true, and k >= tk + 1. In the loop body, there are three cases that correspond to each of the three conditions in the loop condition.\n\nNow, let's try to find the ranking function. We need to find an expression that decreases with every successive iteration of the loop and remains positive as long as the loop continues executing. Since there are multiple conditions and cases in the loop, we should consider using a lexicographic ranking function.\n\nFor this loop, the lexicographic ranking function can be the following sequence of expressions:\n\n```\n(i - an, j - bn, k - tk - 1)\n```\n\nNow let's explain why this is a valid ranking function.\n\n1. All expressions are positive for the loop to continue executing:\n   - (i - an) is positive when an >= i, which is a part of the loop condition.\n   - (j - bn) is positive when bn >= j, which is also a part of the loop condition.\n   - (k - tk - 1) is positive since k >= tk + 1 is a part of the loop condition.\n\n2. At least one of the expressions must decrease with every successive iteration:\n   - If the first condition (an >= i && bn >= j) is true, i or j will increase in the loop body, causing (i - an) or (j - bn) to decrease.\n   - If the second condition (an >= i && bn <= j) is true, i will increase in the loop body, causing (i - an) to decrease.\n   - If the third condition (an <= i && bn >= j) is true, j will increase in the loop body, causing (j - bn) to decrease.\n\nAs the lexicographic ranking function (i - an, j - bn, k - tk - 1) satisfies the properties of being positive for the loop to continue executing and decreasing with every successive iteration, it is a valid ranking function for the given loop.\n\nHere's the ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant i - an;\n    loop variant j - bn;\n    loop variant k - tk - 1;\n*/\n```",
                    "First, let's identify the conditions and variables in the loop:\n\nLoop condition: ((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n\nVariables:\ni, j, k, an, bn, tk\n\nNow, we need to find a ranking function that decreases with every successive iteration of the loop and is positive for the loop to continue executing.\n\nWe can use a lexicographic ranking function with two expressions: (an - i, k - tk - 1)\n\nNow let's output the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant an - i;\n    loop variant k - tk - 1;\n*/\n```\n\nNow let's explain why this is a valid ranking function:\n\n1. (an - i) is positive when the loop condition is true. In the loop condition, an >= i in the first two cases, and an <= i in the third case. Since the loop condition is an OR operation, if any of these cases is true, the loop will continue executing. Therefore, (an - i) is positive when the loop continues executing.\n\n2. (k - tk - 1) is positive when the loop condition is true. The loop condition checks if k >= tk + 1. Since k is always greater than or equal to tk + 1, (k - tk - 1) is positive when the loop continues executing.\n\n3. With every iteration of the loop, either (an - i) decreases or remains the same. If (an - i) remains the same, then (k - tk - 1) must decrease. In all three cases in the loop body, either i increases or j increases along with tk, causing the expressions to decrease.\n\nTherefore, the lexicographic ranking function (an - i, k - tk - 1) is a valid ranking function for the given loop.",
                    "First, let's identify the loop invariants and the conditions that control the loop execution. The loop continues to execute as long as the following conditions are met:\n\n1. `(an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)`\n2. `k >= tk + 1`\n\nNow, let's find a lexicographic ranking function for this loop. We can use the following expressions:\n\n1. `an - i`\n2. `bn - j`\n3. `k - (tk + 1)`\n\nLet's explain why these expressions form a valid lexicographic ranking function:\n\n1. `an - i`: This expression is always positive when the loop executes, as it is a part of the loop condition. It decreases when `i` increases in the loop, which happens in the first and second branches of the if-else statements.\n2. `bn - j`: This expression is always positive when the loop executes, as it is also a part of the loop condition. It decreases when `j` increases in the loop, which happens in the first and third branches of the if-else statements.\n3. `k - (tk + 1)`: This expression is always positive when the loop executes, as it is part of the second loop condition. It decreases when `k` is updated in the first and third branches of the if-else statements.\n\nNow let's write the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - (tk + 1);\n*/\n```\n\nThese ranking functions ensure that the loop terminates as their values decrease in each iteration, and they are positive as long as the loop continues to execute.",
                    "First, let's analyze the loop conditions and the changes inside the loop. The loop executes as long as one of these three conditions is satisfied:\n\n1. an >= i and bn >= j\n2. an >= i and bn <= j\n3. an <= i and bn >= j\n\nAlso, k >= tk + 1\n\nInside the loop, these are the possible changes to the variables:\n\n- If condition 1 is satisfied:\n  - either j increases by k, and tk is updated with the value of k, and k changes to an unknown value, or\n  - i increases by 1\n\n- If condition 2 is satisfied:\n  - i increases by 1\n\n- If condition 3 is satisfied:\n  - j increases by k, and tk is updated with the value of k, and k changes to an unknown value\n\nBased on the loop conditions and the updates inside the loop, we can determine the following lexicographic ranking function:\n\n```\n/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - tk - 1;\n*/\n```\n\nThis ranking function is valid for the following reasons:\n\n1. The values of the expressions are always positive for the loop to continue executing. When any of the expressions becomes non-positive, the loop will terminate.\n\n2. In each iteration of the loop, at least one of the expressions in the lexicographic order must decrease:\n   - If condition 1 is satisfied, either the first expression (an - i) decreases (when i increases) or the second expression (bn - j) decreases (when j increases).\n   - If condition 2 is satisfied, the first expression (an - i) decreases (when i increases).\n   - If condition 3 is satisfied, the second expression (bn - j) decreases (when j increases).\n\n3. If the value of an expression remains the same, the value of the next expression in the lexicographic order must decrease. This is guaranteed by the conditions and updates inside the loop, as explained above.\n\nSince the ranking function satisfies all the required properties, it is a valid ranking function for the given program loop.",
                    "First, let's analyze the loop condition:\n\n```\n((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1\n```\n\nThis condition can be simplified to:\n\n```\n(an != i || bn != j) && k >= tk + 1\n```\n\nNow, we can observe that there are 3 branches in the loop body:\n\n1. If `an >= i && bn >= j`, either `j` increases by `k` or `i` increases by 1.\n2. If `an >= i && bn <= j`, `i` increases by 1.\n3. If `an <= i && bn >= j`, `j` increases by `k`.\n\nTo find a lexicographic ranking function, we need to consider expressions that will decrease or remain the same in each iteration of the loop.\n\nWe can use the following lexicographic ranking function:\n\n```\n/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - tk - 1;\n*/\n```\n\nLet's explain why this is a valid ranking function:\n\n1. In the first branch, either `j` increases by `k` (decreasing `bn - j`) or `i` increases by 1 (decreasing `an - i`).\n2. In the second branch, `i` increases by 1 (decreasing `an - i`).\n3. In the third branch, `j` increases by `k` (decreasing `bn - j`).\n\nIn each iteration of the loop, at least one of the expressions in the lexicographic ranking function decreases, while the others remain the same or decrease. Additionally, the loop condition ensures that the values of these expressions are positive, as `an != i || bn != j` and `k >= tk + 1`.\n\nTherefore, this lexicographic ranking function proves that the loop must terminate."
                ],
                "output": [
                    "/*@\n    loop variant i - an;\n    loop variant j - bn;\n    loop variant k - tk - 1;\n*/",
                    "/*@\n    loop variant an - i;\n    loop variant k - tk - 1;\n*/",
                    "/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - (tk + 1);\n*/",
                    "/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - tk - 1;\n*/",
                    "/*@\n    loop variant an - i;\n    loop variant bn - j;\n    loop variant k - tk - 1;\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { i - an, j - bn, k - tk - 1 };\n/*@\nloop invariant i19: an >= i || an <= i;\nloop invariant i20: bn >= j || bn <= j;\nloop invariant measure.a == i - an && measure.b == j - bn && measure.c == k - tk - 1;\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = i - an;\n//@ ghost measure.b = j - bn;\n//@ ghost measure.c = k - tk - 1;\n}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { an - i, k - tk - 1 };\n/*@\nloop invariant i19: an >= i || an <= i;\nloop invariant i20: bn >= j || bn <= j;\nloop invariant measure.a == an - i && measure.b == k - tk - 1;\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = an - i;\n//@ ghost measure.b = k - tk - 1;\n}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { an - i, bn - j, k - (tk + 1) };\n/*@\nloop invariant i19: an >= i || an <= i;\nloop invariant i20: bn >= j || bn <= j;\nloop invariant measure.a == an - i && measure.b == bn - j && measure.c == k - (tk + 1);\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = an - i;\n//@ ghost measure.b = bn - j;\n//@ ghost measure.c = k - (tk + 1);\n}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { an - i, bn - j, k - tk - 1 };\n/*@\nloop invariant i19: an >= i || an <= i;\nloop invariant i20: bn >= j || bn <= j;\nloop invariant measure.a == an - i && measure.b == bn - j && measure.c == k - tk - 1;\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = an - i;\n//@ ghost measure.b = bn - j;\n//@ ghost measure.c = k - tk - 1;\n}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\nint c;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b) ||\n (v1.c >= 0 && v1.a == v2.a && v1.b == v2.b && v1.c > v2.c);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint i = unknown_int();\n\tint j = unknown_int();\n\tint k = unknown_int();\n\tint an = unknown_int();\n\tint bn = unknown_int();\n\tint tk = unknown_int();\n\t//@ ghost variant_expression measure = { an - i, bn - j, k - tk - 1 };\n/*@\nloop invariant i19: an >= i || an <= i;\nloop invariant i20: bn >= j || bn <= j;\nloop invariant measure.a == an - i && measure.b == bn - j && measure.c == k - tk - 1;\nloop variant measure for lexicographic;\n*/\nwhile (((an >= i && bn >= j) || (an >= i && bn <= j) || (an <= i && bn >= j)) && k >= tk + 1) {\n\t\tif (an >= i && bn >= j) {\n\t\t\tif (unknown_int()) {\n\t\t\t\tj = j + k;\n\t\t\t\ttk = k;\n\t\t\t\tk = unknown_int();\n\t\t\t} else {\n\t\t\t\ti = i + 1;\n\t\t\t}\n\t\t} else if (an >= i && bn <= j) {\n\t\t\ti = i + 1;\n\t\t} else if (an <= i && bn >= j) {\n\t\t\tj = j + k;\n\t\t\ttk = k;\n\t\t\tk = unknown_int();\n\t\t}\n\t\n//@ ghost measure.a = an - i;\n//@ ghost measure.b = bn - j;\n//@ ghost measure.c = k - tk - 1;\n}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "loop invariant an >= i || an <= i is inductive.\nloop invariant bn >= j || bn <= j is inductive.\n\nLoop variant is Invalid.\n"
                    }
                ],
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Gothenburg_v2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.08.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.03.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.02.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_AG313.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.01.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/easy2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA5.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.06.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Bangalore_v4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c"
        ],
        "skipped": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c"
        ],
        "total": 245,
        "success_count": 121,
        "failure_count": 124,
        "success_rate": 0.49387755102040815
    }
}