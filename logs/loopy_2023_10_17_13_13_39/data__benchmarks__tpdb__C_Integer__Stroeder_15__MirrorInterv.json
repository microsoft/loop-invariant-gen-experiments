{
    "logs": {
        "file": "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MirrorInterv.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    while (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
        "success": false,
        "log": [
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_invariants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
                    },
                    {
                        "role": "user",
                        "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    while (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
                    },
                    "First, let's note the pre-conditions and variable assignments in the program:\n\n- i is assigned an unknown integer value.\n- range is assigned the value 20.\n\nNow let's analyze the loop condition and loop body:\n\n- Loop condition: -range <= i && i <= range\n- Loop body:\n  - If (range-i < 5 || range+i < 5), i = i*(-1)\n  - Else:\n    - range = range+1\n    - i = i-1\n    - If (i == 0), range = -1\n\nNow let's find the necessary loop invariants:\n\n```\n/*@\n    loop invariant -range <= i <= range;\n    loop invariant range >= 20;\n    loop invariant (i >= -range && i <= range) ==> ((range - i >= 5) && (range + i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i < 0) ==> (range - i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i > 0) ==> (range + i >= 5));\n*/\n```",
                    "First, let's make a note of the pre-conditions and variable assignments in the program:\n- i is assigned an unknown integer value.\n- range is assigned the value 20.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is (-range <= i && i <= range).\n\nNow, let's find the loop invariants for the while loop:\n\n```\n/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 20;\n    loop invariant i >= -range;\n    loop invariant i <= range;\n*/\n```",
                    "First, let's list the pre-conditions and variable assignments in the program:\n1. i = unknown_int(); // i is non-deterministic and can be any integer value.\n2. range = 20; // range is initialized to 20.\n\nNow, let's analyze the loop body and make a note of the loop condition:\n- Loop condition: -range <= i && i <= range\n\nNow, let's find the loop invariants for the given program. We will use the implications and conjunctions mentioned in the instructions:\n\n```\n/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant (-range <= i && i <= range) ==> (range-i < 5 || range+i < 5) ==> i == -i;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) ==> range == range+1 && i == i-1;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) && i == 0 ==> range == -1;\n*/\n```\n\nThese loop invariants are true before the loop execution, in every iteration of the loop, and after the loop termination.",
                    "First, let's make a note of the pre-conditions or variable assignments in the program:\n\n1. i is assigned an unknown integer value.\n2. range is assigned the value 20.\n\nNext, let's analyze the loop body and make a note of the loop condition:\n\nLoop Condition: -range <= i && i <= range\n\nNow, let's output the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination, such that the loop invariants imply the post condition.\n\n```\n/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 0;\n    loop invariant range >= 20 ==> (range - i >= 5) && (range + i >= 5);\n*/\n```",
                    "First, let's analyze the given program:\n\nPre-conditions or variable assignments:\n1. `i` is assigned an unknown integer value.\n2. `range` is assigned the value 20.\n\nLoop condition:\nThe loop will continue executing as long as `-range <= i && i <= range`.\n\nNow, let's find the loop invariants:\n\n1. Before the loop execution, `range` is 20.\n2. In every iteration of the loop, `range` is either increased by 1 or remains the same.\n3. After the loop termination, `i` is either less than `-range` or greater than `range`.\n\nTaking these points into account, we can define the following loop invariants:\n\n```\n/*@ \n    loop invariant range >= 20;\n    loop invariant -range <= i <= range;\n*/\n```\nThese loop invariants hold true before the loop execution, in every iteration of the loop, and after the loop termination. They also imply the post-condition that `i` is either less than `-range` or greater than `range` after the loop is terminated."
                ],
                "output": [
                    "/*@\n    loop invariant -range <= i <= range;\n    loop invariant range >= 20;\n    loop invariant (i >= -range && i <= range) ==> ((range - i >= 5) && (range + i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i < 0) ==> (range - i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i > 0) ==> (range + i >= 5));\n*/",
                    "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 20;\n    loop invariant i >= -range;\n    loop invariant i <= range;\n*/",
                    "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant (-range <= i && i <= range) ==> (range-i < 5 || range+i < 5) ==> i == -i;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) ==> range == range+1 && i == i-1;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) && i == 0 ==> range == -1;\n*/",
                    "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 0;\n    loop invariant range >= 20 ==> (range - i >= 5) && (range + i >= 5);\n*/",
                    "/*@ \n    loop invariant range >= 20;\n    loop invariant -range <= i <= range;\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@\n    loop invariant -range <= i <= range;\n    loop invariant range >= 20;\n    loop invariant (i >= -range && i <= range) ==> ((range - i >= 5) && (range + i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i < 0) ==> (range - i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i > 0) ==> (range + i >= 5));\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant -range <= i <= range is neither established nor preserved.\nloop invariant range >= 20 is inductive.\nloop invariant (i >= -range && i <= range) ==> ((range - i >= 5) && (range + i >= 5)) is preserved but not established.\nloop invariant (i >= -range && i <= range) ==> ((i < 0) ==> (range - i >= 5)) is inductive.\nloop invariant (i >= -range && i <= range) ==> ((i > 0) ==> (range + i >= 5)) is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 20;\n    loop invariant i >= -range;\n    loop invariant i <= range;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant -range <= i && i <= range is neither established nor preserved.\nloop invariant range >= 20 is inductive.\nloop invariant i >= -range is inductive.\nloop invariant i <= range is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant (-range <= i && i <= range) ==> (range-i < 5 || range+i < 5) ==> i == -i;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) ==> range == range+1 && i == i-1;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) && i == 0 ==> range == -1;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant -range <= i && i <= range is preserved but not established.\nloop invariant (-range <= i && i <= range) ==> (range-i < 5 || range+i < 5) ==> i == -i is preserved but not established.\nloop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) ==> range == range+1 && i == i-1 is preserved but not established.\nloop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) && i == 0 ==> range == -1 is inductive.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 0;\n    loop invariant range >= 20 ==> (range - i >= 5) && (range + i >= 5);\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant -range <= i && i <= range is neither established nor preserved.\nloop invariant range >= 0 is inductive.\nloop invariant range >= 20 ==> (range - i >= 5) && (range + i >= 5) is preserved but not established.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant range >= 20;\n    loop invariant -range <= i <= range;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant range >= 20 is established but not preserved.\nloop invariant -range <= i <= range is preserved but not established.\n\n"
                    }
                ],
                "success": false
            },
            {
                "step": "Houdini for individual completion",
                "success": true,
                "completions": [
                    {
                        "num_solver_calls": 2,
                        "success": false,
                        "invariants": "/*@\n    loop invariant -range <= i <= range;\n    loop invariant range >= 20;\n    loop invariant (i >= -range && i <= range) ==> ((range - i >= 5) && (range + i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i < 0) ==> (range - i >= 5));\n    loop invariant (i >= -range && i <= range) ==> ((i > 0) ==> (range + i >= 5));\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\n\n\nloop invariant i4: (i >= -range && i <= range) ==> ((i < 0) ==> (range - i >= 5));\nloop invariant i5: (i >= -range && i <= range) ==> ((i > 0) ==> (range + i >= 5));\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 3,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 20;\n    loop invariant i >= -range;\n    loop invariant i <= range;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\n\n\n\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                        "checker_output_after_prune": false
                    },
                    {
                        "num_solver_calls": 2,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant (-range <= i && i <= range) ==> (range-i < 5 || range+i < 5) ==> i == -i;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) ==> range == range+1 && i == i-1;\n    loop invariant (-range <= i && i <= range) ==> !(range-i < 5 || range+i < 5) && i == 0 ==> range == -1;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\n\n\n\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                        "checker_output_after_prune": false
                    },
                    {
                        "num_solver_calls": 3,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant -range <= i && i <= range;\n    loop invariant range >= 0;\n    loop invariant range >= 20 ==> (range - i >= 5) && (range + i >= 5);\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\n\n\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                        "checker_output_after_prune": false
                    },
                    {
                        "num_solver_calls": 2,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant range >= 20;\n    loop invariant -range <= i <= range;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\n\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                        "checker_output_after_prune": false
                    }
                ]
            },
            {
                "step": "Houdini for combined completion",
                "solver_calls": 5,
                "success": false,
                "code_with_combined_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                "checker_output": false
            },
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_variants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression  over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\nOutput the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\nIf the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. "
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:  \n```  \n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    while (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}\n```\nFind the ranking function for the loop in the given program and explain why it is a valid ranking function. Let's think step by step. "
                    },
                    "First, let's identify the loop condition and the variables involved. The loop condition is `-range <= i && i <= range`. The variables involved are `i` and `range`.\n\nNow let's analyze the loop body to understand how `i` and `range` change during the loop execution:\n\n1. If `range - i < 5 || range + i < 5`, then `i = i * (-1)`. In this case, `i` changes its sign, and `range` remains the same.\n2. Otherwise, `range = range + 1`, `i = i - 1`, and if `i == 0`, then `range = -1`. In this case, `range` increases by 1, and `i` decreases by 1.\n\nFrom this analysis, we can observe that the value of `range` increases when the first condition doesn't hold, and the value of `i` decreases. Therefore, we can consider the lexicographic ranking function as follows:\n\n```\n/*@\n    loop variant range;\n    loop variant i;\n*/\n```\n\nNow let's explain why this is a valid ranking function:\n\n1. The values of both `range` and `i` are always positive during the loop execution. The loop condition ensures that `-range <= i <= range`, and since `range` starts at 20 and only increases, both `range` and `i` remain positive.\n2. The value of `range` strictly increases when the first condition doesn't hold, while `i` remains bounded (by the loop condition). Therefore, the loop must eventually terminate as `range` increases and the loop condition becomes false.\n\nThus, the lexicographic ranking function `(range, i)` is a valid ranking function for the given program.",
                    "First, let's analyze the loop conditions and the updates inside the loop. The loop continues executing while `-range <= i && i <= range`. Inside the loop, there are two branches:\n\n1. If either `range-i < 5` or `range+i < 5`, then `i` is updated as `i = i*(-1)`. In this case, the value of `i` is negated, but its absolute value remains the same.\n2. In the other case, `range` is incremented by 1, and `i` is decremented by 1. If `i` becomes 0, then `range` is set to -1.\n\nNow, let's try to identify the ranking function. We can consider a lexicographic ranking function with two expressions: `(range, i)`.\n\nHere's the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant range;\n    loop variant i;\n*/\n```\n\nNow, let's prove that this ranking function is valid:\n\n1. Both `range` and `i` must be positive for the loop to continue executing. This is true, as the loop condition ensures that `i` is within the range of `[-range, range]`, and initially, `range` is set to 20.\n\n2. In each iteration of the loop, either `range` must decrease, or if `range` remains the same, `i` must decrease. This is also true:\n   - In the first branch, `i` is negated, but its absolute value remains the same, and `range` remains the same. In this case, the loop moves closer to one of its boundaries, which will eventually cause the loop to terminate.\n   - In the second branch, `range` is incremented, and `i` is decremented. Since `range` is increased, it satisfies the lexicographic ranking condition. Additionally, `i` is decremented, which moves the loop closer to termination.\n\nTherefore, the ranking function `(range, i)` is a valid ranking function for the given loop.",
                    "First, let's simplify the program and annotate it with ACSL-style loop invariants and variants. We can rewrite the program as follows:\n\n```c\n#include <stdbool.h>\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n\n    /*@\n        loop invariant -range <= i <= range;\n        loop variant range - i;\n        loop variant range + i;\n    */\n    while (-range <= i && i <= range) {\n        if (range - i < 5 || range + i < 5) {\n            i = i * (-1);\n        } else {\n            range = range + 1;\n            i = i - 1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n\n    return 0;\n}\n```\n\nThe loop invariants state that `-range <= i <= range` holds at the beginning of each iteration. Now, let's explain why the proposed ranking functions are valid:\n\n1. `range - i`: This expression decreases when the `else` branch is executed because both `range` and `i` are increased by 1. When the `if` branch is executed, `i` is negated, but since `range - i < 5`, the value of `range - i` is still positive. The value of `range - i` is always positive as long as the loop executes.\n\n2. `range + i`: This expression decreases when the `else` branch is executed as `i` is decreased by 1. When the `if` branch is executed, `i` is negated, but since `range + i < 5`, the value of `range + i` is still positive. The value of `range + i` is always positive as long as the loop executes.\n\nSince both ranking functions are positive and decrease in successive iterations, they form a valid lexicographic ranking function for the loop.",
                    "We can observe that the loop termination depends on the values of `i` and `range`. In each iteration of the loop, either `i` changes its sign or `range` increases by 1 and `i` decreases by 1. We can now use this information to find a lexicographic ranking function.\n\n1. First expression: `range + 21`\nThis expression is always positive since `range` starts at 20 and only increases. It decreases only when `i` becomes 0, which breaks the loop, and the loop never executes again. This expression decreases when the `else` block is executed, and `range` is incremented.\n\n2. Second expression: `abs(i)`\nThis expression is always positive since it is the absolute value of `i`. It decreases when `i` is decremented in the `else` block.\n\nWith these two expressions, we have our lexicographic ranking function:\n\n```\n/*@ \n    loop variant range + 21;\n    loop variant abs(i);\n*/\n```\n\nThis is a valid ranking function because:\n\n- Both expressions are always positive while the loop is executing.\n- The first expression decreases when the `else` block is executed, and when the first expression remains the same, the second expression must decrease when the `else` block is executed.\n- The loop terminates when the condition `-range <= i && i <= range` is no longer true, which is guaranteed by the ranking function as it enforces that `range` and `i` will change in a way that eventually breaks the condition.",
                    "First, let's analyze the loop and its conditions. The loop will continue executing as long as `-range <= i` and `i <= range`. Inside the loop, there are two branches:\n\n1. If `range-i < 5` or `range+i < 5`, then `i` is updated to `-i`.\n2. Otherwise, `range` is incremented by 1, `i` is decremented by 1, and if `i` becomes 0, `range` is set to -1.\n\nNow let's find the ranking function for this loop.\n\n```\n/*@\n    loop invariant -range <= i <= range;\n    loop variant range - abs(i);\n*/\n```\n\nThis is a valid ranking function for the given loop for the following reasons:\n\n1. The loop invariant ensures that `i` always stays within the bounds of `-range` and `range`. This means that the value of `range - abs(i)` will always be non-negative, as required by a ranking function.\n\n2. In the first branch, when `i` is updated to `-i`, the value of `range - abs(i)` remains the same, since the absolute value of `i` doesn't change. In this case, the loop may still continue executing, as the loop condition is still satisfied.\n\n3. In the second branch, both `range` and `i` are updated, but their relationship is preserved, ensuring that the loop invariant holds. As `range` is incremented by 1 and `i` is decremented by 1, the value of `range - abs(i)` strictly decreases by 1 in each iteration.\n\nThus, this ranking function satisfies the requirements of being non-negative and strictly decreasing, ensuring the loop's termination."
                ],
                "output": [
                    "/*@\n    loop variant range;\n    loop variant i;\n*/",
                    "/*@\n    loop variant range;\n    loop variant i;\n*/",
                    "#include <stdbool.h>\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n\n    /*@\n        loop invariant -range <= i <= range;\n        loop variant range - i;\n        loop variant range + i;\n    */\n    while (-range <= i && i <= range) {\n        if (range - i < 5 || range + i < 5) {\n            i = i * (-1);\n        } else {\n            range = range + 1;\n            i = i - 1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n\n    return 0;\n}",
                    "/*@ \n    loop variant range + 21;\n    loop variant abs(i);\n*/",
                    "/*@\n    loop invariant -range <= i <= range;\n    loop variant range - abs(i);\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    //@ ghost variant_expression measure = { range, i };\n/*@\n\nloop invariant measure.a == range && measure.b == i;\nloop variant measure for lexicographic;\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    \n//@ ghost measure.a = range;\n//@ ghost measure.b = i;\n}\n    \n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    //@ ghost variant_expression measure = { range, i };\n/*@\n\nloop invariant measure.a == range && measure.b == i;\nloop variant measure for lexicographic;\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    \n//@ ghost measure.a = range;\n//@ ghost measure.b = i;\n}\n    \n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    //@ ghost variant_expression measure = { range - i, range + i };\n/*@\n\nloop invariant measure.a == range - i && measure.b == range + i;\nloop variant measure for lexicographic;\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    \n//@ ghost measure.a = range - i;\n//@ ghost measure.b = range + i;\n}\n    \n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "\n\nLoop variant is Invalid.\n"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "\n        typedef struct {\n        int a;\nint b;\n} variant_expression;\n\n/*@ \n            predicate lexicographic(variant_expression v1, variant_expression v2) =\n        (v1.a >= 0 && v1.a > v2.a) ||\n (v1.b >= 0 && v1.a == v2.a && v1.b > v2.b);\n*/\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    //@ ghost variant_expression measure = { range + 21, abs(i) };\n/*@\n\nloop invariant measure.a == range + 21 && measure.b == abs(i);\nloop variant measure for lexicographic;\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    \n//@ ghost measure.a = range + 21;\n//@ ghost measure.b = abs(i);\n}\n    \n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 27: unbound logic function abs. Ignoring loop annotation"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\ntypedef enum {false,true} bool;\n\nint main() {\n    int i;\n    int range;\n    i = unknown_int();\n    range = 20;\n    \n    /*@\n\nloop variant range - abs(i);\n*/\nwhile (-range <= i && i <= range) {\n        if (range-i < 5 || range+i < 5) {\n            i = i*(-1);\n        } else {\n            range = range+1;\n            i = i-1;\n            if (i == 0) {\n                range = -1;\n            }\n        }\n    }\n    \n    return 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 15: unbound logic function abs. Ignoring loop annotation"
                    }
                ],
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA6.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Gothenburg_v2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.08.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.03.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Stockholm_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB11.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-cousot9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1c_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.04.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.02.c",
            "../data/benchmarks/tpdb/C/Ultimate/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_AG313.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/non_termination/loop/Adding_Subtracting_Zero_1_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.01.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/easy2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA5.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi3_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.06.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Continue1.c",
            "../data/benchmarks/non_termination/loop/Missing_Corner-case_Handling_2_T.c",
            "../data/benchmarks/non_termination/loop/Using_Erroneous_Condition_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Parallel_true-termination.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_1_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Waldkirch_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron1_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-TACAS2011-Fig4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DivMinus.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex7_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Bangalore_v4_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ComplInterv.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA9.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChooseLife.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-exmini_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Ex8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/4NestedWith3Variables_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.05_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex3.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.07_true-termination.c",
            "../data/benchmarks/tpdb/C/AProVE_numeric/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.21_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron12_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-terminate_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Singapore_true-termination.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_2_T.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/McCarthyIterative.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MirrorInterv.c"
        ],
        "skipped": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/WhileFalse_true-termination.c"
        ],
        "total": 265,
        "success_count": 132,
        "failure_count": 133,
        "success_rate": 0.4981132075471698
    }
}