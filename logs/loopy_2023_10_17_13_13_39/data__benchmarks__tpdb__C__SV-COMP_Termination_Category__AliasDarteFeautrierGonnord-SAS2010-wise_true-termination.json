{
    "logs": {
        "file": "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\twhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "success": false,
        "log": [
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_invariants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**"
                    },
                    {
                        "role": "user",
                        "content": "\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\twhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\nYou are allowed to use implication to take care of the conditional nature of the code. Use implication (==>) instead of using if-then.\n\nFor all variables, add conjunctions that bound the maximum and minimum values that they can take, if such bounds exist.\n\nIf a variable is always equal to or smaller or larger than another variable, add a conjunction for their relation.\n\nIf the assertion is guarded by a condition, use the guard condition in an implication.\n\nIf certain variables are non-deterministic at the beginning or end of the loop, use an implication to make the invariant trivially true at that location. \n\nOutput the loop invariants for the loop in the program above. Let's think step by step."
                    },
                    "Let's analyze the given program:\n\n1. Pre-conditions or variable assignments:\n- x and y are assigned non-deterministic integer values.\n- The loop is entered only if both x and y are non-negative (x >= 0 && y >= 0).\n\n2. Loop condition:\n- The loop continues as long as x - y > 2 or y - x > 2.\n\nNow, let's find the loop invariants:\n\n(i) Before the loop execution:\n- x >= 0 and y >= 0 (from the if condition)\n\n(ii) In every iteration of the loop:\n- If x < y, then x increases by 1.\n- If x >= y, then y increases by 1.\n\n(iii) After the loop termination:\n- The difference between x and y must be less than or equal to 2 (since the loop condition is no longer true).\n\nTaking all these points into consideration, the necessary loop invariants are:\n\n```\n@*/\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x <= y ==> x + 2 >= y;\n  loop invariant y <= x ==> y + 2 >= x;\n/*@ */\n```\n\nThese invariants are true before the loop execution, in every iteration of the loop, and after the loop termination. They ensure that the difference between x and y is less than or equal to 2 when the loop terminates.",
                    "First, let's make a note of the pre-conditions or variable assignments in the program:\n- x and y are assigned non-deterministic integer values.\n- There is an assume statement that ensures x and y are both non-negative before entering the loop.\n\nNow, let's analyze the loop body and make a note of the loop condition:\n- The loop condition is (x - y > 2 || y - x > 2).\n\nNow, let's find the loop invariants for this loop:\n\n```\n/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/\n```\n\nHere is the explanation for the loop invariants:\n- The first loop invariant ensures that x and y remain non-negative throughout the loop execution.\n- The second loop invariant asserts that if x - y is no more than 2, then y - x is also no more than 2.\n- The third loop invariant asserts that if y - x is no more than 2, then x - y is also no more than 2.",
                    "Let's analyze the given C program.\n\nPre-conditions or variable assignments:\n1. x and y are assigned non-deterministic integer values.\n2. The loop is executed only if both x and y are non-negative.\n\nLoop condition:\nThe while loop condition is (x - y > 2 || y - x > 2).\n\nPost-condition: (x - y <= 2 && y - x <= 2)\n\nNow let's find the necessary loop invariants:\n\n/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x >= y ==> x - y <= 2;\n    loop invariant y >= x ==> y - x <= 2;\n*/\nThe above loop invariants ensure that x and y are non-negative, and they also maintain the relationship between x and y as required by the post-condition.",
                    "Pre-conditions and variable assignments:\n- x and y are assigned non-deterministic integer values.\n- The loop executes if both x and y are non-negative.\n\nLoop condition:\n- The loop continues while either x - y > 2 or y - x > 2.\n\nTo find the loop invariants, let's analyze the loop body and the loop condition:\n\n1. If x < y, then x is incremented.\n2. If x >= y, then y is incremented.\n\nNow, let's write the loop invariants that hold before the loop execution, in every iteration of the loop, and after the loop termination:\n\n```\n/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\abs(x - y) > 2 ==> (x < y ? x + 1 : y + 1) == (\\max(x, y) + 1);\n*/\n```\n\nThese loop invariants help Frama-C verify the post-condition of the program.",
                    "Pre-conditions and variable assignments:\n- x and y are assigned non-deterministic integers.\n- The loop is executed only if x >= 0 and y >= 0.\n\nLoop condition:\n- The loop continues as long as x - y > 2 or y - x > 2.\n\nLet's find the necessary loop invariants of the while loop:\n\n```\n/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/\n```"
                ],
                "output": [
                    "@*/\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x <= y ==> x + 2 >= y;\n  loop invariant y <= x ==> y + 2 >= x;\n/*@ */",
                    "/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/",
                    [
                        "ERROR: Output does not contain at least 1 complete code block",
                        "Let's analyze the given C program.\n\nPre-conditions or variable assignments:\n1. x and y are assigned non-deterministic integer values.\n2. The loop is executed only if both x and y are non-negative.\n\nLoop condition:\nThe while loop condition is (x - y > 2 || y - x > 2).\n\nPost-condition: (x - y <= 2 && y - x <= 2)\n\nNow let's find the necessary loop invariants:\n\n/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x >= y ==> x - y <= 2;\n    loop invariant y >= x ==> y - x <= 2;\n*/\nThe above loop invariants ensure that x and y are non-negative, and they also maintain the relationship between x and y as required by the post-condition."
                    ],
                    "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\abs(x - y) > 2 ==> (x < y ? x + 1 : y + 1) == (\\max(x, y) + 1);\n*/",
                    "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 4,
                "completions": [
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "@*/\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x <= y ==> x + 2 >= y;\n  loop invariant y <= x ==> y + 2 >= x;\n/*@ */",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant x >= 0 is inductive.\nloop invariant y >= 0 is inductive.\nloop invariant x <= y ==> x + 2 >= y is preserved but not established.\nloop invariant y <= x ==> y + 2 >= x is preserved but not established.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant x >= 0 && y >= 0 is inductive.\nloop invariant x - y <= 2 ==> y - x <= 2 is preserved but not established.\nloop invariant y - x <= 2 ==> x - y <= 2 is preserved but not established.\n\n"
                    },
                    {
                        "num_solver_calls": 0,
                        "success": false,
                        "llm_output": "Let's analyze the given C program.\n\nPre-conditions or variable assignments:\n1. x and y are assigned non-deterministic integer values.\n2. The loop is executed only if both x and y are non-negative.\n\nLoop condition:\nThe while loop condition is (x - y > 2 || y - x > 2).\n\nPost-condition: (x - y <= 2 && y - x <= 2)\n\nNow let's find the necessary loop invariants:\n\n/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x >= y ==> x - y <= 2;\n    loop invariant y >= x ==> y - x <= 2;\n*/\nThe above loop invariants ensure that x and y are non-negative, and they also maintain the relationship between x and y as required by the post-condition.",
                        "error": "Output does not contain at least 1 code block"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\abs(x - y) > 2 ==> (x < y ? x + 1 : y + 1) == (\\max(x, y) + 1);\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant x >= 0 is inductive.\nloop invariant y >= 0 is inductive.\nloop invariant \\abs(x - y) > 2 ==> (x < y ? x + 1 : y + 1) == (\\max(x, y) + 1) is preserved but not established.\n\n"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/",
                        "checker_output_for_invariants": false,
                        "checker_message_for_invariants": "loop invariant 0 <= x is inductive.\nloop invariant 0 <= y is inductive.\nloop invariant x - y <= 2 ==> y - x <= 2 is preserved but not established.\nloop invariant y - x <= 2 ==> x - y <= 2 is preserved but not established.\n\n"
                    }
                ],
                "success": false
            },
            {
                "step": "Houdini for individual completion",
                "success": true,
                "completions": [
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "@*/\n  loop invariant x >= 0;\n  loop invariant y >= 0;\n  loop invariant x <= y ==> x + 2 >= y;\n  loop invariant y <= x ==> y + 2 >= x;\n/*@ */",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\n\n\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0 && y >= 0;\n\n\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 0,
                        "success": false,
                        "llm_output": "Let's analyze the given C program.\n\nPre-conditions or variable assignments:\n1. x and y are assigned non-deterministic integer values.\n2. The loop is executed only if both x and y are non-negative.\n\nLoop condition:\nThe while loop condition is (x - y > 2 || y - x > 2).\n\nPost-condition: (x - y <= 2 && y - x <= 2)\n\nNow let's find the necessary loop invariants:\n\n/*@ \n    loop invariant x >= 0 && y >= 0;\n    loop invariant x >= y ==> x - y <= 2;\n    loop invariant y >= x ==> y - x <= 2;\n*/\nThe above loop invariants ensure that x and y are non-negative, and they also maintain the relationship between x and y as required by the post-condition.",
                        "error": "Output does not contain at least 1 code block"
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant x >= 0;\n    loop invariant y >= 0;\n    loop invariant \\abs(x - y) > 2 ==> (x < y ? x + 1 : y + 1) == (\\max(x, y) + 1);\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\n\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    },
                    {
                        "num_solver_calls": 1,
                        "success": false,
                        "invariants": "/*@ \n    loop invariant 0 <= x;\n    loop invariant 0 <= y;\n    loop invariant x - y <= 2 ==> y - x <= 2;\n    loop invariant y - x <= 2 ==> x - y <= 2;\n*/",
                        "code_after_prune": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: 0 <= x;\nloop invariant i2: 0 <= y;\n\n\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output_after_prune": true
                    }
                ]
            },
            {
                "step": "Houdini for combined completion",
                "solver_calls": 3,
                "success": true,
                "code_with_combined_invariants": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\n\n\nloop invariant i5: x >= 0 && y >= 0;\n\n\n\nloop invariant i11: 0 <= x;\nloop invariant i12: 0 <= y;\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                "checker_output": true
            },
            {
                "step": "Prompting LLM",
                "generating_annotation": "loop_variants",
                "success": true,
                "llm_chat": [
                    {
                        "role": "system",
                        "content": "A ranking function (also called variant) is an expression  over program variables that are live as the loop head. The value of the expression must decrease with every successive iteration of the loop. And the value must be positive for the loop to continue executing. Finding a ranking function helps prove that the loop must terminate.\nLexicographic ranking functions are a generation. They are a sequence of expressions (e1, e2, ...) with the property that the value of each expression must be positive for the loop to execute. Either e1 must decrease or its value remains the same. If its value remains the same then the value of e2 must decrease.\nFind the ranking function for the loop in the following program and explain why it is a valid ranking function.\n\nInstructions:\nOutput the ranking function in one code block, in ACSL syntax. For example,\n```\n/*@\n    loop variant v;\n*/\n```\nIf the ranking function is a sequence of expressions, output them in different lines in their lexicographic order. "
                    },
                    {
                        "role": "user",
                        "content": "Consider the following C program:  \n```  \n#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\twhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\nFind the ranking function for the loop in the given program and explain why it is a valid ranking function. Let's think step by step. "
                    },
                    "First, let's analyze the loop:\n\nThe loop condition is `x - y > 2 || y - x > 2`, which means the loop continues to execute as long as the absolute difference between `x` and `y` is greater than 2.\n\nInside the loop, either `x` is incremented or `y` is incremented, but not both. This means that the absolute difference between `x` and `y` decreases with every iteration of the loop.\n\nNow, let's find the ranking function:\n\nA possible ranking function for this loop is the absolute difference between `x` and `y`. To express this in ACSL syntax, we can use the following code block:\n\n```\n/*@\n    loop variant abs(x - y);\n*/\n```\n\nThis is a valid ranking function because:\n\n1. The value of the expression `abs(x - y)` is positive for the loop to continue executing, as required by the loop condition `x - y > 2 || y - x > 2`.\n\n2. The value of the expression `abs(x - y)` decreases with every successive iteration of the loop, as either `x` or `y` is incremented, but not both.\n\nThus, the ranking function `abs(x - y)` proves that the loop must terminate.",
                    "First, let's identify the loop condition and the updates to variables inside the loop:\n\nLoop condition: `x - y > 2 || y - x > 2`\nUpdates inside the loop:\n- If `x < y`, then `x++`\n- Else, `y++`\n\nWe are looking for expressions that are positive when the loop is executing and decrease with each iteration.\n\nA possible ranking function for this loop is the absolute difference between `x` and `y`: `|x - y|`. Let's see why this is a valid ranking function:\n\n1. Positivity: When the loop is executing, either `x - y > 2` or `y - x > 2`. In both cases, the absolute difference `|x - y|` is positive.\n\n2. Decreasing: In each iteration, either `x` is incremented or `y` is incremented. In both cases, the absolute difference between `x` and `y` decreases by 1.\n\nSo, the ranking function for this loop is `|x - y|`. Here's the code block with the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant abs(x - y);\n*/\n```",
                    "First, let's understand the loop's condition and its body. The loop continues executing while the absolute difference between x and y is greater than 2. Inside the loop, we increment x if x is less than y, otherwise, we increment y.\n\nNow, let's find the ranking function. We need an expression that decreases with every iteration of the loop and is positive for the loop to continue executing. A suitable ranking function for this loop is the absolute difference between x and y.\n\nHere's the ranking function in ACSL syntax:\n\n```c\n/*@\n    loop variant abs(x - y);\n*/\n```\n\nThis is a valid ranking function because:\n\n1. The value of the expression is positive for the loop to continue executing. Since the loop's condition checks if the absolute difference between x and y is greater than 2, it ensures that the value of the ranking function (abs(x - y)) is positive.\n\n2. The value of the expression decreases with every successive iteration of the loop. In each iteration, either x or y is incremented, which reduces the absolute difference between them. This ensures that the value of the ranking function (abs(x - y)) decreases in every iteration.\n\nTherefore, the ranking function abs(x - y) is valid for this loop, proving that the loop must terminate.",
                    "First, let's analyze the loop:\n\nThe loop continues to execute as long as the condition `(x - y > 2 || y - x > 2)` holds. Inside the loop, if `x < y`, `x` is incremented by 1, otherwise, `y` is incremented by 1.\n\nNow let's find the ranking function:\n\nA possible ranking function for this loop is the absolute difference between `x` and `y`, denoted as `|x - y|`. \n\nHere's why it's a valid ranking function:\n\n1. The value of `|x - y|` is positive when the loop executes since the loop condition `(x - y > 2 || y - x > 2)` guarantees that the difference between `x` and `y` is greater than 2.\n\n2. With each iteration, the value of either `x` or `y` increases, making the absolute difference between `x` and `y` decrease or remain the same.\n\n3. Since the loop continues only when the difference between `x` and `y` is greater than 2, the value of `|x - y|` must eventually become less than or equal to 2, causing the loop to terminate.\n\nNow let's write the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant |x - y|;\n*/\n```\n\nThis ranking function shows that the loop must eventually terminate, as the absolute difference between `x` and `y` decreases with each iteration and is always positive when the loop executes.",
                    "First, let's analyze the loop condition and the loop body:\n\nThe loop condition is: x - y > 2 || y - x > 2\nThis means that the loop continues executing as long as the absolute difference between x and y is greater than 2.\n\nInside the loop, there are two cases:\n1. If x < y, then x is incremented by 1.\n2. If x >= y, then y is incremented by 1.\n\nNow, let's find the ranking function:\n\nA suitable ranking function for this loop is the absolute difference between x and y. Since the loop condition ensures that the absolute difference must be greater than 2 for the loop to continue, and in each iteration, either x or y is incremented by 1, the absolute difference between x and y decreases in each iteration, ensuring the loop's termination.\n\nHere is the ranking function in ACSL syntax:\n\n```\n/*@\n    loop variant abs(x - y);\n*/\n```\n\nThis ranking function is valid because:\n\n1. The value of the ranking function is positive for the loop to continue executing (x - y > 2 || y - x > 2 ensures that abs(x - y) > 2).\n2. The value of the ranking function decreases with every successive iteration of the loop since either x or y is incremented by 1 in each iteration, decreasing the absolute difference between x and y."
                ],
                "output": [
                    "/*@\n    loop variant abs(x - y);\n*/",
                    "/*@\n    loop variant abs(x - y);\n*/",
                    "/*@\n    loop variant abs(x - y);\n*/",
                    "/*@\n    loop variant |x - y|;\n*/",
                    "/*@\n    loop variant abs(x - y);\n*/"
                ]
            },
            {
                "step": "Checking individual completion",
                "solver_calls": 5,
                "completions": [
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i5: x >= 0 && y >= 0;\nloop invariant i11: 0 <= x;\nloop invariant i12: 0 <= y;\nloop variant abs(x - y);\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 15: unbound logic function abs. Ignoring loop annotation"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i5: x >= 0 && y >= 0;\nloop invariant i11: 0 <= x;\nloop invariant i12: 0 <= y;\nloop variant abs(x - y);\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 15: unbound logic function abs. Ignoring loop annotation"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i5: x >= 0 && y >= 0;\nloop invariant i11: 0 <= x;\nloop invariant i12: 0 <= y;\nloop variant abs(x - y);\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 15: unbound logic function abs. Ignoring loop annotation"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i5: x >= 0 && y >= 0;\nloop invariant i11: 0 <= x;\nloop invariant i12: 0 <= y;\nloop variant |x - y|;\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 15: unexpected token '|'"
                    },
                    {
                        "candidate_with_combined_invariants_and_variant": "#define assume(e) if(!(e)) return 0;\nextern int unknown(void);\nextern int unknown_int(void);\n\nint main() {\n\tint x = unknown_int();\n\tint y = unknown_int();\n\tif (x >= 0 && y >= 0) {\n\t\t/*@\nloop invariant i1: x >= 0;\nloop invariant i2: y >= 0;\nloop invariant i5: x >= 0 && y >= 0;\nloop invariant i11: 0 <= x;\nloop invariant i12: 0 <= y;\nloop variant abs(x - y);\n*/\nwhile (x - y > 2 || y - x > 2) {\n\t\t\tif (x < y) {\n\t\t\t\tx++;\n\t\t\t} else {\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
                        "checker_output": false,
                        "checker_message": "Annotation error on line 15: unbound logic function abs. Ignoring loop annotation"
                    }
                ],
                "success": false
            }
        ]
    },
    "stats": {
        "success": [
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BrockschmidtCookFuhs-CAV2013-Introduction_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.12.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/WhileDecr.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.09_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Break.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB2.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LogMult.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_3_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Parallel_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex2.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.11.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/genady_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Nyala-2lex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex3b.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.05.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.20_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_ex1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.05.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.10_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.04.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA7.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_java_Continue1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/aaron2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex1.04_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChawdharyCookGulwaniSagivYang-ESOP2008-random2d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA4.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_fermat.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Overflow.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC3.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.13.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulavaniGulwani-CAV2008-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.06.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-TACAS2011-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/HeizmannHoenickeLeikePodelski-ATVA2013-Fig9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA8.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/HeizmannHoenickeLeikePodelski-ATVA2013-Fig5_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/KroeningSharyginaTsitovichWintersteiger-CAV2010-Ex_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-random1d_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaC9.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_4_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusBuiltIn.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Ex6_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_a.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaB6.c",
            "../data/benchmarks/non_termination/loop/Type_Conversion_in_Comparison_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Update_for_Loop_Iterator_1_T.c",
            "../data/benchmarks/tpdb/C/Ultimate/Bangalore_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-ndecr_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-CAV2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MinusMin.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-WST2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedFails4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.09-no-inv_assume.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Copenhagen_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_easySum.c",
            "../data/benchmarks/non_termination/loop/Unsigned_Wraparound_Error_3_T.c",
            "../data/benchmarks/non_termination/loop/Undefined_Behavior_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.10_true-termination.c"
        ],
        "failure": [
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Hanoi_plus_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/UrbanMine-ESOP2014-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Factorial.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Swingers.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.07_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Piecewise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-LICS2004-Fig2-TACAS2011-Fig3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.03_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Lobnya-Boolean-Reordered_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.22_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a-modified_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.09_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-WST2014-Ex5_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.18_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Benghazi_nondet_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.02_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/GulwaniJainKoskinen-PLDI2009-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure2Phase_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/PodelskiRybalchenko-LICS2004-Fig2_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Cairo_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/LeikeHeizmann-TACAS2014-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_c.07.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.03_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PlusSwap.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/aaron3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-counterex1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex1.01_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/LeikeHeizmann-TACAS2014-Ex9_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Et1.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/2Nested_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.08_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1b_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NoriSharma-FSE2013-Fig8_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Toulouse-BranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/MenloPark_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.13_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-rsd_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex3.09_true-termination.c",
            "../data/benchmarks/non_termination/loop/Signed_Overflow_Error_1_T.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_3_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.06_false-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_b.03-no-inv_assume.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/GopanReps-CAV2006-Fig1a_true-termination.c.c",
            "../data/benchmarks/non_termination/loop/Incorrect_Bit_Calculation_2_T.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Gothenburg_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Thun_true-termination.c",
            "../data/benchmarks/tpdb/C/Ultimate/Pure3Phase_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PastaA10.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-speedpldi2_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Stockholm_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/IntPath.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.19_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Ben-Amram-LMCS2010-Ex2.3_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Fibonacci.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7b_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/DoubleNeg.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex4.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/BradleyMannaSipma-ICALP2005-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChenFlurMukhopadhyay-SAS2012-Ex2.01_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Masse-VMCAI2014-Fig1a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ColonSipma-TACAS2001-Fig1_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-speedpldi4_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/TelAviv-Amir-Minimum_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/svcomp_flag.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/CookSeeZuleger-TACAS2013-Fig8a_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.11_false-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/min_rf_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/ChenFlurMukhopadhyay-SAS2012-Ex2.16_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/Mysore_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/PodelskiRybalchenko-VMCAI2004-Ex2_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/ChawdharyCookGulwaniSagivYang-ESOP2008-aaron6_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/Toulouse-MultiBranchesToLoop_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/McCarthy91_Iteration_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/NO_24.c",
            "../data/benchmarks/tpdb/C_Integer/Stroeder_15/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c",
            "../data/benchmarks/tpdb/C_Integer/Ton_Chanh_15/Copenhagen_disj_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/CookSeeZuleger-TACAS2013-Fig7a_true-termination.c",
            "../data/benchmarks/tpdb/C/SV-COMP_Termination_Category/AliasDarteFeautrierGonnord-SAS2010-wise_true-termination.c"
        ],
        "skipped": [],
        "total": 165,
        "success_count": 77,
        "failure_count": 88,
        "success_rate": 0.4666666666666667
    }
}