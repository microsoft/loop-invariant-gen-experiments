{
    "logs": {
        "file": [
            "../data/new_benchmarks/original_benchmarks/LinearArbitrary-SeaHorn/loops/loops/sum04_false-unreach-call_true-termination.i.annot.c",
            {
                "code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  for(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}"
            }
        ],
        "benchmark_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  for(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
        "llm_conversation": [
            {
                "role": "system",
                "content": "You are a helpful AI software assistant that reasons about how code behaves. Given a program, you can find loop invariants, which can then be used to verify some property in the program. \nFrama-C is a software verification tool for C programs. The input to Frama-C is a C program file with ACSL (ANSI/ISO C Specification Language) annotations.\nFor the given program, find the necessary loop invariants of the while loop to help Frama-C verify the post-condition.\n\nInstructions:\n- Make a note of the pre-conditions or variable assignments in the program.\n- Analyze the loop body and make a note of the loop condition. \n- Output loop invariants that are true \n(i) before the loop execution, \n(ii) in every iteration of the loop and \n(iii) after the loop termination, \nsuch that the loop invariants imply the post condition.\n- If a loop invariant is a conjunction, split it into its parts.\n- Output all the loop invariants in one code block. For example:\n```\n/*@ \n    loop invariant i1;\n    loop invariant i2;\n*/\n```\nRules:\n- **Do not use variables or functions that are not declared in the program.** \n- **Do not make any assumptions about functions whose definitions are not given.**\n- **All undefined variables contain garbage values. Do not use variables that have garbage values.**\n- **Do not use keywords that are not supported in ACSL annotations for loops.**\n- **Variables that are not explicitly initialized, could have garbage values. Do not make any assumptions about such values.**\n- **Do not use the \\at(x, Pre) notation for any variable x.**\n- **Do not use non-deterministic function calls.**\n"
            },
            {
                "role": "user",
                "content": "\n\nConsider the following C program:\n```\n#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  for(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;//@ assert(sn==8*(2)|| sn == 0);\n}\n}\n```\nOutput the loop invariants for the loop in the program above.\nLet's think step by step."
            },
            {
                "role": "assistant",
                "content": " The loop in the program above is a for loop that iterates from 1 to 8. The loop body contains an if statement that checks if the loop counter `i` is less than 4, and if so, it increments the variable `sn` by 2.\n\nTo find the loop invariants, we need to identify the necessary conditions that are true before the loop execution, during each iteration of the loop, and after the loop termination.\n\nBefore the loop execution:\n\n* The loop counter `i` is initialized to 1.\n* The variable `sn` is initialized to 0.\n\nDuring each iteration of the loop:\n\n* The loop counter `i` is incremented by 1.\n* The variable `sn` is incremented by 2 if `i` is less than 4.\n\nAfter the loop termination:\n\n* The loop counter `i` is equal to 8.\n* The variable `sn` is equal to 8 \\* 2 or 0.\n\nTherefore, the loop invariants for this program are:\n\n* `i == 1` before the loop execution.\n* `i <= 8` during each iteration of the loop.\n* `i == 8` after the loop termination.\n* `sn == 0` or `sn == 8 * 2` after the loop termination.\n\nHere's the ACSL annotations for the loop invariants:\n```\n/*@\n    loop invariant i == 1;\n    loop invariant i <= 8;\n    loop invariant i == 8;\n    loop invariant sn == 0 || sn == 8 * 2;\n*/\n```"
            },
            {
                "role": "assistant",
                "content": " The loop in the program above is a `for` loop with a condition `i <= 8`. The loop body contains an `if` statement that increments `sn` by 2 if `i` is less than 4.\n\nTo find the necessary loop invariants, we need to analyze the loop body and the loop condition.\n\nBefore the loop execution, the following loop invariants are true:\n\n* `sn` is equal to 0\n* `i` is equal to 1\n\nDuring every iteration of the loop, the following loop invariants are true:\n\n* `sn` is equal to `i` multiplied by 2\n* `i` is less than or equal to 8\n\nAfter the loop termination, the following loop invariants are true:\n\n* `sn` is equal to 8 multiplied by 2 or 0\n\nTherefore, the necessary loop invariants for the loop in the program above are:\n\n* `sn == 0`\n* `i == 1`\n* `sn == i * 2`\n* `i <= 8`\n\nWe can write these loop invariants in the ACSL annotation as follows:\n```\n/*@ \n    loop invariant sn == 0;\n    loop invariant i == 1;\n    loop invariant sn == i * 2;\n    loop invariant i <= 8;\n*/\n```\nNote that we have split the conjunction of loop invariants into its parts to make it easier to understand. Also, we have used the `@` symbol to indicate that the following code is an ACSL annotation."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the given program, we need to analyze the loop body and the loop condition.\n\nThe loop body consists of a single if statement that checks if `i < 4` and updates `sn` accordingly. The loop condition is `i <= 8`.\n\nFrom the loop body, we can infer the following loop invariants:\n\n1. `sn` is initialized to 0 before the loop starts.\n2. `sn` is incremented by 2 in each iteration of the loop where `i < 4`.\n3. `sn` is not modified in any iteration where `i >= 4`.\n\nNow, let's analyze the loop condition. The loop iterates while `i <= 8`. Since `i` is initialized to 1 and incremented by 1 in each iteration, the loop will terminate when `i` reaches 9.\n\nBased on the above analysis, we can write the loop invariants as follows:\n```\n/*@\n    loop invariant sn == 0 || sn == 8*(2);\n    loop invariant i >= 4 || sn == 0;\n    loop invariant i <= 8 || sn == 8*(2);\n@*/\n```\nThe first loop invariant states that `sn` is either 0 or 16 (i.e., 8 times 2). The second loop invariant states that if `i` is greater than or equal to 4, then `sn` must be 0. The third loop invariant states that if `i` is less than or equal to 8, then `sn` must be 16.\n\nNote that these loop invariants are necessary but not sufficient conditions for the post-condition to hold. To verify the post-condition, we need to ensure that the loop terminates and that the final value of `sn` is 16."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the program, we need to analyze the loop body and the loop condition.\n\n1. The loop body is the code that is executed repeatedly as long as the loop condition is true. In this case, the loop body is:\n```\nif(i<4)\nsn = sn +(2);\n```\nThis code increments the variable `sn` by 2 if `i` is less than 4.\n\n2. The loop condition is the condition that must be true in order for the loop to continue executing. In this case, the loop condition is:\n```\ni<=8\n```\nThis condition checks if `i` is less than or equal to 8.\n\nNow, let's find the loop invariants:\n\n1. Before the loop execution, the variable `sn` must be initialized to 0. This is because the loop body increments `sn` by 2, and we want to ensure that `sn` starts at 0.\n```\nsn == 0\n```\n2. In every iteration of the loop, the variable `sn` must be less than or equal to 8. This is because the loop condition checks if `i` is less than or equal to 8, and we want to ensure that `sn` is not incremented beyond 8.\n```\nsn <= 8\n```\n3. After the loop termination, the variable `sn` must be equal to 8 times 2, or 0. This is because the loop body increments `sn` by 2, and we want to ensure that `sn` is equal to 8 times 2 after the loop has finished executing.\n```\nsn == 8*(2) || sn == 0\n```\nTherefore, the loop invariants for the loop in the program are:\n```\nsn == 0\nsn <= 8\nsn == 8*(2) || sn == 0\n```"
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the given program, we need to analyze the loop body and the loop condition.\n\n1. Pre-conditions:\nThe loop starts with `i = 1` and `sn = 0`.\n2. Loop condition:\nThe loop continues until `i > 8`.\n3. Loop body:\nInside the loop, if `i < 4`, `sn` is increased by `2`.\n4. Post-condition:\nAfter the loop, `sn` is either `8 * 2` or `0`.\n\nNow, let's find the loop invariants that imply the post-condition:\n\n1. Loop invariant (before the loop execution):\n`sn == 0`\n2. Loop invariant (in every iteration of the loop):\n`i >= 1`\n3. Loop invariant (after the loop termination):\n`sn == 8 * 2` or `sn == 0`\n\nSo, the loop invariants for the given program are:\n```\n/*@\n  loop invariant sn == 0;\n  loop invariant i >= 1;\n  loop invariant sn == 8 * 2 || sn == 0;\n*/\n```\nNote that we have used the `||` operator to represent the disjunction of the two loop invariants."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the given C program, we need to analyze the loop body and the loop condition.\n\n1. Loop Body:\nThe loop body consists of a single if statement that updates the value of `sn` based on the value of `i`. If `i` is less than 4, `sn` is updated to be `sn + (2)`. Otherwise, `sn` remains unchanged.\n2. Loop Condition:\nThe loop condition is `i <= 8`.\n3. Loop Invariants:\nTo find the loop invariants, we need to identify the variables that are modified inside the loop body and the variables that are used in the loop condition. In this case, the variable `sn` is modified inside the loop body, and the variable `i` is used in the loop condition.\n\nBased on the above analysis, we can identify the following loop invariants:\n\n* Before the loop execution, `sn` is equal to 0.\n* In every iteration of the loop, `sn` is equal to `sn + (2)` if `i` is less than 4, and `sn` is unchanged if `i` is greater than or equal to 4.\n* After the loop termination, `sn` is equal to `8 * (2)` or 0.\n\nHere are the loop invariants in ACSL annotations:\n```\n/*@\n  loop invariant sn == 0;\n  loop invariant sn == sn + (2) || sn == sn;\n  loop invariant sn == 8 * (2) || sn == 0;\n*/\n```\nNote that we have used the `||` operator to represent the disjunction (or) in the loop invariants. Also, we have used the `==` operator to represent the equality check in the loop invariants."
            },
            {
                "role": "assistant",
                "content": " The program has a single loop, which is a for loop that iterates from 1 to 8. The loop body consists of an if statement that checks if the current value of `i` is less than 4. If it is, the variable `sn` is updated by adding 2 to it.\n\nTo find the loop invariants, we need to analyze the loop body and the loop condition. We can start by identifying the variables that are modified within the loop body. In this case, the only variable that is modified is `sn`.\n\nNext, we need to identify the loop invariant that is true before the loop execution, in every iteration of the loop, and after the loop termination. Let's assume that the loop invariant is `sn <= 8*(2) || sn == 0`. This invariant is true before the loop execution because `sn` is initialized to 0, which is less than or equal to 8*(2). It is also true in every iteration of the loop because `sn` is only updated by adding 2 to it, which is less than or equal to 8*(2). Finally, it is true after the loop termination because the loop terminates when `i` becomes greater than 8, and `sn` is never updated again.\n\nHere is the loop invariant in ACSL notation:\n```\n/*@ \n    loop invariant sn <= 8*(2) || sn == 0;\n*/\n```\nNote that we have assumed that the loop invariant is a conjunction of two conditions: `sn <= 8*(2)` and `sn == 0`. This is not necessarily the case, and the loop invariant could be a more complex expression. However, by breaking it down into its parts, we can better understand the behavior of the loop and identify any potential errors."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the given C program, we can follow these steps:\n\n1. Identify the loop: The loop in the program is the `for` loop with the condition `i <= 8`.\n2. Analyze the loop body: The loop body consists of an `if` statement that checks if `i` is less than 4. If it is, it adds 2 to `sn`.\n3. Identify the loop invariant: A loop invariant is a condition that is true before the loop execution, in every iteration of the loop, and after the loop termination. In this case, the loop invariant is `sn == 8 * (2) || sn == 0`.\n4. Output the loop invariant: The loop invariant can be output in the ACSL annotations for the loop using the `loop invariant` keyword. For example:\n```\n/*@\n    loop invariant sn == 8 * (2) || sn == 0;\n*/\n```\nThis loop invariant ensures that the loop will terminate with `sn` equal to either 8 times 2 or 0, which satisfies the post-condition of the program."
            },
            {
                "role": "assistant",
                "content": " The given program has a single loop, which is the for loop. To find the loop invariants, we need to analyze the loop body and the loop condition.\n\nLoop Body:\nThe loop body contains an if statement that modifies the value of the variable sn. If the condition i < 4 is true, the value of sn is increased by 2.\n\nLoop Condition:\nThe loop condition is i <= 8. The loop will iterate for i = 1, 2, 3, 4, 5, 6, 7, and 8.\n\nLoop Invariants:\n\n1. Before the loop execution, the value of sn is 0.\n2. In every iteration of the loop, the value of sn is either 0 or a multiple of 2.\n3. After the loop termination, the value of sn is either 0 or a multiple of 8.\n\nThe above loop invariants can be used to verify the post-condition of the program. The post-condition is that sn is equal to 8 \\* (2) or 0.\n\nHere is the code block with the loop invariants:\n```\n/*@\n    loop invariant sn == 0 || sn % 2 == 0;\n    loop invariant sn == 0 || sn % 8 == 0;\n*/\n```\nNote that the loop invariants are expressed as a conjunction of two conditions. The first condition is that sn is equal to 0 or a multiple of 2, and the second condition is that sn is equal to 0 or a multiple of 8. These conditions are necessary and sufficient to verify the post-condition of the program."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the program above, we need to analyze the loop body and the loop condition.\n\nFirst, let's identify the pre-conditions and variable assignments in the program. The pre-conditions are:\n\n* `i` is an integer variable that is initially set to 1.\n* `sn` is an integer variable that is initially set to 0.\n\nThe variable assignments are:\n\n* `sn` is set to `sn + (2)` in each iteration of the loop, where `(2)` is a constant value.\n\nNow, let's analyze the loop body and the loop condition. The loop body consists of an `if` statement that checks whether `i` is less than 4. If `i` is less than 4, the loop body executes and `sn` is set to `sn + (2)`. Otherwise, the loop body does not execute.\n\nThe loop condition is `i <= 8`, which means that the loop will execute 8 times.\n\nTo find the loop invariants, we need to identify the conditions that are true before the loop execution, in every iteration of the loop, and after the loop termination.\n\nHere are the loop invariants for the loop in the program above:\n\n1. `i` is an integer variable that is initialized to 1 and is incremented by 1 in each iteration of the loop.\n2. `sn` is an integer variable that is initialized to 0 and is set to `sn + (2)` in each iteration of the loop.\n3. The loop body executes 8 times.\n4. The loop condition is `i <= 8`, which means that the loop will execute 8 times.\n\nHere is the code block that specifies the loop invariants:\n```\n/*@\n    loop invariant i;\n    loop invariant sn;\n    loop invariant i <= 8;\n*/\n```\nNote that the loop invariants are true before the loop execution, in every iteration of the loop, and after the loop termination. The loop invariants imply the post-condition `sn == 8 * (2) || sn == 0`, which means that the loop will terminate with either `sn` equal to 8 times the constant value `(2)` or `sn` equal to 0."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants of the while loop in the given program, we need to analyze the loop body and the loop condition.\n\nThe loop body contains a single if-statement, which is executed only if the loop condition is true. The loop condition is `i<=8`, and the loop body is executed as long as `i` is less than or equal to 8.\n\nThe loop invariant is a condition that is true before the loop execution, in every iteration of the loop, and after the loop termination. To find the loop invariant, we need to identify the conditions that are true before the loop execution, in every iteration of the loop, and after the loop termination.\n\nBefore the loop execution, the variable `i` is initialized to 1, and the variable `sn` is initialized to 0. The loop invariant should be true at this point.\n\nIn every iteration of the loop, the variable `i` is incremented by 1, and the variable `sn` is updated by adding 2 to the previous value of `sn`. The loop invariant should be true at this point.\n\nAfter the loop termination, the variable `i` is no longer updated, and the variable `sn` contains the final value of 8. The loop invariant should be true at this point.\n\nBased on the above analysis, we can identify the following loop invariant:\n```\n/*@ \n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i*2;\n*/\n```\nThe first loop invariant `i >= 1` is true before the loop execution, in every iteration of the loop, and after the loop termination. This is because the variable `i` is initialized to 1, and it is incremented by 1 in every iteration of the loop.\n\nThe second loop invariant `sn >= 0` is true before the loop execution, in every iteration of the loop, and after the loop termination. This is because the variable `sn` is initialized to 0, and it is updated by adding 2 to the previous value of `sn` in every iteration of the loop.\n\nThe third loop invariant `sn == i*2` is true before the loop execution, in every iteration of the loop, and after the loop termination. This is because the variable `sn` is updated by adding 2 to the previous value of `sn` in every iteration of the loop, and the variable `i` is incremented by 1 in every iteration of the loop.\n\nTherefore, the loop invariants for the while loop in the given program are:\n```\n/*@ \n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i*2;\n*/\n```"
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the given program, we need to analyze the loop body and the loop condition.\n\n1. The loop body consists of a single statement, which is an if-statement. The if-statement has a condition `i<4` and a statement `sn = sn +(2)`.\n2. The loop condition is `i<=8`.\n3. The loop invariant should be true before the loop execution, in every iteration of the loop, and after the loop termination.\n\nBased on the above analysis, we can identify the following loop invariants:\n\n1. `i` is a variable that is initialized to 1 before the loop execution and is incremented by 1 in each iteration of the loop. Therefore, the loop invariant `i <= 8` is true before the loop execution, in every iteration of the loop, and after the loop termination.\n2. `sn` is a variable that is initialized to 0 before the loop execution and is incremented by 2 in each iteration of the loop where `i<4`. Therefore, the loop invariant `sn <= 8*2` is true before the loop execution, in every iteration of the loop, and after the loop termination.\n3. The loop invariant `sn == 0` is true before the loop execution, in every iteration of the loop, and after the loop termination, since `sn` is initialized to 0 before the loop execution and is never modified in the loop body.\n\nTherefore, the necessary loop invariants for the loop in the given program are:\n```\n/*@\n    loop invariant i <= 8;\n    loop invariant sn <= 8*2;\n    loop invariant sn == 0;\n*/\n```\nNote that the loop invariants are declared using the `@` keyword, which is used to specify ACSL annotations in C programs."
            },
            {
                "role": "assistant",
                "content": " Sure! Let's find the loop invariants for the loop in the program.\n\n1. Pre-condition:\nThe pre-condition for the loop is `i=1` and `sn=0`.\n2. Loop condition:\nThe loop condition is `i<=8`.\n3. Loop body:\nThe loop body increments `sn` by 2 if `i<4`.\n4. Post-condition:\nThe post-condition is `sn==8*(2)|| sn == 0`.\n\nNow, let's find the loop invariants:\n\n(i) Before the loop execution, the loop invariant is `i=1` and `sn=0`.\n\n(ii) In every iteration of the loop, the loop invariant is `sn` is equal to `2*i` if `i<4`, and `sn` is equal to `0` otherwise.\n\n(iii) After the loop termination, the loop invariant is `sn==8*(2)|| sn == 0`.\n\nSo, the loop invariants are:\n```\n/*@ \n    loop invariant i=1;\n    loop invariant sn=0;\n    loop invariant sn==2*i || sn==0;\n    loop invariant sn==8*(2) || sn==0;\n*/\n```\nNote that we have split the loop invariant into its parts, and we have also added the pre-condition and post-condition as loop invariants."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the given C program, we need to analyze the loop body and the loop condition.\n\nThe loop body is:\n```\nif(i<4)\nsn = sn +(2);\n```\nThe loop condition is:\n```\ni<=8\n```\nNow, let's identify the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination.\n\nBefore the loop execution:\n\n* The variable `sn` is initialized to 0.\n* The variable `i` is initialized to 1.\n\nIn every iteration of the loop:\n\n* The variable `sn` is incremented by 2 if `i` is less than 4.\n* The variable `i` is incremented by 1.\n\nAfter the loop termination:\n\n* The variable `sn` is equal to 8 \\* (2) if the loop terminates due to `i` exceeding 8.\n* The variable `sn` is equal to 0 if the loop terminates due to `i` being equal to 4.\n\nSo, the loop invariants are:\n\n* `sn` is initialized to 0.\n* `i` is initialized to 1.\n* `sn` is incremented by 2 if `i` is less than 4.\n* `i` is incremented by 1.\n* `sn` is equal to 8 \\* (2) if the loop terminates due to `i` exceeding 8.\n* `sn` is equal to 0 if the loop terminates due to `i` being equal to 4.\n\nWe can write these loop invariants in the ACSL annotations for the loop as follows:\n```\n/*@ \n    loop invariant sn == 0;\n    loop invariant i == 1;\n    loop invariant sn + 2*i == 8*(2) || sn + 2*i == 0;\n*/\n```\nNote that we have used the `==` operator to check for equality, and the `||` operator to represent the logical OR."
            },
            {
                "role": "assistant",
                "content": " To find the loop invariants for the loop in the program above, we need to analyze the loop body and the loop condition.\n\nFirst, let's identify the loop variables and the loop condition:\n\n* Loop variables: `i` and `sn`\n* Loop condition: `i <= 8`\n\nNext, we need to find the loop invariants that are true before the loop execution, in every iteration of the loop, and after the loop termination.\n\nBefore the loop execution:\n\n* `i` is initialized to 1\n* `sn` is initialized to 0\n\nIn every iteration of the loop:\n\n* `i` is incremented by 1\n* `sn` is either incremented by 2 or remains the same, depending on the value of `i`\n\nAfter the loop termination:\n\n* `i` is greater than or equal to 8\n* `sn` is either equal to 8 times 2 or 0\n\nBased on the above analysis, we can write the loop invariants as follows:\n```\n/*@\n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i * 2 || sn == 0;\n*/\n```\nNote that we have split the loop invariant into three parts to make it easier to understand and verify."
            }
        ],
        "invariants": [
            "/*@\n    loop invariant i == 1;\n    loop invariant i <= 8;\n    loop invariant i == 8;\n    loop invariant sn == 0 || sn == 8 * 2;\n*/",
            "/*@ \n    loop invariant sn == 0;\n    loop invariant i == 1;\n    loop invariant sn == i * 2;\n    loop invariant i <= 8;\n*/",
            "/*@\n    loop invariant sn == 0 || sn == 8*(2);\n    loop invariant i >= 4 || sn == 0;\n    loop invariant i <= 8 || sn == 8*(2);\n@*/",
            "if(i<4)\nsn = sn +(2);",
            "/*@\n  loop invariant sn == 0;\n  loop invariant i >= 1;\n  loop invariant sn == 8 * 2 || sn == 0;\n*/",
            "/*@\n  loop invariant sn == 0;\n  loop invariant sn == sn + (2) || sn == sn;\n  loop invariant sn == 8 * (2) || sn == 0;\n*/",
            "/*@ \n    loop invariant sn <= 8*(2) || sn == 0;\n*/",
            "/*@\n    loop invariant sn == 8 * (2) || sn == 0;\n*/",
            "/*@\n    loop invariant sn == 0 || sn % 2 == 0;\n    loop invariant sn == 0 || sn % 8 == 0;\n*/",
            "/*@\n    loop invariant i;\n    loop invariant sn;\n    loop invariant i <= 8;\n*/",
            "/*@ \n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i*2;\n*/",
            "/*@\n    loop invariant i <= 8;\n    loop invariant sn <= 8*2;\n    loop invariant sn == 0;\n*/",
            "/*@ \n    loop invariant i=1;\n    loop invariant sn=0;\n    loop invariant sn==2*i || sn==0;\n    loop invariant sn==8*(2) || sn==0;\n*/",
            "/*@ \n    loop invariant sn == 0;\n    loop invariant i == 1;\n    loop invariant sn + 2*i == 8*(2) || sn + 2*i == 0;\n*/",
            "/*@\n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i * 2 || sn == 0;\n*/"
        ],
        "completions": [
            {
                "invariants": "/*@\n    loop invariant i == 1;\n    loop invariant i <= 8;\n    loop invariant i == 8;\n    loop invariant sn == 0 || sn == 8 * 2;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i == 1;\nloop invariant i2: i <= 8;\nloop invariant i3: i == 8;\nloop invariant i4: sn == 0 || sn == 8 * 2;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant i == 1 is inductive.\nloop invariant i <= 8 is inductive.\nloop invariant i == 8 is preserved but not established.\nloop invariant sn == 0 || sn == 8 * 2 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@ \n    loop invariant sn == 0;\n    loop invariant i == 1;\n    loop invariant sn == i * 2;\n    loop invariant i <= 8;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0;\nloop invariant i2: i == 1;\nloop invariant i3: sn == i * 2;\nloop invariant i4: i <= 8;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 0 is inductive.\nloop invariant i == 1 is inductive.\nloop invariant sn == i * 2 is preserved but not established.\nloop invariant i <= 8 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@\n    loop invariant sn == 0 || sn == 8*(2);\n    loop invariant i >= 4 || sn == 0;\n    loop invariant i <= 8 || sn == 8*(2);\n@*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0 || sn == 8*(2);\nloop invariant i2: i >= 4 || sn == 0;\nloop invariant i3: i <= 8 || sn == 8*(2);\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 0 || sn == 8*(2) is established but not preserved.\nloop invariant i >= 4 || sn == 0 is inductive.\nloop invariant i <= 8 || sn == 8*(2) is established but not preserved.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "if(i<4)\nsn = sn +(2);",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "No invariants found.",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants/variants found"
            },
            {
                "invariants": "/*@\n  loop invariant sn == 0;\n  loop invariant i >= 1;\n  loop invariant sn == 8 * 2 || sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0;\nloop invariant i2: i >= 1;\nloop invariant i3: sn == 8 * 2 || sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 0 is established but not preserved.\nloop invariant i >= 1 is inductive.\nloop invariant sn == 8 * 2 || sn == 0 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\nloop invariant i2: i >= 1;\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "loop invariant i >= 1 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@\n  loop invariant sn == 0;\n  loop invariant sn == sn + (2) || sn == sn;\n  loop invariant sn == 8 * (2) || sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0;\nloop invariant i2: sn == sn + (2) || sn == sn;\nloop invariant i3: sn == 8 * (2) || sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 0 is established but not preserved.\nloop invariant sn == sn + (2) || sn == sn is inductive.\nloop invariant sn == 8 * (2) || sn == 0 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\nloop invariant i2: sn == sn + (2) || sn == sn;\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "loop invariant sn == sn + (2) || sn == sn is inductive.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@ \n    loop invariant sn <= 8*(2) || sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn <= 8*(2) || sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn <= 8*(2) || sn == 0 is established but not preserved.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@\n    loop invariant sn == 8 * (2) || sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 8 * (2) || sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 8 * (2) || sn == 0 is established but not preserved.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@\n    loop invariant sn == 0 || sn % 2 == 0;\n    loop invariant sn == 0 || sn % 8 == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0 || sn % 2 == 0;\nloop invariant i2: sn == 0 || sn % 8 == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 0 || sn % 2 == 0 is inductive.\nloop invariant sn == 0 || sn % 8 == 0 is established but not preserved.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0 || sn % 2 == 0;\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "loop invariant sn == 0 || sn % 2 == 0 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@\n    loop invariant i;\n    loop invariant sn;\n    loop invariant i <= 8;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i;\nloop invariant i2: sn;\nloop invariant i3: i <= 8;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant i is inductive.\nloop invariant sn is preserved but not established.\nloop invariant i <= 8 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@ \n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i*2;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i >= 1;\nloop invariant i2: sn >= 0;\nloop invariant i3: sn == i*2;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant i >= 1 is inductive.\nloop invariant sn >= 0 is inductive.\nloop invariant sn == i*2 is preserved but not established.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i >= 1;\nloop invariant i2: sn >= 0;\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "loop invariant i >= 1 is inductive.\nloop invariant sn >= 0 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n"
            },
            {
                "invariants": "/*@\n    loop invariant i <= 8;\n    loop invariant sn <= 8*2;\n    loop invariant sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i <= 8;\nloop invariant i2: sn <= 8*2;\nloop invariant i3: sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant i <= 8 is established but not preserved.\nloop invariant sn <= 8*2 is inductive.\nloop invariant sn == 0 is established but not preserved.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@ \n    loop invariant i=1;\n    loop invariant sn=0;\n    loop invariant sn==2*i || sn==0;\n    loop invariant sn==8*(2) || sn==0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i=1;\nloop invariant i2: sn=0;\nloop invariant i3: sn==2*i || sn==0;\nloop invariant i4: sn==8*(2) || sn==0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "Annotation error on line 6: Assignment operators not allowed in annotations.",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@ \n    loop invariant sn == 0;\n    loop invariant i == 1;\n    loop invariant sn + 2*i == 8*(2) || sn + 2*i == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: sn == 0;\nloop invariant i2: i == 1;\nloop invariant i3: sn + 2*i == 8*(2) || sn + 2*i == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant sn == 0 is inductive.\nloop invariant i == 1 is inductive.\nloop invariant sn + 2*i == 8*(2) || sn + 2*i == 0 is preserved but not established.\nAssertion sn == 8 * 2 || sn == 0: Partially proven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "No invariants found."
            },
            {
                "invariants": "/*@\n    loop invariant i >= 1;\n    loop invariant sn >= 0;\n    loop invariant sn == i * 2 || sn == 0;\n*/",
                "code_with_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i >= 1;\nloop invariant i2: sn >= 0;\nloop invariant i3: sn == i * 2 || sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "success": false,
                "checker_message": "loop invariant i >= 1 is inductive.\nloop invariant sn >= 0 is inductive.\nloop invariant sn == i * 2 || sn == 0 is established but not preserved.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n",
                "success_after_prune": false,
                "pruned_code": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i >= 1;\nloop invariant i2: sn >= 0;\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
                "checker_message_after_prune": "loop invariant i >= 1 is inductive.\nloop invariant sn >= 0 is inductive.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n"
            }
        ],
        "code_with_combined_invariants": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\nloop invariant i1: i == 1;\nloop invariant i2: i <= 8;\nloop invariant i3: i == 8;\nloop invariant i4: sn == 0 || sn == 8 * 2;\nloop invariant i5: sn == 0;\nloop invariant i6: i == 1;\nloop invariant i7: sn == i * 2;\nloop invariant i8: i <= 8;\nloop invariant i9: sn == 0 || sn == 8*(2);\nloop invariant i10: i >= 4 || sn == 0;\nloop invariant i11: i <= 8 || sn == 8*(2);\nloop invariant i12: sn == 0;\nloop invariant i13: i >= 1;\nloop invariant i14: sn == 8 * 2 || sn == 0;\nloop invariant i15: sn == 0;\nloop invariant i16: sn == sn + (2) || sn == sn;\nloop invariant i17: sn == 8 * (2) || sn == 0;\nloop invariant i18: sn <= 8*(2) || sn == 0;\nloop invariant i19: sn == 8 * (2) || sn == 0;\nloop invariant i20: sn == 0 || sn % 2 == 0;\nloop invariant i21: sn == 0 || sn % 8 == 0;\nloop invariant i22: i;\nloop invariant i23: sn;\nloop invariant i24: i <= 8;\nloop invariant i25: i >= 1;\nloop invariant i26: sn >= 0;\nloop invariant i27: sn == i*2;\nloop invariant i28: i <= 8;\nloop invariant i29: sn <= 8*2;\nloop invariant i30: sn == 0;\nloop invariant i31: i=1;\nloop invariant i32: sn=0;\nloop invariant i33: sn==2*i || sn==0;\nloop invariant i34: sn==8*(2) || sn==0;\nloop invariant i35: sn == 0;\nloop invariant i36: i == 1;\nloop invariant i37: sn + 2*i == 8*(2) || sn + 2*i == 0;\nloop invariant i38: i >= 1;\nloop invariant i39: sn >= 0;\nloop invariant i40: sn == i * 2 || sn == 0;\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
        "checker_output": false,
        "checker_message": "Annotation error on line 36: Assignment operators not allowed in annotations.",
        "code_after_combine_and_prune": "#define assume(e) if(!(e)) return 0;\n\nint main(){\n  int  i,  sn=0;\n  /*@\n\n\n\n\n\n\n\n\n\nloop invariant i13: i >= 1;\n\n\n\n\n\n\nloop invariant i22: i;\n\n\n\n\n\n\n\n\n\n\n*/\nfor(i=1; i<=8; i++){\n    if(i<4)\n    sn = sn +(2);\n  }\n  {;\n//@ assert(sn==8*(2)|| sn == 0);\n}\n}",
        "checker_output_after_combine_and_prune": false,
        "checker_message_after_combine_and_prune": "loop invariant i >= 1 is inductive.\nloop invariant i is inductive.\nAssertion sn == 8 * 2 || sn == 0: Unproven\n"
    },
    "stats": {
        "success": [
            0,
            1,
            6,
            9,
            12,
            19,
            25,
            26,
            27,
            28,
            34,
            37,
            38,
            39,
            40,
            43,
            49,
            52,
            58,
            60,
            63,
            64,
            65,
            66,
            68,
            72,
            73,
            79,
            83,
            85,
            86,
            87,
            88,
            96,
            100,
            101,
            102,
            104,
            109,
            112,
            115,
            118,
            128,
            129,
            130,
            137,
            138,
            144
        ],
        "failure": [
            2,
            3,
            4,
            5,
            7,
            8,
            10,
            11,
            13,
            14,
            15,
            16,
            17,
            18,
            20,
            21,
            22,
            23,
            24,
            29,
            30,
            31,
            32,
            33,
            35,
            36,
            41,
            42,
            44,
            45,
            46,
            47,
            48,
            50,
            51,
            53,
            54,
            55,
            56,
            57,
            59,
            61,
            62,
            67,
            69,
            70,
            71,
            74,
            75,
            76,
            77,
            78,
            80,
            81,
            82,
            84,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            97,
            98,
            99,
            103,
            105,
            106,
            107,
            108,
            110,
            111,
            113,
            114,
            116,
            117,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            131,
            132,
            133,
            134,
            135,
            136,
            139,
            140,
            141,
            142,
            143,
            145
        ],
        "skipped": [],
        "total": 146,
        "success_rate": 0.3287671232876712
    }
}